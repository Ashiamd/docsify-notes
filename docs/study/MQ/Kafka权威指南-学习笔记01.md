# Kafka权威指南-学习笔记01

# 1. 初识Kafka

## 1. 1 发布与订阅消息系统

### 1 .1 .1 如何开始

### 1.1.2 独立的队列系统

## 1.2 Kafka 登场

### 1.2.1 消息和批次

+ Kafka 的数据单元被称为**消息**
+ 为了提高效率，消息被分批次写入Kafka 。**批次**就是一组消息，这些消息属于同一个主题和分区

### 1.2.2 模式

​	对于Kafka 来说，消息不过是晦涩难懂的字节数组，所以有人建议用一些额外的结构来定义消息内容，让它们更易于理解。根据应用程序的需求，消息**模式**（ schema ）有许多可用的选项（JSON、XML、proto、Avro等）。

### * 1.2.3 主题和分区

​	Kafka 的消息通过**主题**进行分类。主题就好比数据库的表，或者文件系统里的文件夹。主题可以被分为若干个**分区**， 一个分区就是一个提交日志。消息以追加的方式写入分区，然后以先入先出的顺序读取。<u>要注意，由于一个主题一般包含几个分区，因此**无法在整个主题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序**</u>。

​	图1-5 所示的主题有4个分区，消息被迫加写入<u>每个分区</u>的尾部。Kafka 通过分区来实现数据冗余和伸缩性。分区可以分布在不同的服务器上，也就是说， 一个主题可以横跨多个服务器，以此来提供比单个服务器更强大的性能。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16add12a4299ce6a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

​	图1- 5：包含多个分区的主题表示

### * 1.2.4 生产者和消费者

​	<u>Kafka 的客户端</u>就是Kafka系统的用户，它们被分为两种基本类型：**生产者**和**消费者**。除此之外，还有其他高级客户端API —— 用于数据集成的Kafka Connect API 和用于流式处理的Kafka Streams 。这些高级客户端API使用生产者和消费者作为内部组件，提供了高级的功能。

+ **生产者**创建消息。在其他发布与订阅系统中，生产者可能被称为<u>发布者</u>或<u>写入者</u>。一般情况下，一个消息会被发布到一个特定的主题上。生产者在默认情况下把消息均衡地分布到主题的所有分区上，而并不关心特定消息会被写到哪个分区。不过，在某些情况下，生产者会把消息直接写到指定的分区。这通常是通过消息键和分区器来实现的，分区器为键生成一个散列值，并将其映射到指定的分区上。这样可以保证包含同一个键的消息会被写到同一个分区上。生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到分区。第3章将详细介绍生产者。

+ **消费者**读取消息。在其他发布与订阅系统中，消费者可能被称为<u>订阅者</u>或<u>读者</u>。消费者订阅一个或多个主题，并按照消息生成的顺序读取它们。<u>消费者通过检查消息的偏移盘来区分已经读取过的消息</u>。偏移量是另一种元数据，它是一个不断递增的整数值，在创建消息时， Kafka 会把它添加到消息里。在给定的分区里，每个消息的偏移量都是唯一的。<u>消费者把每个分区最后读取的消息偏移量保存在Zookeeper 或Kafka 上，如果消费者关闭或重启，它的读取状态不会丢失</u>。

​	消费者是**消费者群组**的一部分，也就是说，会有一个或多个消费者共同读取一个主题。<u>**群组保证每个分区只能被一个消费者使用**</u>。图1-6 所示的群组中，有3 个消费者同时读取一个主题。其中的两个消费者各自读取一个分区，另外一个消费者读取其他两个分区。<u>消费者与分区之间的映射通常被称为消费者对分区的所有权关系</u>。

​	**通过这种方式，消费者可以消费包含大量消息的主题。而且，如果一个消费者失效，群组里的其他消费者可以接管失效消费者的工作**。第4章将详细介绍消费者和悄费者群组。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16add12a4233c775~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

​	图1-6 ：消费者群组从主题读取消息

### * 1.2.5 broker和集群

​	**一个独立的<u>Kafka 服务器</u>被称为broker**。

+ broker接收来自生产者的消息，**为消息设置偏移量**，并提交消息到磁盘保存。
+ broker为消费者提供服务，对读取<u>分区</u>的请求作出响应，返回已经提交到磁盘上的消息。

​	<u>根据特定的硬件及其性能特征，单个broker可以轻松处理数千个分区以及每秒百万级的消息量</u>。

​	broker 是**集群**的组成部分。<u>每个集群都有一个broker 同时充当了**集群控制器**的角色（自动从集群的活跃成员中选举出来）。**控制器负责管理工作，包括将分区分配给broker 和监控broker**</u>。

​	<u>在集群中， 一个分区从属于一个broker，该broker 被称为分区的**首领**</u>。

​	**一个分区可以分配给多个broker**，这个时候会发生**分区复制**（见图1-7）。**这种复制机制为分区提供了消息冗余，如果有一个broker 失效，其他broker 可以接管领导权。不过，<u>相关的消费者和生产者都要重新连接到新的首领</u>**。第6章将详细介绍集群的操作，包括分区复制。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16add12a43368941~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

​	图1-7 ：集群里的分区复制

​	**保留消息**（在一定期限内）是Kafka 的一个重要特性。

​	Kafka broker 默认的消息保留策略是这样的：

+ 要么保留一段时间（比如7 天）
+ 要么保留到消息达到一定大小的字节数（比如1GB ）。当消息数量达到这些上限时，旧消息就会过期井被删除。

​	所以在任何时刻， 可用消息的总量都不会超过配置参数所指定的大小。<u>主题可以配置自己的保留策略，可以将消息保留到不再使用它们为止</u>。

​	例如，用于跟踪用户活动的数据可能需要保留几天，而应用程序的度量指标可能只需要保留几个小时。可以通过配置把主题当作**紧凑型日志**， 只有最后一个带有特定键的消息会被保留下来。这种情况对于变更日志类型的数据来说比较适用，因为人们只关心最后时刻发生的那个变更。

### * 1.2.6 多集群

​	随着Kafka 部署数量的增加，基于以下几点原因，最好使用多个集群。

+ 数据类型分离

+ 安全需求隔离

+ 多数据中心（灾难恢复）

​	**如果使用多个数据中心，就需要在它们之间复制消息**。这样，在线应用程序才可以访问到多个站点的用户活动信息。*例如，如果一个用户修改了他们的资料信息，不管从哪个数据中心都应该能看到这些改动。或者多个站点的监控数据可以被聚集到一个部署了分析程序和告警系统的中心位置*。不过， **<u>Kafka的消息复制机制只能在单个集群里进行，不能在多个集群之间进行</u>**。

​	Kafka 提供了一个叫作MirrorMaker 的工具，可以用它来实现集群间的消息复制。<u>MirrorMaker的核心组件包含了一个生产者和一个消费者，两者之间通过一个队列相连</u>。**消费者从一个集群读取消息，生产者把消息发送到另一个集群上**。

​	![v2-8869847fc733df34a94a54d4d9076ee5_b.jpg](https://img-blog.csdnimg.cn/img_convert/e1e93adef38fa5a0084cb6e0b34d21e7.png)

​	图1-8 ： 多数据中的架构

​	图1-8 展示了一个使用MirrorMaker 的例子，两个“本地”集群的消息被聚集到一个“聚合”集群上，然后将该集群复制到其他数据中心。不过，这种方式在创建复杂的数据管道方面显得有点力不从心。第7章将详细讨论这些案例。

## 1.3 为什么选择Kafka

### 1.3.1 多个生产者

​	<u>Kafka可以无缝地支持多个生产者，不管客户端在使用单个主题还是多个主题</u>。所以它很适合用来从多个前端系统收集数据，并以统一的格式对外提供数据。例如， 一个包含了多个微服务的网站，可以为页面视图创建一个单独的主题，所有服务都以相同的消息格式向该主题写入数据。消费者应用程序会获得统一的页面视图，而无需协调来自不同生产者的数据流。

### * 1.3.2 多个消费者

​	<u>除了支持多个生产者外， Kafka 也支持多个消费者从一个单独的消息流上读取数据，而且**消费者之间互不影响**</u>。这与其他队列系统不同，其他队列系统的消息一旦被一个客户端读取，其他客户端就无法再读取它。**另外，多个消费者可以组成一个群组，它们共享一个消息流，并<u>保证整个群组对每个给定的消息只处理一次</u>**。

### 1.3. 3 基于磁盘的数据存储

​	Kafka 不仅支持多个消费者，还允许消费者非实时地读取消息，这要归功于Kafka 的数据保留特性。消息被提交到磁盘，根据设置的保留规则进行保存。**每个主题可以设置单独的保留规则**，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。消费者可能会因为处理速度慢或突发的流量高峰导致无法及时读取消息，而持久化数据可以保证数据不会丢失。消费者可以在进行应用程序维护时离线一小段时间，而无需担心消息丢失或堵塞在生产者端。<u>消费者可以被关闭，但消息会继续保留在Kafka 里。消费者可以从上次中断的地方继续处理消息</u>。

### 1.3.4 伸缩性

​	为了能够轻松处理大量数据， Kafka 从一开始就被设计成一个具有灵活伸缩性的系统。用户在开发阶段可以先使用单个broker ，再扩展到包含3个broker 的小型开发集群，然后随着数据量不断增长，部署到生产环境的集群可能包含上百个broker 。<u>对在线集群进行扩展丝毫不影响整体系统的可用性。也就是说， 一个包含多个broker 的集群，即使个别broker失效，仍然可以持续地为客户提供服务</u>。<u>要提高集群的容错能力，需要配置较高的复制系数</u>。第6章将讨论关于复制的更多细节。

### 1.3.5 高性能

​	上面提到的所有特性，让Kafka 成为了一个高性能的**发布与订阅消息**系统。通过横向扩展生产者、消费者和broker，Kafka可以轻松处理巨大的消息流。在处理大量数据的同时，它还能保证**亚秒级**的消息延迟。

## 1.4 数据生态系统

​	Kafka 为数据生态系统带来了循环系统，如图1-9 所示。它在基础设施的各个组件之间传递消息，为所有客户端提供一致的接口。<u>当与提供消息模式的系统集成时，生产者和消费者之间不再有紧密的祸合，也**不需要在它们之间建立任何类型的直连**</u>。我们可以根据业务需要添加或移除组件．因为生产者不再关心谁在使用数据，也不关心有多少个消费者。

![v2-90d0e87bef7b3732cfd70a8c78710e95_b.jpg](https://img-blog.csdnimg.cn/img_convert/14b915f52caadd0f56ff37357dbce671.png)

​	圄1-9 ：大数据生态系统

​	使用场景：

1. 活动跟踪

2. 传递消息
3. 度量指标和日志记录
4. 提交日志
5. 流处理

## 1.5 起源故事

​	Kafka 是为了解决Linkedln数据管道问题应运而生的。<u>它的设计目的是提供一个高性能的消息系统，可以处理多种数据类型，并能够实时提供纯净且结构化的用户活动数据和系统度量指标</u>。

### 1.5.1 Linkedln的问题

​	最开始，我们调研了一些现成的开源解决方案，希望能够找到一个系统，可以实时访问数据，并通过横向扩展来处理大量的悄息。我们使用ActiveMQ 创建了一个原型系统，但它当时还无能满足横向扩展的需求。Linkedln 不得不使用这种脆弱的解决方案， 虽然ActiveMQ 有很多触陷会导致broker 暂停服务。客户端的连接因此被阻塞，处理用户请求的能力也受到影响。于是我们最后决定构建自己的基础设施。

### 1.5.2 Kafka 的诞生

​	Linkedln 的开发团队由Jay Kreps 领导。Jay Kreps 是Linkedln 的首席工程师，之前负责分布式键值存储系统Voldemort的开发。初建团队成员还包括Neha Narkhede ，不久之后，Jun Rao 也加入了进来。他们一起着手创建一个消息系统，可以同时满足上述的两种需求，并且可以在未来进行横向扩展。他们的主要目标如下：

+ 使用推送和拉取模型解耦生产者和消费者

+ 为消息传递系统中的消息提供数据持久化，以便支持多个消费者
+ 通过系统优化实现高吞吐量
+ 系统可以随着数据流的增长进行横向扩展

​	最后我们看到的这个发布与订阅消息系统具有典型的消息系统接口，但从存储层来看，它更像是一个日志聚合系统。Kafka 使用Avro作为消息序列化框架，每天高效地处理数十亿级别的度量指标和用户活动跟踪信息。Linkedln已经拥有超过万亿级别的消息使用量（截止到2015 年8 月），而且每天仍然需要处理超过千万亿字节的数据。

### 1.5.3 走向开源

​	2010 年底， Kafka 作为开源项目在GitHub 上发布。2011年7月，因为倍受开源社区的关注，它成为Apache软件基金会的孵化器项目。2012年10 月， Kafka 从孵化器项目毕业。	

### 1.5.4 命名

## 1.6 开始Kafka之旅

## 2. 安装Kafka

## 2.1 要事先行

### 2.1.1 选择操作系统

### 2.1.2 安装Java

​	在安装Zookeeper和Kafka之前，需要先安装Java环境。

### 2.1.3 安装Zookeeper

​	**Kafka 使用Zookeeper 保存集群的元数据信息和消费者信息**。Kafka 发行版自带了Zookeeper ，可以直接从脚本启动，不过安装一个完整版的Zookeeper 也并不费劲。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112413373216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94aWFvY2hlbmd4aW55aXpoYW4uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70)

图2-1 : Kafka 和Zookeeper

## 2.2 安装Kafka Broker

## 2.3 broker配置

### 2.3.1 常规配置

​	有一些配置选项，在单机安装时可以直接使用默认值，但在部署到其他环境时要格外小心。这些参数是单个服务器最基本的配置，它们中的大部分需要经过修改后才能用在集群里。

1. broker.id

   每个broker 都需要有一个标识符，使用broker.id 来表示。它的默认值是0 ，也可以被设置成其他任意整数。**这个值在整个Kafka 集群里必须是唯一的**。这个值可以任意选定，如果出于维护的需要，可以在服务器节点间交换使用这些ID 。建议把它们设置成与机器名具有相关性的整数，这样在进行维护时，将ID 号映射到机器名就没那么麻烦了。例如，如果机器名包含唯一性的数字（比如hostl . example.com 、host2.example.com），那么用这些数字来设置broker.id 就再好不过了。

2. port

   如果使用配置样本来启动Kafka ，它会监听9092 端口。修改port配置参数可以把它设置成其他任意可用的端口。要注意，如果使用1024以下的端口，需要使用root权限启动Kafka ，不过不建议这么做。

3. Zookeeper.connect

   **用于保存broker元数据的Zookeeper 地址是通过zookeeper.connect 来指定的**。`localhost:2181`表示这个Zookeeper 是运行在本地的2181端口上。该配置参数是用冒号分隔的一组`hostname:port/path`列表，每一部分的含义如下：

   + hostname 是Zookeeper 服务器的机器名或IP 地址

   + port 是Zookeeper 的客户端连接端口

   + /path 是可选的Zookeeper 路径，作为Kafka集群的chroot 环境。如果不指定，默认使用根路径。

   如果指定的chroot路径不存在， broker 会在启动的时候创建它。

   > 为什么使用chroot路径
   >
   > 在Kafka 集群里使用chroot 路径是一种最佳实践。Zookeeper 群组可以共享给其他应用程序，即使还有其他Kafka集群存在， 也不会产生冲突。最好是在配置文件里指定一组Zookeeper服务器，用分号把它们隔开。一旦有一个Zookeeper 服务器岩机， broker可以连接到Zookeeper群组的另一个节点上。

4. log.dirs

   **Kafka把所有消息都保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的**。它是一组用逗号分隔的本地文件系统路径。<u>如果指定了多个路径，那么broker 会根据“最少使用”原则，把同一个分区的日志片段保存到同一个路径下</u>。要注意， broker 会往拥有最少数目分区的路径新增分区，而不是往拥有最小磁盘空间的路径新增分区。

5. num.recovery.threads.per.data.dir

   对于如下3种情况， Kafka 会使用可配置的线程池来处理日志片段：

   + 服务器正常启动，用于打开每个分区的日志片段

   + 服务器崩愤后重启，用于检查和截短每个分区的日志片段
   + 服务器正常关闭，用于关闭日志片段

   <u>默认情况下，每个日志目录只使用一个线程</u>。因为这些线程只是在服务器启动和关闭时会用到，所以完全可以设置大量的线程来达到井行操作的目的。特别是对于包含大量分区的服务器来说， 一旦发生崩愤，在进行恢复时使用井行操作可能会省下数小时的时间。设此参数时需要注意，所配置的数字对应的是log.dirs指定的单个日志目录。也就是说，如果num.recovery.threads.per.data.dir被设为8 ， 井且log.dir指定了3 个路径，那么总共需要24 个线程。

6. auto.create.topics.enable

   默认情况下， Kafka 会在如下几种情形下<u>自动创建主题</u>：

   + 当一个生产者开始往主题写入消息时

   + 当一个消费者开始从主题读取消息时

   + 当任意一个客户端向主题发送元数据请求时。

   很多时候，这些行为都是非预期的。而且，根据Kafka协议，如果一个主题不先被创建，根本无法知道它是否已经存在。如果显式地创建主题， 不管是手动创建还是通过其他配置系统来创建，都可以把auto.create.topics.enable设为false 。

### * 2.3.2 主题的默认配置

​	Kafka 为新创建的主题提供了很多默认配置参数。可以通过管理工具（将在第9 章介绍）为每个主题单独配置一部分参数，比如分区个数和数据保留策略。服务器提供的默认配置可以作为基准，它们适用于大部分主题。

> 使用主题配置覆盖（override)
>
> 之前的Kafka 版本允许主题覆盖服务器的默认配置，包括log.retention.hours.per.topic 、log.retention.bytes.per.topic和log.segment.bytes.per.topic 这几个参数。新版本不再支持这些参数，而且如果要对参数进行覆盖，需要使用管理工具。

1. num.paritions

   num.paritions参数指定了新创建的主题将包含多少个分区。如果启用了主题自动创建功能（该功能默认是启用的），主题分区的个数就是该参数指定的值。该参数的默认值是1。**要注意，我们可以增加主题分区的个数，但不能减少分区的个数**。所以，如果要让一个主题的分区个数少于num.partitions指定的值，需要手动创建该主题（将在第9章讨论）。

   第1章里已经提到， Kafka集群通过分区对主题进行横向扩展，所以当有新的broker 加入集群时，可以通过分区个数来实现集群的负载均衡。当然，这并不是说，在存在多个主题的情况下（它们分布在多个broker上），为了能让分区分布到所有broker上， 主题分区的个数必须要大于broker的个数。不过，<u>拥有大量消息的主题如果要进行负载分散，就需要大量的分区</u>。

   > 如何选定分区数量
   >
   > 为主题选定分区数量并不是一件可有可无的事情，在进行数量选择时，需要考虑如下几个因素。
   >
   > + 主题需要达到多大的吞吐量？例如，是希望每秒钟写入100KB 还是1GB?
   >
   > + 从单个分区读取数据的最大吞吐量是多少？每个分区一般都会有一个消费者，如果你知道消费者将数据写入数据库的速度不会超过每秒50MB ，那么你也该知道，从一个分区读取数据的吞吐量不需要超过每秒50MB 。
   >
   > + 可以通过类似的方法估算生产者向单个分区写入数据的吞吐量，不过生产者的速度一般比消费者快得多，所以最好为生产者多估算一些吞吐量。
   >
   > + 每个broker 包含的分区个数、可用的磁盘空间和网络带宽。
   >
   > + <u>如果消息是按照不同的键来写入分区的，那么为已有的主题新增分区就会很困难</u>。
   >
   > + **单个broker 对分区个数是有限制的，因为分区越多，占用的内存越多，完成首领选举需要的时间也越长**。

   很显然，综合考虑以上几个因素，你需要很多分区，但不能太多。**如果你估算出主题的吞吐量和消费者吞吐量，可以用主题吞吐量除以消费者吞吐量算出分区的个数**。也就是说，如果每秒钟要从主题上写入和读取1GB 的数据，并且每个消费者每秒钟可以处理50MB的数据，那么至少需要20个分区。这样就可以让20 个消费者同时读取这些分区，从而达到每秒钟1GB 的吞吐量。

   如果不知道这些信息，那么<u>根据经验，把分区的大小限制在25GB以内可以得到比较理想的效果</u>。

2. log.retention.ms

   **Kafka 通常根据时间来决定数据可以被保留多久。默认使用log.retention.ms参数来配置时间，默认值为168小时，也就是一周**。除此以外，还有其他两个参数log.retention.minutes和log.retention.ms。这3个参数的作用是一样的，都是决定消息多久以后会被删除，不过还是推荐使用log.retention.ms。<u>如果指定了不止一个参数， Kafka会优先使用具有最小值的那个参数。</u>

   > 根据时间保留数据和最后修改时间
   >
   > **根据时间保留数据是通过检查磁盘上日志片段文件的最后修改时间来实现的**。<u>一般来说，最后修改时间指的就是日志片段的关闭时间，也就是文件里最后一个消息的时间戳。不过，如果使用管理工具在服务器间移动分区，最后修改时间就不准确了</u>。时间误差可能导致这些分区过多地保留数据。在第9章讨论分区移动时会提到更多这方面的内容。

3. log.retention.bytes

   另一种方式是通过保留的消息字节数来判断消息是否过期。它的值通过参数log.retention.bytes来指定，**作用在每一个分区上**。也就是说，如果有一个包含8个分区的主题，井且log.retention.bytes被设为1GB ，那么这个主题最多可以保留8GB 的数据。所以，当主题的分区个数增加时，整个主题可以保留的数据也随之增加。

   > 根据字节大小和时间保留数据
   >
   > **如果同时指定了log.retention.bytes和log.retention.ms（或者另一个时间参数），只要任意一个条件得到满足，消息就会被删除**。例如，假设log.retention.ms设置为86 400 000 （也就是1 天），log.retention.bytes设置为1 000 000 000 （也就是1GB ），如果消息字节总数在不到一天的时间就超过了1GB ，那么<u>多出来的部分就会被删除</u>。相反，如果消息字节总数小于1GB ，那么一天之后这些消息也会被删除，尽管分区的数据总量小于1GB 。

4. log.segment.bytes

   **以上的设置都作用在日志片段上，而不是作用在单个消息上**。当消息到达broker 时，它们被迫加到分区的当前日志片段上。当日志片段大小达到log.segment.bytes指定的上限（默认是1GB）时，当前日志片段就会被关闭，一个新的日志片段被打开。<u>如果一个日志片段被关闭，就开始等待过期。这个参数的值越小，就会越频繁地关闭和分配新文件，从而降低磁盘写入的整体效率</u>。

   如果主题的消息量不大，那么如何调整这个参数的大小就变得尤为重要。例如，如果一个主题每天只接收100MB 的消息，而log.retention.ms使用默认设置，那么需要10天时间才能填满一个日志片段。因为在日志片段被关闭之前消息是不会过期的，所以如果log.retention.ms被设为604 800 000 （ 也就是1 周），那么日志片段最多需要17 天才会过期。<u>这是因为关闭日志片段需要10 天的时间，而根据配置的过期时间，还需要再保留7 天时间（要等到日志片段里的最后一个消息过期才能被删除）</u> 。

   > 使用时间戳获取偏移量
   >
   > 日志片段的大小会影响使用时间戳获取偏移量。在使用时间戳获取日志偏移量时， Kafka 会检查分区里最后修改时间大于指定时间戳的日志片段（已经被关闭的），该日志片段的前一个文件的最后修改时间小子指定时向戳。然后， Kafka 返回该日志片段（也就是文件名）开头的偏移量。**对于使用时间戳获取偏移量的操作来说，日志片段越小，结果越准确**。

5. log.segment.ms

   **另一个可以控制日志片段关闭时间的参数是log.segment.ms时，它指定了多长时间之后日志片段会被关闭**。就像log.retention.bytes和log.retention.ms这两个参数一样，log.segment.bytes和log.segment.ms这两个参数之间也不存在互斥问题。日志片段会在大小或时间达到上限时被关闭，就看哪个条件先得到满足。<u>默认情况下，log.segment.ms没有设定值，所以只根据大小来关闭日志片段</u>。

   > 基于时间的日志片段对磁盘性能的影响
   >
   > 在使用基于时间的日志片段时，要着重考虑并行关闭多个日志片段对磁盘性能的影响。如果多个分区的日志片段永远不能达到大小的上限，就会发生这种情况，因为broker 在启动之后就开始计算日志片段的过期时间，对于那些数据量小的分区来说，日志片段的关闭操作总是同时发生。

6. message.max.bytes

   **broker 通过设置message.max.bytes参数来限制单个消息的大小，默认值是1 000 000 ，也就是1MB** 。如果生产者尝试发送的消息超过这个大小，不仅消息不会被接收，还会收到broker 返回的错误信息。<u>跟其他与字节相关的配置参数一样，该参数指的是压缩后的消息大小，也就是说，只要压缩后的消息小于message.max.bytes指定的值，消息的实际大小可以远大于这个值</u>。

   这个值对性能有显著的影响。值越大，那么负责处理网络连接和请求的线程就需要花越多的时间来处理这些请求。它还会增加磁盘写入块的大小，从而影响IO吞吐量。

   > 在服务端和客户端之间协调消息大小的配置
   >
   > **消费者客户端设置的fetch.message.max.bytes必须与服务器端设置的消息大小进行协调。<u>如果这个值比message.max.bytes小，那么消费者就无法读取比较大的消息，导致出现消费者被阻塞的情况。在为集群里的broker 配置fetch.message.max.bytes参数时， 也遵循同样的原则</u>。**

## 2.4 硬件的选择

P42

