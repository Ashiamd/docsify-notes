# Kafka权威指南-学习笔记01

# 1. 初识Kafka

## 1. 1 发布与订阅消息系统

### 1 .1 .1 如何开始

### 1.1.2 独立的队列系统

## 1.2 Kafka 登场

### 1.2.1 消息和批次

+ Kafka 的数据单元被称为**消息**
+ 为了提高效率，消息被分批次写入Kafka 。**批次**就是一组消息，这些消息属于同一个主题和分区

### 1.2.2 模式

​	对于Kafka 来说，消息不过是晦涩难懂的字节数组，所以有人建议用一些额外的结构来定义消息内容，让它们更易于理解。根据应用程序的需求，消息**模式**（ schema ）有许多可用的选项（JSON、XML、proto、Avro等）。

### * 1.2.3 主题和分区

​	Kafka 的消息通过**主题**进行分类。主题就好比数据库的表，或者文件系统里的文件夹。主题可以被分为若干个**分区**， 一个分区就是一个提交日志。消息以追加的方式写入分区，然后以先入先出的顺序读取。<u>要注意，由于一个主题一般包含几个分区，因此**无法在整个主题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序**</u>。

​	图1-5 所示的主题有4个分区，消息被迫加写入<u>每个分区</u>的尾部。Kafka 通过分区来实现数据冗余和伸缩性。分区可以分布在不同的服务器上，也就是说， 一个主题可以横跨多个服务器，以此来提供比单个服务器更强大的性能。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16add12a4299ce6a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

​	图1- 5：包含多个分区的主题表示

### * 1.2.4 生产者和消费者

​	<u>Kafka 的客户端</u>就是Kafka系统的用户，它们被分为两种基本类型：**生产者**和**消费者**。除此之外，还有其他高级客户端API —— 用于数据集成的Kafka Connect API 和用于流式处理的Kafka Streams 。这些高级客户端API使用生产者和消费者作为内部组件，提供了高级的功能。

+ **生产者**创建消息。在其他发布与订阅系统中，生产者可能被称为<u>发布者</u>或<u>写入者</u>。一般情况下，一个消息会被发布到一个特定的主题上。生产者在默认情况下把消息均衡地分布到主题的所有分区上，而并不关心特定消息会被写到哪个分区。不过，在某些情况下，生产者会把消息直接写到指定的分区。这通常是通过消息键和分区器来实现的，分区器为键生成一个散列值，并将其映射到指定的分区上。这样可以保证包含同一个键的消息会被写到同一个分区上。生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到分区。第3章将详细介绍生产者。

+ **消费者**读取消息。在其他发布与订阅系统中，消费者可能被称为<u>订阅者</u>或<u>读者</u>。消费者订阅一个或多个主题，并按照消息生成的顺序读取它们。<u>消费者通过检查消息的偏移盘来区分已经读取过的消息</u>。偏移量是另一种元数据，它是一个不断递增的整数值，在创建消息时， Kafka 会把它添加到消息里。在给定的分区里，每个消息的偏移量都是唯一的。<u>消费者把每个分区最后读取的消息偏移量保存在Zookeeper 或Kafka 上，如果消费者关闭或重启，它的读取状态不会丢失</u>。

​	消费者是**消费者群组**的一部分，也就是说，会有一个或多个消费者共同读取一个主题。<u>**群组保证每个分区只能被一个消费者使用**</u>。图1-6 所示的群组中，有3 个消费者同时读取一个主题。其中的两个消费者各自读取一个分区，另外一个消费者读取其他两个分区。<u>消费者与分区之间的映射通常被称为消费者对分区的所有权关系</u>。

​	**通过这种方式，消费者可以消费包含大量消息的主题。而且，如果一个消费者失效，群组里的其他消费者可以接管失效消费者的工作**。第4章将详细介绍消费者和悄费者群组。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16add12a4233c775~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

​	图1-6 ：消费者群组从主题读取消息

### * 1.2.5 broker和集群

​	**一个独立的<u>Kafka 服务器</u>被称为broker**。

+ broker接收来自生产者的消息，**为消息设置偏移量**，并提交消息到磁盘保存。
+ broker为消费者提供服务，对读取<u>分区</u>的请求作出响应，返回已经提交到磁盘上的消息。

​	<u>根据特定的硬件及其性能特征，单个broker可以轻松处理数千个分区以及每秒百万级的消息量</u>。

​	broker 是**集群**的组成部分。<u>每个集群都有一个broker 同时充当了**集群控制器**的角色（自动从集群的活跃成员中选举出来）。**控制器负责管理工作，包括将分区分配给broker 和监控broker**</u>。

​	<u>在集群中， 一个分区从属于一个broker，该broker 被称为分区的**首领**</u>。

​	**一个分区可以分配给多个broker**，这个时候会发生**分区复制**（见图1-7）。**这种复制机制为分区提供了消息冗余，如果有一个broker 失效，其他broker 可以接管领导权。不过，<u>相关的消费者和生产者都要重新连接到新的首领</u>**。第6章将详细介绍集群的操作，包括分区复制。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/22/16add12a43368941~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

​	图1-7 ：集群里的分区复制

​	**保留消息**（在一定期限内）是Kafka 的一个重要特性。

​	Kafka broker 默认的消息保留策略是这样的：

+ 要么保留一段时间（比如7 天）
+ 要么保留到消息达到一定大小的字节数（比如1GB ）。当消息数量达到这些上限时，旧消息就会过期井被删除。

​	所以在任何时刻， 可用消息的总量都不会超过配置参数所指定的大小。<u>主题可以配置自己的保留策略，可以将消息保留到不再使用它们为止</u>。

​	例如，用于跟踪用户活动的数据可能需要保留几天，而应用程序的度量指标可能只需要保留几个小时。可以通过配置把主题当作**紧凑型日志**， 只有最后一个带有特定键的消息会被保留下来。这种情况对于变更日志类型的数据来说比较适用，因为人们只关心最后时刻发生的那个变更。

### * 1.2.6 多集群

​	随着Kafka 部署数量的增加，基于以下几点原因，最好使用多个集群。

+ 数据类型分离

+ 安全需求隔离

+ 多数据中心（灾难恢复）

​	**如果使用多个数据中心，就需要在它们之间复制消息**。这样，在线应用程序才可以访问到多个站点的用户活动信息。*例如，如果一个用户修改了他们的资料信息，不管从哪个数据中心都应该能看到这些改动。或者多个站点的监控数据可以被聚集到一个部署了分析程序和告警系统的中心位置*。不过， **<u>Kafka的消息复制机制只能在单个集群里进行，不能在多个集群之间进行</u>**。

​	Kafka 提供了一个叫作MirrorMaker 的工具，可以用它来实现集群间的消息复制。<u>MirrorMaker的核心组件包含了一个生产者和一个消费者，两者之间通过一个队列相连</u>。**消费者从一个集群读取消息，生产者把消息发送到另一个集群上**。

​	![v2-8869847fc733df34a94a54d4d9076ee5_b.jpg](https://img-blog.csdnimg.cn/img_convert/e1e93adef38fa5a0084cb6e0b34d21e7.png)

​	图1-8 ： 多数据中的架构

​	图1-8 展示了一个使用MirrorMaker 的例子，两个“本地”集群的消息被聚集到一个“聚合”集群上，然后将该集群复制到其他数据中心。不过，这种方式在创建复杂的数据管道方面显得有点力不从心。第7章将详细讨论这些案例。

## 1.3 为什么选择Kafka

### 1.3.1 多个生产者

​	<u>Kafka可以无缝地支持多个生产者，不管客户端在使用单个主题还是多个主题</u>。所以它很适合用来从多个前端系统收集数据，并以统一的格式对外提供数据。例如， 一个包含了多个微服务的网站，可以为页面视图创建一个单独的主题，所有服务都以相同的消息格式向该主题写入数据。消费者应用程序会获得统一的页面视图，而无需协调来自不同生产者的数据流。

### * 1.3.2 多个消费者

​	<u>除了支持多个生产者外， Kafka 也支持多个消费者从一个单独的消息流上读取数据，而且**消费者之间互不影响**</u>。这与其他队列系统不同，其他队列系统的消息一旦被一个客户端读取，其他客户端就无法再读取它。**另外，多个消费者可以组成一个群组，它们共享一个消息流，并<u>保证整个群组对每个给定的消息只处理一次</u>**。

### 1.3. 3 基于磁盘的数据存储

​	Kafka 不仅支持多个消费者，还允许消费者非实时地读取消息，这要归功于Kafka 的数据保留特性。消息被提交到磁盘，根据设置的保留规则进行保存。**每个主题可以设置单独的保留规则**，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。消费者可能会因为处理速度慢或突发的流量高峰导致无法及时读取消息，而持久化数据可以保证数据不会丢失。消费者可以在进行应用程序维护时离线一小段时间，而无需担心消息丢失或堵塞在生产者端。<u>消费者可以被关闭，但消息会继续保留在Kafka 里。消费者可以从上次中断的地方继续处理消息</u>。

### 1.3.4 伸缩性

​	为了能够轻松处理大量数据， Kafka 从一开始就被设计成一个具有灵活伸缩性的系统。用户在开发阶段可以先使用单个broker ，再扩展到包含3个broker 的小型开发集群，然后随着数据量不断增长，部署到生产环境的集群可能包含上百个broker 。<u>对在线集群进行扩展丝毫不影响整体系统的可用性。也就是说， 一个包含多个broker 的集群，即使个别broker失效，仍然可以持续地为客户提供服务</u>。<u>要提高集群的容错能力，需要配置较高的复制系数</u>。第6章将讨论关于复制的更多细节。

### 1.3.5 高性能

​	上面提到的所有特性，让Kafka 成为了一个高性能的**发布与订阅消息**系统。通过横向扩展生产者、消费者和broker，Kafka可以轻松处理巨大的消息流。在处理大量数据的同时，它还能保证**亚秒级**的消息延迟。

## 1.4 数据生态系统

​	Kafka 为数据生态系统带来了循环系统，如图1-9 所示。它在基础设施的各个组件之间传递消息，为所有客户端提供一致的接口。<u>当与提供消息模式的系统集成时，生产者和消费者之间不再有紧密的祸合，也**不需要在它们之间建立任何类型的直连**</u>。我们可以根据业务需要添加或移除组件．因为生产者不再关心谁在使用数据，也不关心有多少个消费者。

![v2-90d0e87bef7b3732cfd70a8c78710e95_b.jpg](https://img-blog.csdnimg.cn/img_convert/14b915f52caadd0f56ff37357dbce671.png)

​	圄1-9 ：大数据生态系统

​	使用场景：

1. 活动跟踪

2. 传递消息
3. 度量指标和日志记录
4. 提交日志
5. 流处理

## 1.5 起源故事

​	Kafka 是为了解决Linkedln数据管道问题应运而生的。<u>它的设计目的是提供一个高性能的消息系统，可以处理多种数据类型，并能够实时提供纯净且结构化的用户活动数据和系统度量指标</u>。

### 1.5.1 Linkedln的问题

​	最开始，我们调研了一些现成的开源解决方案，希望能够找到一个系统，可以实时访问数据，并通过横向扩展来处理大量的悄息。我们使用ActiveMQ 创建了一个原型系统，但它当时还无能满足横向扩展的需求。Linkedln 不得不使用这种脆弱的解决方案， 虽然ActiveMQ 有很多触陷会导致broker 暂停服务。客户端的连接因此被阻塞，处理用户请求的能力也受到影响。于是我们最后决定构建自己的基础设施。

### 1.5.2 Kafka 的诞生

​	Linkedln 的开发团队由Jay Kreps 领导。Jay Kreps 是Linkedln 的首席工程师，之前负责分布式键值存储系统Voldemort的开发。初建团队成员还包括Neha Narkhede ，不久之后，Jun Rao 也加入了进来。他们一起着手创建一个消息系统，可以同时满足上述的两种需求，并且可以在未来进行横向扩展。他们的主要目标如下：

+ 使用推送和拉取模型解耦生产者和消费者

+ 为消息传递系统中的消息提供数据持久化，以便支持多个消费者
+ 通过系统优化实现高吞吐量
+ 系统可以随着数据流的增长进行横向扩展

​	最后我们看到的这个发布与订阅消息系统具有典型的消息系统接口，但从存储层来看，它更像是一个日志聚合系统。Kafka 使用Avro作为消息序列化框架，每天高效地处理数十亿级别的度量指标和用户活动跟踪信息。Linkedln已经拥有超过万亿级别的消息使用量（截止到2015 年8 月），而且每天仍然需要处理超过千万亿字节的数据。

### 1.5.3 走向开源

​	2010 年底， Kafka 作为开源项目在GitHub 上发布。2011年7月，因为倍受开源社区的关注，它成为Apache软件基金会的孵化器项目。2012年10 月， Kafka 从孵化器项目毕业。	

### 1.5.4 命名

## 1.6 开始Kafka之旅

## 2. 安装Kafka

## 2.1 要事先行

### 2.1.1 选择操作系统

### 2.1.2 安装Java

​	在安装Zookeeper和Kafka之前，需要先安装Java环境。

### 2.1.3 安装Zookeeper

​	**Kafka 使用Zookeeper 保存集群的元数据信息和消费者信息**。Kafka 发行版自带了Zookeeper ，可以直接从脚本启动，不过安装一个完整版的Zookeeper 也并不费劲。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112413373216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94aWFvY2hlbmd4aW55aXpoYW4uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70)

图2-1 : Kafka 和Zookeeper

## 2.2 安装Kafka Broker

## 2.3 broker配置

### 2.3.1 常规配置

​	有一些配置选项，在单机安装时可以直接使用默认值，但在部署到其他环境时要格外小心。这些参数是单个服务器最基本的配置，它们中的大部分需要经过修改后才能用在集群里。

1. broker.id

   每个broker 都需要有一个标识符，使用broker.id 来表示。它的默认值是0 ，也可以被设置成其他任意整数。**这个值在整个Kafka 集群里必须是唯一的**。这个值可以任意选定，如果出于维护的需要，可以在服务器节点间交换使用这些ID 。建议把它们设置成与机器名具有相关性的整数，这样在进行维护时，将ID 号映射到机器名就没那么麻烦了。例如，如果机器名包含唯一性的数字（比如hostl . example.com 、host2.example.com），那么用这些数字来设置broker.id 就再好不过了。

2. port

   如果使用配置样本来启动Kafka ，它会监听9092 端口。修改port配置参数可以把它设置成其他任意可用的端口。要注意，如果使用1024以下的端口，需要使用root权限启动Kafka ，不过不建议这么做。

3. Zookeeper.connect

   **用于保存broker元数据的Zookeeper 地址是通过zookeeper.connect 来指定的**。`localhost:2181`表示这个Zookeeper 是运行在本地的2181端口上。该配置参数是用冒号分隔的一组`hostname:port/path`列表，每一部分的含义如下：

   + hostname 是Zookeeper 服务器的机器名或IP 地址

   + port 是Zookeeper 的客户端连接端口

   + /path 是可选的Zookeeper 路径，作为Kafka集群的chroot 环境。如果不指定，默认使用根路径。

   如果指定的chroot路径不存在， broker 会在启动的时候创建它。

   > 为什么使用chroot路径
   >
   > 在Kafka 集群里使用chroot 路径是一种最佳实践。Zookeeper 群组可以共享给其他应用程序，即使还有其他Kafka集群存在， 也不会产生冲突。最好是在配置文件里指定一组Zookeeper服务器，用分号把它们隔开。一旦有一个Zookeeper 服务器岩机， broker可以连接到Zookeeper群组的另一个节点上。

4. log.dirs

   **Kafka把所有消息都保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的**。它是一组用逗号分隔的本地文件系统路径。<u>如果指定了多个路径，那么broker 会根据“最少使用”原则，把同一个分区的日志片段保存到同一个路径下</u>。要注意， broker 会往拥有最少数目分区的路径新增分区，而不是往拥有最小磁盘空间的路径新增分区。

5. num.recovery.threads.per.data.dir

   对于如下3种情况， Kafka 会使用可配置的线程池来处理日志片段：

   + 服务器正常启动，用于打开每个分区的日志片段

   + 服务器崩愤后重启，用于检查和截短每个分区的日志片段
   + 服务器正常关闭，用于关闭日志片段

   <u>默认情况下，每个日志目录只使用一个线程</u>。因为这些线程只是在服务器启动和关闭时会用到，所以完全可以设置大量的线程来达到井行操作的目的。特别是对于包含大量分区的服务器来说， 一旦发生崩愤，在进行恢复时使用井行操作可能会省下数小时的时间。设此参数时需要注意，所配置的数字对应的是log.dirs指定的单个日志目录。也就是说，如果num.recovery.threads.per.data.dir被设为8 ， 井且log.dir指定了3 个路径，那么总共需要24 个线程。

6. auto.create.topics.enable

   默认情况下， Kafka 会在如下几种情形下<u>自动创建主题</u>：

   + 当一个生产者开始往主题写入消息时

   + 当一个消费者开始从主题读取消息时

   + 当任意一个客户端向主题发送元数据请求时。

   很多时候，这些行为都是非预期的。而且，根据Kafka协议，如果一个主题不先被创建，根本无法知道它是否已经存在。如果显式地创建主题， 不管是手动创建还是通过其他配置系统来创建，都可以把auto.create.topics.enable设为false 。

### * 2.3.2 主题的默认配置

​	Kafka 为新创建的主题提供了很多默认配置参数。可以通过管理工具（将在第9 章介绍）为每个主题单独配置一部分参数，比如分区个数和数据保留策略。服务器提供的默认配置可以作为基准，它们适用于大部分主题。

> 使用主题配置覆盖（override)
>
> 之前的Kafka 版本允许主题覆盖服务器的默认配置，包括log.retention.hours.per.topic 、log.retention.bytes.per.topic和log.segment.bytes.per.topic 这几个参数。新版本不再支持这些参数，而且如果要对参数进行覆盖，需要使用管理工具。

1. num.paritions

   num.paritions参数指定了新创建的主题将包含多少个分区。如果启用了主题自动创建功能（该功能默认是启用的），主题分区的个数就是该参数指定的值。该参数的默认值是1。**要注意，我们可以增加主题分区的个数，但不能减少分区的个数**。所以，如果要让一个主题的分区个数少于num.partitions指定的值，需要手动创建该主题（将在第9章讨论）。

   第1章里已经提到， Kafka集群通过分区对主题进行横向扩展，所以当有新的broker 加入集群时，可以通过分区个数来实现集群的负载均衡。当然，这并不是说，在存在多个主题的情况下（它们分布在多个broker上），为了能让分区分布到所有broker上， 主题分区的个数必须要大于broker的个数。不过，<u>拥有大量消息的主题如果要进行负载分散，就需要大量的分区</u>。

   > 如何选定分区数量
   >
   > 为主题选定分区数量并不是一件可有可无的事情，在进行数量选择时，需要考虑如下几个因素。
   >
   > + 主题需要达到多大的吞吐量？例如，是希望每秒钟写入100KB 还是1GB?
   >
   > + 从单个分区读取数据的最大吞吐量是多少？每个分区一般都会有一个消费者，如果你知道消费者将数据写入数据库的速度不会超过每秒50MB ，那么你也该知道，从一个分区读取数据的吞吐量不需要超过每秒50MB 。
   >
   > + 可以通过类似的方法估算生产者向单个分区写入数据的吞吐量，不过生产者的速度一般比消费者快得多，所以最好为生产者多估算一些吞吐量。
   >
   > + 每个broker 包含的分区个数、可用的磁盘空间和网络带宽。
   >
   > + <u>如果消息是按照不同的键来写入分区的，那么为已有的主题新增分区就会很困难</u>。
   >
   > + **单个broker 对分区个数是有限制的，因为分区越多，占用的内存越多，完成首领选举需要的时间也越长**。

   很显然，综合考虑以上几个因素，你需要很多分区，但不能太多。**如果你估算出主题的吞吐量和消费者吞吐量，可以用主题吞吐量除以消费者吞吐量算出分区的个数**。也就是说，如果每秒钟要从主题上写入和读取1GB 的数据，并且每个消费者每秒钟可以处理50MB的数据，那么至少需要20个分区。这样就可以让20 个消费者同时读取这些分区，从而达到每秒钟1GB 的吞吐量。

   如果不知道这些信息，那么<u>根据经验，把分区的大小限制在25GB以内可以得到比较理想的效果</u>。

2. log.retention.ms

   **Kafka 通常根据时间来决定数据可以被保留多久。默认使用log.retention.ms参数来配置时间，默认值为168小时，也就是一周**。除此以外，还有其他两个参数log.retention.minutes和log.retention.ms。这3个参数的作用是一样的，都是决定消息多久以后会被删除，不过还是推荐使用log.retention.ms。<u>如果指定了不止一个参数， Kafka会优先使用具有最小值的那个参数。</u>

   > 根据时间保留数据和最后修改时间
   >
   > **根据时间保留数据是通过检查磁盘上日志片段文件的最后修改时间来实现的**。<u>一般来说，最后修改时间指的就是日志片段的关闭时间，也就是文件里最后一个消息的时间戳。不过，如果使用管理工具在服务器间移动分区，最后修改时间就不准确了</u>。时间误差可能导致这些分区过多地保留数据。在第9章讨论分区移动时会提到更多这方面的内容。

3. log.retention.bytes

   另一种方式是通过保留的消息字节数来判断消息是否过期。它的值通过参数log.retention.bytes来指定，**作用在每一个分区上**。也就是说，如果有一个包含8个分区的主题，井且log.retention.bytes被设为1GB ，那么这个主题最多可以保留8GB 的数据。所以，当主题的分区个数增加时，整个主题可以保留的数据也随之增加。

   > 根据字节大小和时间保留数据
   >
   > **如果同时指定了log.retention.bytes和log.retention.ms（或者另一个时间参数），只要任意一个条件得到满足，消息就会被删除**。例如，假设log.retention.ms设置为86 400 000 （也就是1 天），log.retention.bytes设置为1 000 000 000 （也就是1GB ），如果消息字节总数在不到一天的时间就超过了1GB ，那么<u>多出来的部分就会被删除</u>。相反，如果消息字节总数小于1GB ，那么一天之后这些消息也会被删除，尽管分区的数据总量小于1GB 。

4. log.segment.bytes

   **以上的设置都作用在日志片段上，而不是作用在单个消息上**。当消息到达broker 时，它们被迫加到分区的当前日志片段上。当日志片段大小达到log.segment.bytes指定的上限（默认是1GB）时，当前日志片段就会被关闭，一个新的日志片段被打开。<u>如果一个日志片段被关闭，就开始等待过期。这个参数的值越小，就会越频繁地关闭和分配新文件，从而降低磁盘写入的整体效率</u>。

   如果主题的消息量不大，那么如何调整这个参数的大小就变得尤为重要。例如，如果一个主题每天只接收100MB 的消息，而log.retention.ms使用默认设置，那么需要10天时间才能填满一个日志片段。因为在日志片段被关闭之前消息是不会过期的，所以如果log.retention.ms被设为604 800 000 （ 也就是1 周），那么日志片段最多需要17 天才会过期。<u>这是因为关闭日志片段需要10 天的时间，而根据配置的过期时间，还需要再保留7 天时间（要等到日志片段里的最后一个消息过期才能被删除）</u> 。

   > 使用时间戳获取偏移量
   >
   > 日志片段的大小会影响使用时间戳获取偏移量。在使用时间戳获取日志偏移量时， Kafka 会检查分区里最后修改时间大于指定时间戳的日志片段（已经被关闭的），该日志片段的前一个文件的最后修改时间小子指定时向戳。然后， Kafka 返回该日志片段（也就是文件名）开头的偏移量。**对于使用时间戳获取偏移量的操作来说，日志片段越小，结果越准确**。

5. log.segment.ms

   **另一个可以控制日志片段关闭时间的参数是log.segment.ms时，它指定了多长时间之后日志片段会被关闭**。就像log.retention.bytes和log.retention.ms这两个参数一样，log.segment.bytes和log.segment.ms这两个参数之间也不存在互斥问题。日志片段会在大小或时间达到上限时被关闭，就看哪个条件先得到满足。<u>默认情况下，log.segment.ms没有设定值，所以只根据大小来关闭日志片段</u>。

   > 基于时间的日志片段对磁盘性能的影响
   >
   > 在使用基于时间的日志片段时，要着重考虑并行关闭多个日志片段对磁盘性能的影响。如果多个分区的日志片段永远不能达到大小的上限，就会发生这种情况，因为broker 在启动之后就开始计算日志片段的过期时间，对于那些数据量小的分区来说，日志片段的关闭操作总是同时发生。

6. message.max.bytes

   **broker 通过设置message.max.bytes参数来限制单个消息的大小，默认值是1 000 000 ，也就是1MB** 。如果生产者尝试发送的消息超过这个大小，不仅消息不会被接收，还会收到broker 返回的错误信息。<u>跟其他与字节相关的配置参数一样，该参数指的是压缩后的消息大小，也就是说，只要压缩后的消息小于message.max.bytes指定的值，消息的实际大小可以远大于这个值</u>。

   这个值对性能有显著的影响。值越大，那么负责处理网络连接和请求的线程就需要花越多的时间来处理这些请求。它还会增加磁盘写入块的大小，从而影响IO吞吐量。

   > 在服务端和客户端之间协调消息大小的配置
   >
   > **消费者客户端设置的fetch.message.max.bytes必须与服务器端设置的消息大小进行协调。<u>如果这个值比message.max.bytes小，那么消费者就无法读取比较大的消息，导致出现消费者被阻塞的情况。在为集群里的broker 配置fetch.message.max.bytes参数时， 也遵循同样的原则</u>。**

## 2.4 硬件的选择

​	如果比较关注性能，那么就需要考虑几个会影响整体性能的因素：磁盘吞吐量和容量、内存、网络和CPU。

### * 2.4.1 磁盘吞吐量

​	**生产者客户端的性能直接受到服务器端磁盘吞吐量的影响**。<u>生产者生成的消息必须被提交到服务器保存，大多数客户端在发送消息之后会一直等待，直到至少有一个服务器确认悄息已经成功提交为止</u>。也就是说，**磁盘写入速度越快，生成消息的延迟就越低**。

> 在考虑硬盘类型对磁盘吞吐量的影响时，是选择传统的机械硬盘（HDD）还是固态硬盘(SSD），我们可以很容易地作出决定。固态硬盘的查找和访问速度都很快，提供了最好的性能。机械硬盘更便宜， 单块硬盘容量也更大。在同一个服务器上使用多个机械硬盘，可以设置多个数据目录，或者把它们设置成磁盘阵列，这样可以提升机械硬盘的性能。其他方面的因素，比如磁盘特定的技术（串行连接存储技术或SATA ），或者磁盘控制器的质量， 都会影响吞吐量。	

### 2.4.2 磁盘容量

​	磁盘容量是另一个值得讨论的话题。需要多大的磁盘容量取决于需要保留的消息数量。如果服务器每天会收到1TB 消息，并且保留7天，那么就需要7TB 的存储空间，而且还要为其他文件提供至少10%的额外空间。除此之外，还需要提供缓冲区，用于应付消息流量的增长和波动。

​	在决定扩展Kafka集群规模时，存储容量是一个需要考虑的因素。**通过让主题拥有多个分区， 集群的总流量可以被均衡到整个集群，而且如果单个broker无法支撑全部容量，可以让其他broker提供可用的容量**。<u>存储容量的选择同时受到集群复制策略的影响</u>（将在第6章讨论更多的细节） 。

### * 2.4.3 内存

​	除了磁盘性能外，服务器端可用的内存容量是影响客户端性能的主要因素。**磁盘性能影响生产者，而内存影响消费者**。<u>消费者一般从分区尾部读取消息，如果有生产者存在，就紧跟在生产者后面。在这种情况下，消费者读取的消息会直接存放在系统的页面缓存里，这比从磁盘上重新读取要快得多</u>。

​	<u>运行Kafka 的JVM 不需要太大的内存，剩余的系统内存可以用作页面缓存，或者用来缓存正在使用中的日志片段</u>。这也就是为什么不建议把Kafka 同其他重要的应用程序部署在一起的原因，它们需要共享页面缓存，最终会降低Kafka 消费者的性能。

 ### * 2.4.4 网络

​	**网络吞吐量决定了Kafka 能够处理的最大数据流量**。它和磁盘存储是制约Kafka扩展规模的主要因素。Kafka支持多个消费者，造成流入和流出的网络流量不平衡，从而让情况变得更加复杂。对于给定的主题， 一个生产者可能每秒钟写入1MB 数据，但可能同时有多个消费者瓜分网络流量。其他的操作，如集群复制（在第6章介绍）和镜像（在第8章介绍）也会占用网络流量。<u>如果网络接口出现饱和，那么集群的复制出现延时就在所难免，从而让集群不堪一击</u>。

### 2.4.5 CPU

​	与磁盘和内存相比， **Kafka 对计算处理能力的要求相对较低**，不过它在一定程度上还是会影响整体的性能。<u>**客户端为了优化网络和磁盘空间，会对消息进行压缩。服务器需要对消息进行批量解压，设置偏移量，然后重新进行批量压缩，再保存到磁盘上**。这就是Kafka 对计算处理能力有所要求的地方</u>。不过不管怎样，这都不应该成为选择硬件的主要考虑因素。

## 2.5 云端的Kafka

## 2.6 Kafka集群

​	单个Kafka 服务器足以满足本地开发或POC 要求，不过集群也有它的强大之处。**使用集群最大的好处是可以跨服务器进行负载均衡，再则就是可以<u>使用复制功能来避免因单点故障造成的数据丢失</u>**。在维护Kafka 或底层系统时，使用集群可以确保为客户端提供高可用性。本节只是介绍如何配置Kafka 集群，第6章将介绍更多关于数据复制的内容。

![img](http://www.ituring.com.cn/figures/2017/Kafka/013.png)

### * 2.6.1 需要多少个broker

​	一个Kafka 集群需要多少个broker 取决于以下几个因素。首先，需要多少<u>磁盘空间</u>来保留数据，以及单个broker 有多少空间可用。如果整个集群需要保留10TB 的数据， 每个broker 可以存储2TB ，那么至少需要5个broker 。如果启用了数据复制，那么至少还需要一倍的空间，不过这要取决于配置的复制系数是多少（将在第6 章介绍）。也就是说，如果启用了数据复制，那么这个集群至少需要10 个broker 。

​	第二个要考虑的因素是集群处理请求的能力。这通常与<u>网络接口处理客户端流量的能力</u>有关，特别是当有多个消费者存在或者在数据保留期间流量发生波动（比如高峰时段的流量爆发）时。如果单个broker的网络接口在高峰时段可以达到80%的使用量，并且有两个消费者，那么消费者就无法保持峰值，除非有两个broker 。如果集群启用了复制功能，则要把这个额外的消费者考虑在内。<u>因磁盘吞吐量低和系统内存不足造成的性能问题，也可以通过扩展多个broker来解决</u>。

### 2.6.2 broker配置

​	要把一个broker 加入到集群里，只需要修改两个配置参数。

​	首先，所有broker 都必须配置相同的zookeeper.connect， 该参数指定了用于保存元数据的Zookeeper群组和路径。

​	其次，每个broker 都必须为broker.id参数设置唯一的值。<u>如果两个broker 使用相同的broker.id，那么第二个broker 就无法启动</u>。在运行集群时，还可以配置其他一些参数，特别是那些用于控制数据复制的参数，这些将在后续的章节介绍。

### 2.6.3 操作系统调优

​	大部分Linux发行版默认的内核调优参数配置已经能够满足大多数应用程序的运行需求，不过还是可以通过调整一些参数来进一步提升Kafka的性能。这些参数主要与虚拟内存、网络子系统和用来存储日志片段的磁盘挂载点有关。这些参数一般配置在`/etc/sysctl.conf`文件里，不过在对内核参数进行调整时，最好参考操作系统的文挡。

1. 虚拟内存

   一般来说， Linux 的虚拟内存会根据系统的工作负荷进行自动调整。我们可以对交换分区的处理方式和内存脏页进行调整，从而让Kafka 更好地处理工作负载。

   **对于大多数依赖吞吐量的应用程序来说，要尽量避免内存交换**。内存页和磁盘之间的交换对Kafka 各方面的性能都有重大影响。Kafka大量地使用系统页面缓存，如果虚拟内存被交换到磁盘，说明已经没有多余内存可以分配给页面缓存了。

   <u>一种避免内存交换的方告是不设置任何交换分区。内存交换不是必需的，不过它确实能够在系统发生灾难性错误时提供一些帮助</u>。进行内存交换可以防止操作系统由于内存不足而突然终止进程。基于上述原因，建议把vm.swappiness参数的值设置得小一点，比如1。该参数指明了虚拟机的子系统将如何使用交换分区，而不是只把内存页从页面缓存里移除。要优先考虑减小页面缓存，而不是进行内存交换。

   > 为什么不把vm.swappiness设为零
   >
   > 先前，人们建议尽量把vm.swappiness设为0 ，它意味着“除非发生内存溢出，否则不要进行内存交换”。直到Linux 内核3.5-rc1版本发布，这个值的意义才发生了变化。这个变化被移植到其他的发行版上，包括Red Hat 企业版内核2.6.32-303。在发生变化之后， 0 意味着“在任何情况下都不要发生交换”。所以现在建议把这个值设为1。

   脏页会被冲刷到磁盘上，调整内核对脏页的处理方式可以让我们从中获益。Kafka 依赖I/O性能为生产者提供快速的响应。这就是为什么日志片段一般要保存在快速磁盘上，不管是单个快速磁盘（如SSD）还是具有NVRAM 缓存的磁盘子系统（如RAID）。这样一来，在后台刷新进程将脏页写入磁盘之前，可以减少脏页的数量，这个可以通过将ratio设为小于10 的值来实现。该值指的是系统内存的百分比，大部分情况下设为5 就可以了。它不应该被设为0 ，因为那样会促使内核频繁地刷新页面，从而降低内核为底层设备的磁盘写入提供缓冲的能力。

   通过设置vm.dirty_ratio参数可以增加被内核进程刷新到磁盘之前的脏页数量，可以将它设为大于20 的值（这也是系统内存的百分比）。这个值可设置的范围很广， 60～80 是个比较合理的区间。不过调整这个参数会带来一些风险，包括未刷新磁盘操作的数量和同步刷新引起的长时间I/O等待。<u>如果该参数设置了较高的值，建议启用Kafka的复制功能，避免因系统崩溃造成数据丢失</u>。

   为了给这些参数设置合适的值，最好是在Kafka 集群运行期间检查脏页的数量，不管是在生存环境还是模拟环境。可以在`/proc/vmstat`文件里查看当前脏页数量。

   ```shell
   # cat /proc/vmstat | egrep "dirty|writeback"
   nr_dirty 3875
   nr_writeback 29
   nr_writeback_temp 0
   ```

2. 磁盘

   除了选择合适的磁盘硬件设备和使用RAID外，文件系统是影响性能的另一个重要因素。有很多种文件系统可供选择，不过对于本地文件系统来说，EXT4（第四代可扩展文件系统）和XFS 最为常见。近来，XFS成为很多Linux发行版默认的文件系统，因为它只需要做少量调优就可以承担大部分的工作负荷，比EXT4具有更好的表现。EXT4 也可以做得很好，但需要做更多的调优，存在较大的风险。其中就包括设置更长的提交间隔（默认是5 ），以便降低刷新的频率。<u>EXT4还引入了块分配延迟， 一旦系统崩愤，更容易造成数据丢失和文件系统毁坏。XFS也使用了分配延迟算撞，不过比EXT4的要安全些。XFS为Kafka 提供了更好的性能，除了由文件系统提供的自动调优之外，无需额外的调优。批量磁盘写入具有更高的效率，可以提升整体的I/O吞吐量</u>。

   不管使用哪一种文件系统来存储日志片段，最好要对挂载点的noatime参数进行合理的设置。**<u>文件元数据包含3 个时间戳： 创建时间（ctime）、最后修改时间（mtime）以及最后访问时间（atime）</u>**。**默认情况下，每次文件被读取后都会更新atime ，这会导致大量的磁盘写操作，而且atime属性的用处不大，除非某些应用程序想要知道某个文件在最近一次修改后有没有被访问过（这种情况可以使用realtime）**。<u>Kafka用不到该属性，所以完全可以把它禁用掉。为挂载点设置noatime参数可以防止更新atime ，但不会影响ctime和mtime</u>。

3. 网络

   默认情况下，系统内核没有针对快速的大流量网络传输进行优化， 所以对于应用程序来说，一般需要对Linux 系统的网络技进行调优，以实现对大流量的支持。实际上，调整Kafka 的网络配置与调整其他大部分Web服务器和网络应用程序的网络配置是一样的。首先<u>可以对分配给socket读写缓冲区的内存大小作出调整，这样可以显著提升网络的传输性能</u>。socket 读写缓冲区对应的参数分别是`net.core.wmem_default`和`net.core.rmem_default`，合理的值是131 072 （ 也就是128 KB ）。读写缓冲区最大值对应的参数分别是`net.core.wmem_max`和`net.core.rmem_max`，合理的值是2 097 152 （ 也就是2 MB ）。要注意，最大值井不意味着每个socket 一定要有这么大的缓冲空间，只是说在必要的情况下才会达到这个值。

   除了设置socket 外，还需要设置TCP socket 的读写缓冲区，它们的参数分别是`net.ipv4.tcp_wmem`和`net.ipv4 .tcp_rmem`。这些参数的值由3 个整数组成，它们使用空格分隔，分别表示最小值、默认值和最大值。最大值不能大于`net.core.wmem_max`和`net.core.rmem_max`指定的大小。例如，“4096 65536 204800。”表示最小值是4KB、默认值是64KB、最大值是2MB 。<u>根据Kafka 服务器接收流量的实际情况，可能需要设置更高的最大值，为网络连接提供更大的缓冲空间</u>。

   还有其他一些有用的网络参数。例如， 把`net.ipv4.tcp_window_scaling`设为1 ，启用TCP时间窗扩展，可以提升客户端传输数据的效率，传输的数据可以在服务器端进行缓冲。把`net.ipv4.tcp_max_syn_backlog`设为比默认值1024 更大的值，可以接受更多的井发连接。把`net.core.netdev_max_backlog`设为比默认值1000 更大的值，有助于应对网络流量的爆发，特别是在使用千兆网络的情况下，允许更多的数据包排队等待内核处理。

## 2.7 生产环境的注意事项

### 2.7.1 垃圾回收器选项

P47
