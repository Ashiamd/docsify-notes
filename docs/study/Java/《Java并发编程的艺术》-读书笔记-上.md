# 《Java并发编程的艺术》读书笔记-上

> 找到的[书本源码](http://ifeve.com/wp-content/uploads/2015/08/ArtConcurrentBook.zip)下载链接

# 第1章 并发编程的挑战

## 1.1 上下文切换

上下文切换即内核态进程之间的切换。

*（寄存器、缓存等需要保存切换前的进程状态）*

*（Linux严格意义上不区分进程和线程，一个内核态进程控制块PCB对应一个用户态轻量级进程LWP，LWP在绑定一个用户级线程。内核态进程控制块PCB、轻量级进程LWP由操作系统提供，而用户线程由用户空间的线程库实现，需要与LWP建立关系，在Linux中一个LWP只和一个线程建立管理，早期的Solaris系统则是一个LWP能与多个用户线程建立关系。）*

### 1.1.1 多线程一定快吗

不一定，上下文切换有开销。

*（且如果考虑需要同步的环境下，多线程有时候效率还远低于串行化执行。比如卡牌游戏一般单线程执行，完全没有必要多线程执行再强行增加同步数据的代码逻辑。）*

### 1.1.2 测试上下文切换次数和时长

+ Lmbench性能分析工具，可以测试上下文切换时长
+ vmstat可以测试上下文切换次数

### 1.1.3 如何减少上下文切换

+ 无锁并发编程
+ CAS算法
+ 使用最少线程
+ 使用协程

*（用户级线程，go语言有内置，java则需要使用第三方库Quasar。协程一般用于IO密集的场景，计算量大的场景还是使用线程合适。协程即用户态单线程内多个线程上下文来回切换，而非内核态之间的多线程上下文的切换。）*

1. 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
2. CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
3. 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
4. 协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

> [大家说一下 多线程 协程 在实际项目中的应用场景](https://www.v2ex.com/t/453925)
>
> [协程到底有没有并发执行？](https://www.zhihu.com/question/38393045)

### 1.1.4 减少上下文切换实战

1. 使用jstack命令dump线程信息，查看指定pid的进程内的线程工作信息
2. 使用grep、awk等shell指令统计文件中线程分别处于什么状态（及各自数量）
3. 打开dump文件查看某一状态的线程主要都在做什么工作（比如可能出现大量WAITING的线程=>线程池设定的线程上限数量过大or设置的闲置线程数过大）
4. 回到项目代码中，减少对应线程池设定的线程数量or其他操作。
5. 再次通过上述流程，查看线程信息。

## 1.2 死锁

### 死锁样例

​	通俗的说法，即进程/线程A占用资源A的情况下申请需要资源B，而进程/线程B占用资源B的情况下申请需要资源A，陷入死循环。（本质即占用共享资源的情况下申请其他共享资源，有可能导致死锁）

​	一般写代码不会直接出现死锁逻辑，但是代码执行时抛出异常等意外情况，可能导致占用的锁没被释放，进而导致死锁产生。

​	通过dump线程信息，可以查找出死锁产生的java代码位置。

```java
// 书上的死锁样例代码
public class DeadLockDemo {
  private static String A = "A";
  private static String B = "B";
  public static void main(String[] args) {
    new DeadLockDemo().deadLock();
  }
  private void deadLock() {
    Thread t1 = new Thread(new Runnable() {
      @Override
      public void run() {
        synchronized (A) {
          try { Thread.currentThread().sleep(2000);
              } catch (InterruptedException e) {
            e.printStackTrace();
          }
          synchronized (B) {
            System.out.println("1");
          }
        }
      }
    });
    Thread t2 = new Thread(new Runnable() {
      @Override
      public void run() {
        synchronized (B) {
          synchronized (A) {
            System.out.println("2");
          }
        }
      }
    });
    t1.start();
    t2.start();
  }
}
```

运行jvm后，通过shell指令dump线程信息并查看。

```shell
ps aux # 先找到对应进程的pid（我想找的是JVM进程）
jstack {JVM进程PID} > ~/dump_file # dump线程信息
cat ~/dump_file # 查看dump文件

... # 省略文件上面其他内容
Java stack information for the threads listed above:
===================================================
"Thread-1":
	at concurrency.DeadLockDemo$2.run(DeadLockDemo.java:33)
	- waiting to lock <0x000000071576e550> (a java.lang.String)
	- locked <0x000000071576e580> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)
"Thread-0":
	at concurrency.DeadLockDemo$1.run(DeadLockDemo.java:23)
	- waiting to lock <0x000000071576e580> (a java.lang.String)
	- locked <0x000000071576e550> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```

### 常见避免死锁的方法

+ 避免一个线程同时获取多个锁。

+ 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。

+ 尝试使用定时锁，使用`lock.tryLock（timeout）`来替代使用内部锁机制。

+ 对于数据库锁，**加锁和解锁必须在一个数据库连接**里，否则会出现解锁失败的情况

## 1.3 资源限制的挑战

### 什么是资源限制

​	资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。

​	例如，服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10Mb/s，所以在进行并发编程时，要考虑这些资源的限制。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源限制有数据库的连接数和socket连接数等。

### 资源限制引发的问题

​	在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是**如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢**，因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发地下载和处理数据时，导致CPU利用率达到100%，几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。

### 如何解决资源限制的问题

​	**对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。**比如使用ODPS、Hadoop或者自己搭建服务器集群，不同的机器处理不同的数据。可以通过“数据ID%机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。

​	**对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接**。

### 在资源限制情况下进行并发编程

​	如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。<u>有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接</u>。

## 1.4 本章小结

​	图书的作者建议多使用JDK并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化，均可解决了本章提到的几个挑战。

# 第2章 Java并发机制的底层实现原理

​	**Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行**，Java中所使用的并发机制依赖于JVM的实现和CPU的指令。本章我们将深入底层一起探索下Java并发机制的底层实现原理。

## 2.1 volatile的使用

volatile保证线程可见性（一个线程修改一个共享变量时，另一个线程能读到这个修改的值）。

### volatile的定义与实现原理

#### volatile定义

​	Java语言规范第3版中对`volatile`的定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过**排他锁**单独获得这个变量。Java语言提供了`volatile`，在某些情况下比锁要更加方便。如果一个字段被声明成`volatile`，Java线程内存模型确保所有线程看到这个变量的值是一致的。

CPU的术语定义（表格）

| 术语     | 英语单词 | 术语描述 |
| :-: | :-: | :- |
| 内存屏障 | memory barriers | 是一组处理器指令，用于实现对内存操作的顺序限制 |
| 缓存行 | cache line | 缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，需要使用多个主内存读周期 |
| 原子操作 | atomic operations | 不可中断的一个或一系列操作 |
| 缓存行填充 | cache line fill | 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1、L2、L3的或所有） |
| 缓存命中 | cache hit | 如果进行高速缓存行填充的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取 |
| 写命中 | write hit | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。 |
| 写缺失 | write misses the cache | 一个有效的缓存行被写入到不存在的内存区域 |

X86处理器下，通过工具获取JIT编译器生成的汇编指令来查看volatile进行写操作时，CPU会做什么事情。

Java代码如下：

```java
instance = new Singleton(); // instance是volatile变量
```

转变成的汇编代码如下：

```assembly
0x01a3de1d: movb $0×0,0×1104800(%esi);
# 0x01a3de24: lock addl $0×0,(%esp);  有volatile变量修饰的共享变量进行写操作的时候会多出这行汇编代码
```

通过查IA-32架构软件开发者手册可知，**Lock前缀**的指令在多核处理器下会引发了两件事情：

1. **将当前处理器缓存行的数据写回到系统内存**。
2. **这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效**。

​	<small>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，**在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改0，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。**</small>

---

#### volatile的实现原则

1. **Lock前缀指令会引起处理器缓存回写到内存**。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存*<small>(因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存)</small>*。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，**它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。**
2. *(现在一般是锁缓存行，而非锁总线。缓存行一般64字节)*
3. **一个处理器的缓存回写到内存会导致其他处理器的缓存无效**。IA-32处理器和Intel 64处理器使用**MESI**（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。<u>处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</u>。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

### volatile的使用优化

​	著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类`LinkedTransferQueue`，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。`LinkedTransferQueue`的代码如下。

```java
public class LinkedTransferQueue<E> extends AbstractQueue<E> implements TransferQueue<E>, java.io.Serializable {
  /** 队列中的头部节点 */
  private transient final PaddedAtomicReference<QNode> head;
  /** 队列中的尾部节点 */
  private transient final PaddedAtomicReference<QNode> tail;
  static final class PaddedAtomicReference <T> extends AtomicReference T> {
    // 使用很多4个字节的引用追加到64个字节
    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
    PaddedAtomicReference(T r) {
      super(r);
    }
  } 
  public class AtomicReference <V> implements java.io.Serializable {
    private volatile V value;
    // 省略其他代码
  }
  // ....
}
```

`LinkedTransferQueue`这个类，它使用一个内部类类型来定义队列的头节点（head）和尾节点（tail），而这个内部类

`PaddedAtomicReference`相对于父类`AtomicReference`只做了一件事情，就是将共享变量追加到64字节。一个对象的引用占4个字节，

它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节（大多数处理器的缓存行大小为64字节）。

<small>对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。<u>Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</u></small>

在两种场景下使用`volatile`时不应该使用将变量字节追加到64字节：

1. **缓存行非64字节宽的处理器**。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。

2. **共享变量不会被频繁地写**。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。

<small>不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized。</small>

## 2.2 synchronized的实现原理与应用

​	在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着**Java SE 1.6**对synchronized进行了各种优化之后，有些情况下它就并不那么重了。<u>Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</u>

​	利用`synchronized`实现同步的基础：**Java中的每一个对象都可以作为锁**。具体表现为以下3种形式。

+ 对于普通同步方法，锁是当前实例对象。
+ 对于静态同步方法，锁是当前类的Class对象。
+ 对于同步方法块，锁是`synchonized`括号里配置的对象。

**当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁**。

​	从JVM规范中可以看到`synchonized`在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

​	**`monitorenter`指令是在编译后插入到同步代码块的开始位置，而`monitorexit`是插入到方法结束处和异常处**，JVM要保证每个`monitorenter`必须有对应的`monitorexit`与之配对。**任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。**线程执行到`monitorenter`指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

### 2.2.1 Java对象头

​	`synchronized`用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit；64位虚拟机中，1字节宽等于8字节，即64bit。

| 长度 | 内容 | 说明 |
| :-: | :-: | :-: |
| 32/64bit | Mark Word | 存储对象的hashCode或锁信息等 |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针 |
| 32/64bit | Array length | 数组的长度（如果当前对象是数组） |

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：

| 锁状态   | 25bit            | 4bit         | 1bit是否是偏向锁 | 2bit锁标志位 |
| -------- | ---------------- | ------------ | ---------------- | ------------ |
| 无锁状态 | 对象头的hashCode | 对象分代年龄 | 0                | 01           |

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：

<table>
  <tr align="center">
    <th rowspan="2">锁状态</th>
    <th colspan="2">25bit</th>
    <th rowspan="2">4bit</th>
    <th>1bit</th>
    <th>2bit</th>
  </tr>
  <tr align="center">
    <th>23bit</th>
    <th>2bit</th>
    <th>是否是偏向锁</th>
    <th>锁标志位</th>
  </tr>
  <tr align="center">
    <td>轻量级锁</td>
    <td colspan="4">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr align="center">
    <td>重量级锁</td>
    <td colspan="4">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
  <tr align="center">
    <td>GC标记</td>
    <td colspan="4">空</td>
    <td>11</td>
  </tr>
  <tr align="center">
    <td>偏向锁</td>
    <td>线程ID</td>
    <td>Epoch</td>
    <td>对象分代年龄</td>
    <td>1</td>    
    <td>01</td>
  </tr>
</table>
64位虚拟机下，Mark Word是64bit大小的，其存储结构如下表：

<table>
  <tr align="center">
  	<th rowspan="2">锁状态</th>
    <th>25bit</th>
    <th>31bit</th>
    <th>1bit</th>
    <th>4bit</th>
    <th>1bit</th>
    <th>2bit</th>
  </tr>
  <tr align="center">
  	<th></th>
    <th></th>
    <th>cms_free</th>
    <th>分代年龄</th>
    <th>偏向锁</th>
    <th>锁标志位</th>
  </tr>
  <tr align="center">
    <td>无锁</td>
  	<td>unused</td>
    <td>hashCode</td>
    <td></td>
    <td></td>
    <td>0</td>
    <td>01</td>
  </tr>
  <tr align="center">
    <td>偏向锁</td>
  	<td colspan="2">ThreadID(54bit) &emsp; Epoch(2bit)</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr align="center">
    <td>轻量级锁</td>
  	<td colspan="5">ptr_to_lock_record(62bit)</td>
    <td>00</td>
  </tr>
  <tr align="center">
    <td>重量级锁</td>
  	<td colspan="5">ptr_to_heavyweight_monitor(62bit)</td>
    <td>10</td>
  </tr>
  <tr align="center">
    <td>GC标记</td>
  	<td colspan="5"></td>
    <td>11</td>
  </tr>
</table>

### 2.2.2 锁的升级与对比

​	Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率**。

#### 偏向锁

​	HotSpot的作者经过研究发现，<u>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得</u>，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

##### 偏向锁的撤销

​	**偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁**。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzMvMTZiYjUzZWIzNTc2ZTQzYw)

##### 关闭偏向锁

​	偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟（4秒）之后才激活，如有必要可以使用JVM参数来关闭延迟：`-XX:BiasedLockingStartupDelay=0`。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：`-XX:-UseBiasedLocking=false`，那么程序默认会进入轻量级锁状态。

#### 轻量级锁

##### 轻量级锁加锁

​	线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程<u>尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针</u>。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用**自旋**来获取锁。

##### 轻量级锁解锁

​	轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，**如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁**。图2-2是两个线程同时争夺锁，导致锁膨胀的流程图。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzMvMTZiYjUzZjNlMTc1YjRmZQ)

​	因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

#### 锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                           | 适用场景                          |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | --------------------------------- |
| 偏向锁   | 加锁和解锁都不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 只有一个线程访问同步块            |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间 同步块执行速度非常块 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间慢                           | 追求吞吐量 同步块执行时间较长     |

## 2.3 原子操作的实现原理

​	原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂。让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。

### 术语定义

​	了解原子操作的实现原理前，先要了解一下相关的术语。

| **术语名称** | **英文**               | **解释**                                                     |
| ------------ | ---------------------- | ------------------------------------------------------------ |
| 缓存行       | Cache line             | 缓存的最小操作单位                                           |
| 比较并交换   | Compare and Swap       | CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。 |
| CPU流水线    | CPU pipeline           | CPU流水线的工作方式就像工业生产上的装配流水线，在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。 |
| 内存顺序冲突 | Memory order violation | 内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。 |

### 处理器如何实现原子操作

​	32位IA-32处理器使用基于**对缓存加锁**或**总线加锁**的方式来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性。**处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址**。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，<u>处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性</u>。

#### 使用总线锁保证原子性

​	第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如图2-3所示。

![1](http://ifeve.com/wp-content/uploads/2012/12/1.png)	

​	原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。

​	处理器使用总线锁就是来解决这个问题的。**所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存**。

#### 使用缓存锁保证原子性

​	第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

​	频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为**缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效**，在如图2-3所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行。

#### 两种情况下处理器不会使用缓存锁定

​	第一种情况是：**当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。**

​	第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

​	<u>针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。例如，位测试和修改指令：BTS、BTR、BTC；交换指令XADD、**CMPXCHG**，以及其他一些操作数和逻辑指令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</u>

### Java如何实现原子操作

​	在Java中可以通过**锁**和**循环CAS**的方式来实现原子操作。

#### 使用循环CAS实现原子操作

​	JVM中的CAS操作正是利用了处理器提供的**CMPXCHG指令**实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。

```java
private AtomicInteger atomicI = new AtomicInteger(0);
private int i = 0;
public static void main(String[] args) {
  final Counter cas = new Counter();
  List<Thread> ts = new ArrayList<Thread>(600);
  long start = System.currentTimeMillis();
  for (int j = 0; j < 100; j++) {
    Thread t = new Thread(new Runnable() {
      @Override
      public void run() {
        for (int i = 0; i < 10000; i++) {
          cas.count();
          cas.safeCount();
        }
      }
    });
    ts.add(t);
  }
  for (Thread t : ts) {
    t.start();
  }
  // 等待所有线程执行完成
  for (Thread t : ts) {
    try {
      t.join();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
  System.out.println(cas.i);
  System.out.println(cas.atomicI.get());
  System.out.println(System.currentTimeMillis() - start);
}
/** * 使用CAS实现线程安全计数器 */
private void safeCount() {
  for (;;) {
    int i = atomicI.get();
    boolean suc = atomicI.compareAndSet(i, ++i);
    if (suc) {
      break;
    }
  }
}
/**
* 非线程安全计数器
*/
private void count() {
  i++;
}
```

​	从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。

#### CAS实现原子操作的三大问题

​	在Java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如LinkedTransferQueue类的`xfer`方法。CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。**ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。**

##### ABA问题

​	因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。**ABA问题的解决思路就是使用版本号**。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。**从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题**。这个类的`compareAndSet`方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

```java
public boolean weakCompareAndSet(V   expectedReference, // 预期引用
                                 V   newReference, // 更新后的引用
                                 int expectedStamp, // 预期标志
                                 int newStamp) { // 更新后的标志
  return compareAndSet(expectedReference, newReference,
                       expectedStamp, newStamp);
}
```

##### 循环时间长开销大

​	自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。

##### 只能保证一个共享变量的原子操作

​	当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。**从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作**。

#### 使用锁机制实现原子操作

​	锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是**<u>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</u>**

## 2.4 本章小结

​	volatile、synchronized和原子操作的实现原理。Java中的大部分容器和框架都依赖于volatile和原子操作的实现原理。

# 第3章 Java内存模型

​	Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员，本章将揭开Java内存模型神秘的面纱。本章大致分4部分：

+ Java内存模型的基础，主要介绍内存模型相关的基本概念；
+ Java内存模型中的顺序一致性，主要介绍**重排序**与**顺序一致性内存模型**；
+ 同步原语，主要介绍3个同步原语（**synchronized**、**volatile**和**final**）的内存语义及重排序规则在处理器中的实现；
+ Java内存模型的设计，主要介绍Java内存模型的设计原理，及其与处理器内存模型和顺序一致性内存模型的关系。

## 3.1 Java内存模型的基础

> [Java内存模型基础](https://blog.csdn.net/u011665991/article/details/89426024) => 以下大多数图片出处

### 3.1.1 并发编程模型的两个关键问题

​	在并发编程中，需要处理两个关键问题：

+ 线程之间如何**通信**
+ 线程之间如何**同步**

​	这里的线程是指并发执行的活动实体。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：**共享内存和消息传递**。

​	<small>在**共享内存**的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</small>

​	<small>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</small>

​	**Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明**。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

### 3.1.2 Java内存模型的抽象结构

​	在Java中，所有**实例域、静态域和数组元素都存储在堆内存**中，堆内存在线程之间共享（本章用“共享变量”这个术语代指实例域，静态域和数组元素）。<u>局部变量（Local Variables），方法定义参数（Java语言规范称之为Formal Method Parameters）和异常处理器参数（ExceptionHandler Parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响</u>。

​	Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。**本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化**。

![img](https://img-blog.csdnimg.cn/20190421000245105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2NjU5OTE=,size_16,color_FFFFFF,t_70)

​	如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：

1. 线程A把本地内存A中更新过的共享变量刷新到主内存中去。

2. 线程B到主内存中去读取线程A之前已更新过的共享变量。

![img](https://img-blog.csdnimg.cn/20190421000257648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2NjU5OTE=,size_16,color_FFFFFF,t_70)

​	本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

<small>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</small>

*<small>（这里内部涉及MESI，缓存一致性协议，由硬件和操作系统联合保证对共享的缓存行、内存的读写有序、同步。简单说，如果线程A修改变量x为1并写回内存，而B本地缓存x为0，此时B会发现同一缓存行的变量x变化，需要重新从内存中读取新值）。</small>*

> [并发研究之CPU缓存一致性协议(MESI)](https://www.cnblogs.com/yanlong300/p/8986041.html)

### 3.1.3 从源代码到指令序列的重排序

​	在执行程序时，为了提高性能，**编译器**和**处理器**常常会对指令做**重排序**。重排序分3种类型。

1. **编译器优化的重排序**。编译器在<u>不改变单线程程序语义</u>的前提下，可以重新安排语句

   的执行顺序。

2. **指令级并行的重排序**。现代处理器采用了指令级并行技术（Instruction-Level

   Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应

   机器指令的执行顺序。

3. **内存系统的重排序**。由于**处理器使用缓存和读/写缓冲区**，这使得加载和存储操作看上

   去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序：

![img](https://img-blog.csdnimg.cn/2019042100032094.png)

​	<small>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，**通过内存屏障指令来禁止特定类型的处理器重排序。**</small>

​	JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的**编译器重排序**和**处理器重排序**，为程序员提供一致的内存可见性保证。

> [计算机组成原理17----CPU指令流水线](https://blog.csdn.net/u014106644/article/details/95209474)
>
> [关于volatile、MESI、内存屏障、#Lock](https://www.jianshu.com/p/6745203ae1fe)
>
> [intel x86系列CPU既然是strong order的，不会出现loadload乱序，为什么还需要lfence指令？](https://www.zhihu.com/question/29465982)

### 3.1.4 并发编程模型的分类

​	**现代的处理器使用写缓冲区临时保存向内存写入的数据**。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但**每个处理器上的写缓冲区，仅仅对它所在的处理器可见**。这个特性会对内存操作的执行顺序产生重要的影响：**处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致**。

<table>
  <tr align="center">
  	<th>ProcessorA</th>
    <th>ProcessorB</th>
  </tr>
  <tr align="center">
  	<td>
    	<p>
        a = 1; //A1<br/>
				x = b; //A2
      </p>
    </td>
    <td>
    	<p>
        b = 2; //B1<br/>
				y = a; //B2
      </p>
    </td>
  </tr>
  <tr align="center">
    <td colspan="2">
      <p>
      初始状态：a = b = 0<br/>
			处理器允许执行后得到结果：x = y = 0
    	</p>
    </td>
  </tr>
</table>

假设处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到x=y=0的结果。

![img](https://img-blog.csdnimg.cn/20190421000335153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2NjU5OTE=,size_16,color_FFFFFF,t_70)

​	<small>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x=y=0的结果。</small>

​	<small>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1→A2，但内存操作实际发生的顺序却是A2→A1。此时，处理器A的内存操作顺序被重排序了</small>

​	这里的关键是，**由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致**。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序。

​	**常见处理器允许的重排序类型**的列表：("N"表示处理器不允许两个操作重排序，"Y"表示允许重排)

| 处理器\规则 | Load-Load | Load-Store | Store-Store | Store-Load | 数据依赖 |
| ----------- | --------- | ---------- | ----------- | ---------- | -------- |
| sparc-TSO   | N         | N          | N           | **Y**      | N        |
| x86         | N         | N          | N           | **Y**      | N        |
| ia64        | Y         | Y          | Y           | **Y**      | N        |
| PowerPC     | Y         | Y          | Y           | **Y**      | N        |

​	从表格可知：**常见的处理器都允许Store-Load重排序**；**常见的处理器都不允许对存在数据依赖的操作做重排序**。sparc-TSO和X86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。

注意：

+ sparc-TSO是指以TSO（Total Store Order）内存模型运行时sparc处理器的特性
+ 表中的X86包括X64及AMD64
+ 由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它
+ 数据依赖性后文会专门说明

​	为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为4类：

| 屏障类型            | 指令示例                   | 说明                                                         |
| ------------------- | -------------------------- | ------------------------------------------------------------ |
| LoadLoad Barriers   | Load1; LoadLoad; Load2     | 确保Load1数据的装载先于Load2及所有后续装载指令的装载         |
| StoreStore Barriers | Store1; StoreStore; Store2 | 确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储 |
| LoadStore Barriers  | Load1; LoadStore; Store2   | 确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存    |
| StoreLoad Barriers  | Store1; StoreLoad; Load2   | 确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令 |

​	**StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。**

### 3.1.5 happens-before简介

​	从JDK 5开始，Java使用新的JSR-133内存模型（除非特别说明，本文针对的都是JSR-133内存模型）。**JSR-133使用happens-before的概念来阐述操作之间的内存可见性**。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。<u>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间</u>。

​	与程序员密切相关的happens-before规则如下：

+ **程序顺序规则**：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
+ **监视器锁规则**：对一个锁的解锁，happens-before于随后对这个锁的加锁。
+ **volatile变量规则**：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
+ **传递性**：如果A happens-before B，且B happens-before C，那么A happens-before C。

注意：

　**两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行**！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens-before的定义很微妙，后文会具体说明happens-before为什么要这么定义。

​	happens-before与JMM的关系如图所示。

![img](https://img-blog.csdnimg.cn/20190421000355199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2NjU5OTE=,size_16,color_FFFFFF,t_70)

​	如图所示，一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。

## 3.2 重排序

​	重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。

### 3.2.1 数据依赖性

​	如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型，如表所示。

<table>
  <tr>
  	<th>名称</th>
    <th>代码示例</th>
    <th>说明</th>
  </tr>
  <tr>
  	<td>写后读</td>
    <td>
      a = 1;<br/>
      b = a;
    </td>
    <td>写一个变量之后，再读这个位置</td>
  </tr>
  <tr>
  	<td>写后写</td>
    <td>
      a = 1;<br/>
      a = 2;
    </td>
    <td>写一个变量之后，再写这个变量</td>
  </tr>
  <tr>
  	<td>读后写</td>
    <td>
      a = b;<br/>
      b = 1;
    </td>
    <td>读一个变量之后，再写这个变量</td>
  </tr>
</table>

​	上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。

​	前面提到过，编译器和处理器可能会对操作做重排序。**编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序**。

​	**这里所说的数据依赖性仅针对<u>单个处理器中执行的指令序列和单个线程</u>中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。**

### 3.2.2 as-if-serial语义

​	**as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变**。<u>编译器、runtime和处理器都必须遵守as-if-serial语义</u>。**为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序**，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。

```java
double pi = 3.14; // A
double r = 1.0; // B
double area = pi * r * r; // C
```

上面3个操作的数据依赖关系如图所示。

![img](https://img.jbzj.com/file_images/article/201905/2019052111184516.png)

​	<small>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</small>

![img](https://img.jbzj.com/file_images/article/201905/2019052111184517.png)

​	as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。asif-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。

> [深入理解happens-before和as-if-serial语义](https://www.jb51.net/article/161668.htm) <= 图片来源

### 3.2.3 程序顺序规则

​	根据happens-before的程序顺序规则，上面计算圆的面积的示例代码存在3个happens-before关系。

1. A　happens-before B。
2. B　happens-before C。
3. A　happens-before C。

​	这里的第3个happens-before关系，是根据happens-before的传递性推导出来的。

​	这里A happens-before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。如果A happens-before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且<u>重排序操作A和操作B后的执行结果，与操作A和操作B按happens-before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。</u>

​	**在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能提高并行度**。编译器和处理器遵从这一目标，从happens-before的定义我们可以看出，JMM同样遵从这一目标。

### 3.2.4 重排序对多线程的影响

​	现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码。

```java
class ReorderExample {
  int a = 0;
  boolean flag = false;
  public void writer() {
    a = 1; // 1
    flag = true; // 2
  }
  Public void reader() {
    if (flag) { // 3
      int i = a * a; // 4
      // ……
    }
  }
}
```

​	flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？

**答案是：不一定能看到。**

*<small>(前面数据依赖性的写后写指的是对同一个变量，这个对两个不同变量赋值，完全可能flag赋值先于a变量，导致`reader()`方法中的变量i计算得出0)</small>*

​	由于操作1和操作2**没有数据依赖关系**，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4**没有数据依赖关系**，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图。

![img](https://img.jbzj.com/file_images/article/201905/2019052111184518.png)

​	操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还没有被线程A写入，在这里多线程程序的语义被重排序破坏了！

**注意**：本文统一用虚箭线标识错误的读操作，用实箭线标识正确的读操作。

---

​	下面再让我们看看，当操作3和操作4重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作3和操作4重排序后，程序执行的时序图。

![img](https://img.jbzj.com/file_images/article/201905/2019052111184619.png)

​	在程序中，操作3和操作4**存在控制依赖关系**。**当代码中存在控制依赖性时，会影响指令序列执行的并行度**。为此，**编译器和处理器**会采用**猜测（Speculation）执行**来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a\*a，然后把计算结果临时保存到一个名为**重排序缓冲（Reorder Buffer，ROB）**的硬件缓存中。当操作3的条件判断为真时，就把该计算结果写入变量i中。

​	从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！

​	**在单线程程序中，对存在<u>控制依赖</u>的操作重排序，不会改变执行结果**（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；<u>但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果</u>。

> [处理器结构--ReorderBuffer](https://cloud.tencent.com/developer/article/1358003)

## 3.3 顺序一致性

​	顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。

### 3.3.1 数据竞争与顺序一致性

当程序未正确同步时，就可能会存在数据竞争。Java内存模型规范对数据竞争的定义如下。

​	"在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序。"

JMM对**正确同步的多线程程序的内存一致性**做了如下保证。

​	如果程序是正确同步的，程序的执行将具有顺序一致性（Sequentially Consistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。马上我们就会看到，这对于程序员来说是一个极强的保证。这里的同步是指广义上的同步，包括对常用同步原语（synchronized、volatile和final）的正确使用。

### 3.3.2 顺序一致性内存模型

> [Java并发指南2：深入理解Java内存模型JMM](https://zhuanlan.zhihu.com/p/90920443)

​	<u>顺序一致性内存模型是一个被计算机科学家理想化了的**理论参考模型**</u>，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性。

1. 一个线程中的所有操作必须按照程序的顺序来执行。

2. （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内

存模型中，每个操作都必须原子执行且立刻对所有线程可见。

​	<u>顺序一致性内存模型</u>为程序员提供的视图如下：

![img](https://pic2.zhimg.com/80/v2-4987a0c005023fbbab06293aa2c36da5_1440w.jpg)

​	*<small>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。从上面的示意图可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化（即在顺序一致性模型中，所有操作之间具有全序关系）。</small>*

​	为了更好进行理解，下面通过两个示意图来对顺序一致性模型的特性做进一步的说明。

​	假设有两个线程A和B并发执行。其中A线程有3个操作，它们在程序中的顺序是：A1→A2→A3。B线程也有3个操作，它们在程序中的顺序是：B1→B2→B3。

​	假设这两个线程使用监视器锁来正确同步：A线程的3个操作执行后释放监视器锁，随后B线程获取同一个监视器锁。那么程序在顺序一致性模型中的执行效果将如图所示。

​	![img](https://pic4.zhimg.com/80/v2-a2be3cbfb19fa8854510e708a65e31df_1440w.jpg)

​	现在我们再假设这两个线程没有做同步，下面是这个**未同步程序**在顺序一致性模型中的执行示意图。

![img](https://pic4.zhimg.com/80/v2-4f5afaac60fff83522424ed5486f0d13_1440w.jpg)

​	**未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序**。以上图为例，线程A和B看到的执行顺序都是：B1→A1→A2→B2→A3→B3。之所以能得到这个保证是因为<u>顺序一致性内存模型中的每个操作必须立即对任意线程可见</u>。

​	但是，在**JMM中就没有这个保证**。**未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致**。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。

### 3.3.3 同步程序的顺序一致性效果

​	对前面的示例程序ReorderExample用锁来同步，看看正确同步的程序如何具有顺序一致性。

```java
class SynchronizedExample {
  int a = 0;
  boolean flag = false;
  public synchronized void writer() { // 获取锁
    a = 1;
    flag = true;
  } // 释放锁
  public synchronized void reader() { // 获取锁
    if (flag) {
      int i = a;
      ……
    } // 释放锁
  }
}
```

​	根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比。

​	顺序一致性模型中，所有操作完全按程序的顺序串行执行。**而在JMM中，临界区内的代码可以重排序**（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。<u>虽然线程A在临界区内做了重排序，但由于**监视器互斥执行**的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</u>

​	![img](https://pic1.zhimg.com/80/v2-08b2577f293533447511fe3724ecbd10_1440w.jpg)

​	从这里我们可以看到，**JMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。**

### 3.3.4 未同步程序的执行特性

​	对于未同步或未正确同步的多线程程序，**JMM只提供最小安全性**：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），**JMM保证线程读操作读取到的值不会无中生有**（Out Of Thin Air）的冒出来。为了实现最小安全性，**JVM在堆上分配对象时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在已清零的内存空间（Pre-zeroed Memory）分配对象时，域的默认初始化已经完成了。**

​	**JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致**。因为如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化，这对程序的执行性能会产生很大的影响。而且未同步程序在顺序一致性模型中执行时，整体是无序的，其执行结果往往无法预知。而且，保证未同步程序在这两个模型中的执行结果一致没什么意义。

​	未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。

1. 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而**JMM不保证单线程内的操作会按程序的顺序执行**（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。

2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而**JMM不保证所有线程能看到一致的操作执行顺序**。这一点前面也已经讲过，这里就不再赘述。

3. **JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。**

​	第3个差异与处理器总线的工作机制密切相关。在计算机中，**数据通过总线在处理器和内存之间传递**。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为**总线事务（Bus Transaction）**。总线事务包括读事务（Read Transaction）和写事务（Write Transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，**总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。**下面，让我们通过一个示意图来说明总线的工作机制，如下图所示。

![img](https://pic1.zhimg.com/80/v2-716756201ce6e9dcc569ba78d6658bfc_1440w.jpg)

​	<small>由图可知，假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（Bus Arbitration）会对竞争做出裁决，这里假设总线在仲裁后判定处理器A在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器A继续它的总线事务，而其他两个处理器则要等待处理器A的总线事务完成后才能再次执行内存访问。假设在处理器A执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器D向总线发起了总线事务，此时处理器D的请求会被总线禁止。</small>

​	总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行。**在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。**

​	**在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写操作具有原子性。当JVM在这种处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。**

​	当单个内存操作不具有原子性时，可能会产生意想不到后果。

![img](https://pic3.zhimg.com/80/v2-e78e4a0bc47da41ca330ae0355cb6f5a_1440w.jpg)

​	<small>如上图所示，假设处理器A写一个long型变量，同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作，且这两个32位的写操作被分配到不同的写事务中执行。同时，处理器B中64位的读操作被分配到单个的读事务中执行。当处理器A和B按上图的时序来执行时，处理器B将看到仅仅被处理器A“写了一半”的无效值。</small>

​	注意，在JSR-133之前的旧内存模型中，一个64位long/double型变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，**任意的读操作在JSR-133中都必须具有原子性（即任意读操作必须要在单个读事务中执行）。**

## 3.4 volatile的内存语义

​	当声明共享变量为volatile后，对这个变量的读/写将会很特别。为了揭开volatile的神秘面纱，下面将介绍volatile的内存语义及volatile内存语义的实现。

### 3.4.1 volatile的特性

​	理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。

```java
class VolatileFeaturesExample {
  volatile long vl = 0L; // 使用volatile声明64位的long型变量
  public void set(long l) {
    vl = l; // 单个volatile变量的写
  }
  public void getAndIncrement () {
    vl++; // 复合（多个）volatile变量的读/写
  }
  public long get() {
    return vl; // 单个volatile变量的读
  }
}
```

​	假设有多个线程分别调用上面程序的3个方法，这个程序在语义上和下面程序等价。

```java
class VolatileFeaturesExample {
  long vl = 0L; // 64位的long型普通变量
  public synchronized void set(long l) { // 对单个的普通变量的写用同一个锁同步
    vl = l;
  }
  public void getAndIncrement () { // 普通方法调用
    long temp = get(); // 调用已同步的读方法
    temp += 1L; // 普通写操作
    set(temp); // 调用已同步的写方法
  }
  public synchronized long get() { // 对单个的普通变量的读用同一个锁同步
    return vl;
  }
}
```

​	如上面示例程序所示，一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间的执行效果相同。

​	**锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性**，这意味着**对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入**。

​	**锁的语义决定了临界区代码的执行具有原子性**。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。**如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。**

​	简而言之，volatile变量自身具有下列特性。

+ **可见性**：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。

+ **原子性**：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

### 3.4.2 volatile写-读建立的happens-before关系

> [【读书笔记】《Java并发编程的艺术》Java内存模型——volatile的内存语义](https://blog.csdn.net/Handsome_Le_le/article/details/108191402)

​	上面讲的是volatile变量自身的特性，对程序员来说，volatile对**线程的内存可见性**的影响比volatile自身的特性更为重要，也更需要我们去关注。

​	从JSR-133开始（即从JDK5开始），volatile变量的写-读可以实现线程之间的通信。

​	<u>从**内存语义**的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义</u>。

```java
class VolatileExample {
  int a = 0;
  volatile boolean flag = false;
  public void writer() {
    a = 1;　　　　　 // 1
    flag = true;　　　 // 2
  }
  public void reader() {
    if (flag) {　　　　// 3
      int i = a;　　 // 4
      ……
    }
  }
}
```

​	假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens-before规则，这个过程建立的happens-before关系可以分为3类：

1. 根据程序次序规则，1 happens-before 2;3 happens-before 4。

2. 根据volatile规则，2 happens-before 3。

3. 根据happens-before的传递性规则，1 happens-before 4。

上述happens-before关系的图形化表现形式如下。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200825141849209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbmRzb21lX0xlX2xl,size_16,color_FFFFFF,t_70#pic_center)

​	在上图中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens-before保证。

​	这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。

注意：这本书的文章统一用粗实线标识组合后产生的happens-before关系。

### 3.4.3 volatile写-读的内存语义

​	volatile写的内存语义如下。

​	**当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。**

​	以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行volatile写后，共享变量的状态示意图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200825142426491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbmRzb21lX0xlX2xl,size_16,color_FFFFFF,t_70#pic_center)

​	线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。

---

​	volatile读的内存语义如下。

​	**当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。**

​	在读flag变量后，本地内存B包含的值已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值变成一致。

​	如果我们把volatile写和volatile读两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200825142726784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbmRzb21lX0xlX2xl,size_16,color_FFFFFF,t_70#pic_center)

​	下面对volatile写和volatile读的内存语义做个总结。

+ 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程

发出了（其对共享变量所做修改的）消息。

+ 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile

变量之前对共享变量所做修改的）消息。

+ 线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过

主内存向线程B发送消息。

### 3.4.4 volatile内存语义的实现

> [volatile禁止重排序的原理-内存屏障](https://blog.csdn.net/pang5356/article/details/109226307)

​	重排序分为**编译器重排序**和**处理器重排序**。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。

​	JMM针对<u>编译器</u>制定了volatile重排序规则表。

<table>
  <tr align="center">
  	<th>是否能重排序</th>
    <th colspan="3">第二个操作</th>
  </tr>
  <tr align="center">
  	<td>第一个操作</td>
    <td>普通读/写</td>
    <td>volatile读</td>
    <td>volatile写</td>
  </tr>
  <tr align="center">
  	<td>普通读/写</td>
    <td></td>
    <td></td>
    <td>NO</td>
  </tr>
  <tr align="center">
  	<td>volatile读</td>
    <td>NO</td>
    <td>NO</td>
    <td>NO</td>
  </tr>
  <tr align="center">
  	<td>volatile写</td>
    <td></td>
    <td>NO</td>
    <td>NO</td>
  </tr>
</table>

​	举例来说，第三行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。

+ **当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。**

+ **当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。**

+ **当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。**

​	为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入**内存屏障**来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。

+ **在每个volatile写操作的前面插入一个StoreStore屏障。**

+ **在每个volatile写操作的后面插入一个StoreLoad屏障。**

+ **在每个volatile读操作的后面插入一个LoadLoad屏障。**

+ **在每个volatile读操作的后面插入一个LoadStore屏障。**

​	上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。

---

​	下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201022172226543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhbmc1MzU2,size_16,color_FFFFFF,t_70#pic_center)

​	图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为**StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存**。

​	这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。**从这里可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。**

---

​	下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201022172412526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhbmc1MzU2,size_16,color_FFFFFF,t_70#pic_center)

​	图中的**LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序**。

---

​	上述volatile写和volatile读的内存屏障插入策略非常保守。**在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障**。

```java
class VolatileBarrierExample {
  int a;
  volatile int v1 = 1;
  volatile int v2 = 2;
  void readAndWrite() {
    int i = v1;　　 // 第一个volatile读
    int j = v2; 　 // 第二个volatile读
    a = i + j; // 普通写
    v1 = i + 1; 　 // 第一个volatile写
    v2 = j * 2; 　 // 第二个 volatile写
  }
  …　　　　　　 // 其他方法
}
```

针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201022172538891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhbmc1MzU2,size_16,color_FFFFFF,t_70#pic_center)

​	**注意，最后的StoreLoad屏障不能省略**。<u>因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插入一个StoreLoad屏障</u>。

​	<u>上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为例，图中除最后的StoreLoad屏障外，其他的屏障都会被省略。</u>

---

​	前面保守策略下的volatile读和写，在X86处理器平台可以优化成如图所示。

​	前文（3.1.4并发编程模型的分类）提到过，**X86处理器仅会对写-读操作做重排序**。X86不会对读-读、读-写和写-写操作做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。在X86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。

​	![在这里插入图片描述](https://img-blog.csdnimg.cn/20201022172808413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhbmc1MzU2,size_16,color_FFFFFF,t_70#pic_center)

### 3.4.5 JSR-133为什么要增强volatile的内存语义

> [《Java并发编程的艺术》 —3.4.5　JSR-133为什么要增强volatile的内存语义](https://bbs.huaweicloud.com/blogs/136249)

​	**在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序**。在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行，如图所示。

![img](https://bbs-img.huaweicloud.com/blogs/img/1575359923453584.png)

​	在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。

​	因此，在旧的内存模型中，volatile的写-读没有锁的释放-获取所具有的内存语义。**为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。**<u>从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止</u>。

​	**由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。**如果读者想在程序中用volatile代替锁，请一定谨慎，具体详情请参阅Brian Goetz的文章《Java理论与实践：正确使用Volatile变量》。

## 3.5 锁的内存语义

​	众所周知，锁可以让临界区互斥执行。这里将介绍锁的另一个同样重要，但常常被忽视的功能：锁的内存语义。

### 3.5.1 锁的释放-获取建立的happens-before关系

> [《Java并发编程的艺术》 读书笔记 之 Java内存模型（五）锁的内存语义](https://blog.csdn.net/lejustdoit/article/details/97259630)

​	锁是Java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。

```java
class MonitorExample {
  int a = 0;
  public synchronized void writer() {　　　　 // 1
    a++;　　　　　　　　　　 // 2
  }　　　　　　　　　　　　 // 3
  public synchronized void reader() {　　　 // 4
    int i = a;　　　　　　　　 // 5
    ……
  }　　　　　　　　　　　　 // 6
}
```

​	假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens-before规则，这个过程包含的happens-before关系可以分为3类。<small>(happens-before三种形式记不清的可以回顾3.1.5 happens-before简介)</small>

1. 根据程序次序规则，1 happens-before 2,2 happens-before 3;4 happens-before 5,5 happensbefore 6。

2. 根据监视器锁规则，3 happens-before 4。

3. 根据happens-before的传递性，2 happens-before 5。

上述happens-before关系的图形化表现形式如图所示。

![img](https://img-blog.csdnimg.cn/2019072514192863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlanVzdGRvaXQ=,size_16,color_FFFFFF,t_70)

​	每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens-before保证。

​	在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens-before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。

### 3.5.2 锁的释放和获取的内存语义

​	**当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。**以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如图所示。

![img](https://img-blog.csdnimg.cn/20190725141944826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlanVzdGRvaXQ=,size_16,color_FFFFFF,t_70)

---

​	**当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量**。图是锁获取的状态示意图。

![img](https://img-blog.csdnimg.cn/2019072514195712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlanVzdGRvaXQ=,size_16,color_FFFFFF,t_70)

​	**对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。**

---

​	下面对锁释放和锁获取的内存语义做个总结。

+ 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A

对共享变量所做修改的）消息。

+ 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共

享变量所做修改的）消息。

+ 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发

送消息。

### 3.5.3 锁内存语义的实现

> [ReentrantLock原理分析](https://www.cnblogs.com/wangymd/p/13064036.html)

​	本文（指这本书）将借助ReentrantLock的源代码，来分析锁内存语义的具体实现机制。

```java
class ReentrantLockExample {
  int a = 0;
  ReentrantLock lock = new ReentrantLock();
  public void writer() {
    lock.lock();　　　　 // 获取锁
    try {
      a++;
    } finally {
      lock.unlock();　　// 释放锁
    }
  }
  public void reader () {
    lock.lock();　　　　 // 获取锁
    try {
      int i = a;
      ……
    } finally {
      lock.unlock();　 // 释放锁
    }
  }
}
```

​	在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。

​	ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。**AQS使用一个整型的volatile变量（命名为state）来维护同步状态**，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。

​	图3-27是ReentrantLock的类图（仅画出与本文相关的部分）。

![img](https://img2020.cnblogs.com/blog/1209653/202006/1209653-20200608095900109-733735179.png)



ReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。

使用公平锁时，加锁方法lock()调用轨迹如下。

1. ReentrantLock:lock()。

2. FairSync:lock()。

3. AbstractQueuedSynchronizer:acquire(int arg)。

4. ReentrantLock:tryAcquire(int acquires)。

在第4步真正开始加锁，下面是该方法的源代码：

```java
protected final boolean tryAcquire(int acquires) {
  final Thread current = Thread.currentThread();
  int c = getState();　　　　// 获取锁的开始，首先读volatile变量state
  if (c == 0) {
    if (isFirst(current) &&
        compareAndSetState(0, acquires)) {
      setExclusiveOwnerThread(current);
      return true;
    }
  }
  else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc < 0)　　
      throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
  }
  return false;
}
```

从上面源代码中我们可以看出，加锁方法首先读volatile变量state。

---

在使用公平锁时，解锁方法unlock()调用轨迹如下。

1. ReentrantLock:unlock()。

2. AbstractQueuedSynchronizer:release(int arg)。

3. Sync:tryRelease(int releases)。

在第3步真正开始释放锁，下面是该方法的源代码。

```java
protected final boolean tryRelease(int releases) {
  int c = getState() - releases;
  if (Thread.currentThread() != getExclusiveOwnerThread())
    throw new IllegalMonitorStateException();
  boolean free = false;
  if (c == 0) {
    free = true;
    setExclusiveOwnerThread(null);
  }
  setState(c);　　　　　// 释放锁的最后，写volatile变量state
  return free;
}
```

​	从上面的源代码可以看出，在释放锁的最后写volatile变量state。

​	公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。

---

​	现在我们来分析非公平锁的内存语义的实现。**非公平锁的释放和公平锁完全一样**，所以这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下。

1. ReentrantLock:lock()。

2. NonfairSync:lock()。

3. AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)。

在第3步真正开始加锁，下面是该方法的源代码。

```java
protected final boolean compareAndSetState(int expect, int update) {
  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

​	<u>该方法以原子操作的方式更新state变量，本文把Java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义</u>。

​	这里我们分别从编译器和处理器的角度来分析，CAS如何同时具有volatile读和volatile写的内存语义。

​	前文我们提到过，编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着**为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序**。

​	下面我们来分析在常见的intel X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的。

​	下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码。

```java
public final native boolean compareAndSwapInt(Object o, long offset,
                                              int expected,
                                              int x);
```

​	可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：unsafe.cpp，atomic.cpp和atomic*windows*x86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147-27*jun*2011\openjdk\hotspot\src\os*cpu\windows*x86\vm\ atomic*windows*x86.inline.hpp（对应于windows操作系统，X86处理器）。下面是对应于intel X86处理器的源代码的片段。

```c
// Adding a lock prefix to an instruction on MP machine
// VC++ doesn't like the lock prefix to be on a single line
// so we can't insert a label after the lock prefix.
// By emitting a lock prefix, we can define a label after it.
#define LOCK_IF_MP(mp) __asm cmp mp, 0  \
                       __asm je L0      \
                       __asm _emit 0xF0 \
                       __asm L0:

inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {
  // alternative for InterlockedCompareExchange
  int mp = os::is_MP();
  __asm {
    mov edx, dest
      mov ecx, exchange_value
      mov eax, compare_value
      LOCK_IF_MP(mp)
      cmpxchg dword ptr [edx], ecx
  }
}
```

​	如上面源代码所示，<u>程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（Lock Cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）</u>。

​	intel的手册对**lock前缀**的说明如下。

1. 确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前

缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会

带来昂贵的开销。从Pentium 4、Intel Xeon及P6处理器开始，Intel使用缓存锁定（Cache Locking）

来保证指令执行的原子性。**缓存锁定将大大降低lock前缀指令的执行开销**。

2. **禁止该指令，与之前和之后的读和写指令重排序。**

3. **把写缓冲区中的所有数据刷新到内存中。**

上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。

经过上面的分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。

---

现在对公平锁和非公平锁的内存语义做个总结。

+ 公平锁和非公平锁释放时，最后都要写一个volatile变量state。

+ 公平锁获取时，首先会去读volatile变量。

+ 非公平锁获取时，首先会用**CAS更新volatile变量，这个操作同时具有volatile读和volatile**

**写的内存语义**。

**从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式。**

1. **利用volatile变量的写-读所具有的内存语义。**

2. **利用CAS所附带的volatile读和volatile写的内存语义。**

### 3.5.4 concurrent包的实现

> [concurrent包的实现](https://blog.csdn.net/fristjcjdncg/article/details/107836695)

​	由于**Java的CAS同时具有volatile读和volatile写的内存语义**，因此Java线程之间的通信现在有了下面4种方式。

1. A线程写volatile变量，随后B线程读这个volatile变量。

2. A线程写volatile变量，随后B线程用CAS更新这个volatile变量。

3. A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。

4. A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。

​	**Java的CAS会使用现代处理器上提供的高效机器级别的原子指令**，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（**从本质上来说，能够支持原子性读-改-写指令的计算机，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令**）。同时，<u>volatile变量的读/写和CAS可以实现线程之间的通信</u>。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。

+ **首先，声明共享变量为volatile。**

+ **然后，使用CAS的原子条件更新来实现线程之间的同步。**

+ **同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。**

​	AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200806122925981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyaXN0amNqZG5jZw==,size_16,color_FFFFFF,t_70)

## 3.6 final域的内存语义

​	与前面介绍的锁和volatile相比，对final域的读和写更像是普通的变量访问。下面将介绍final域的内存语义。

### 3.6.1 final域的重排序规则

​	对于final域，**编译器**和**处理器**要遵守两个重排序规则。

1. **在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。**

2. **初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。**

```java
public class FinalExample {
  int i;　　　　　　　　　　 // 普通变量
  final int j;　　　　　　　　 // final变量
  static FinalExample obj;
  public FinalExample () {　　 // 构造函数
    i = 1;　　　　　　　　 // 写普通域
    j = 2;　　　　　　　　 // 写final域
  }
  public static void writer () {　 // 写线程A执行
    obj = new FinalExample ();
  }
  public static void reader () {　 // 读线程B执行
    FinalExample object = obj; // 读对象引用
    int a = object.i;　　　　　 // 读普通域
    int b = object.j;　　　　　 // 读final域
  }
}
```

​	这里假设一个线程A执行writer()方法，随后另一个线程B执行reader()方法。下面我们通过这两个线程的交互来说明这两个规则。

### 3.6.2 写final域的重排序规则

​	**写final域的重排序规则禁止把final域的写重排序到构造函数之外**。这个规则的实现包含下面2个方面。

1. **JMM禁止编译器把final域的写重排序到构造函数之外**。

2. **编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外**。

​	分析writer()方法。writer()方法只包含一行代码：`obj = new FinalExample()`。这行代码包含两个步骤，如下：

1. 构造一个FinalExample类型的对象。

2. 把这个对象的引用赋值给引用变量obj。

​	假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序。

​	在下图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。

​	**写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障**。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值1还没有写入普通域i）。

![img](https://images2018.cnblogs.com/blog/1271073/201711/1271073-20171125101432031-773659605.png)

### 3.6.3 读final域的重排序规则

> [多线程与高并发(五)final关键字](https://www.cnblogs.com/yuanqinnan/p/11231274.html)

​	**读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。**

​	**初次读对象引用与初次读该对象包含的final域，这两个操作之间存在<u>间接依赖关系</u>。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作**。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。

​	reader()方法包含3个操作：

+ 初次读引用变量obj。

+ 初次读引用变量obj指向对象的普通域j。

+ 初次读引用变量obj指向对象的final域i。

​	现在假设写线程A没有发生任何重排序，同时程序在<u>不遵守间接依赖</u>的处理器上执行，下图所示是一种可能的执行时序。

![img](https://img2018.cnblogs.com/blog/1113901/201907/1113901-20190723133514066-2107664801.png)

​	在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而**读final域的重排序规则会把读对象final域的操作"限定"在读对象引用之后**，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。

​	**读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用**。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。

### 3.6.4 final域为引用类型

​	上面我们看到的final域是基础数据类型，如果final域是引用类型，将会有什么效果？请看下列示例代码。

```java
public class FinalReferenceExample {
  final int[] intArray; // final是引用类型
  static FinalReferenceExample obj;
  public FinalReferenceExample () { // 构造函数
    intArray = new int[1]; // 1
    intArray[0] = 1; // 2
  }
  public static void writerOne () { // 写线程A执行
    obj = new FinalReferenceExample (); // 3
  }
  public static void writerTwo () { // 写线程B执行
    obj.intArray[0] = 2; // 4
  }
  public static void reader () { // 读线程C执行
    if (obj != null) { // 5
      int temp1 = obj.intArray[0]; // 6
    }
  }
}
```

​	本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对**编译器**和**处理器**增加了如下约束：**在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序**。

​	对上面的示例程序，假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader()方法。下图是一种可能的线程执行时序。

![img](https://img2018.cnblogs.com/blog/1113901/201907/1113901-20190723133615280-1259470664.png)

​	在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。

​	**JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。**

​	如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用**同步原语（lock或volatile）来确保内存可见性**。

（换言之，final只保证构造函数内对final的使用与构造函数外第一次使用final对象/变量时不会有重排序，之后再修改final引用对象的值，JMM不再保证不会重排序。）

### 3.6.5 为什么final引用不能从构造函数内"溢出"

> [理解final](http://www.mamicode.com/info-detail-1021008.html)

​	前面我们提到过，**写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了**。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面的示例代码。

```java
public class FinalReferenceEscapeExample {
  final int i;
  static FinalReferenceEscapeExample obj;
  public FinalReferenceEscapeExample () {
    i = 1; // 1写final域
    obj = this; // 2 this引用在此"逸出"
  }
  public static void writer() {
    new FinalReferenceEscapeExample ();
  }
  public static void reader() {
    if (obj != null) { // 3
      int temp = obj.i; // 4
    }
  }
}
```

​	假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：

![技术分享](http://static.oschina.net/uploads/img/201509/02112811_R6Ol.png)



​	在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。

### 3.6.6 final语义在处理器中的实现

​	现在我们以X86处理器为例，说明final语义在处理器中的具体实现。

+ **写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。**
+ **读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。**

​	由于X86处理器不会对写-写操作做重排序，所以在X86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于X86处理器不会对存在间接依赖关系的操作做重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，<u>在X86处理器中，final域的读/写不会插入任何内存屏障</u>！

### 3.6.7 JSR-133为什么要增强final的语义

​	在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。最常见的例子就是**在旧的Java内存模型中，String的值可能会改变**。

​	**为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值**。

## 3.7 happens-before

​	happens-before是JMM最核心的概念。对应Java程序员来说，理解happens-before是理解JMM的关键。

### 3.7.1 JMM的设计

​	首先，让我们来看**JMM的设计意图**。从JMM设计者的角度，在设计JMM时，需要考虑两个关键因素。

+ **程序员对内存模型的使用**。程序员希望内存模型易于理解、易于编程。程序员希望基于一个**强**内存模型来编写代码。

+ **编译器和处理器对内存模型的实现**。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个**弱**内存模型。

​	由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。下面让我们来看JSR-133是如何实现这一目标的。

```java
double pi = 3.14;　　 // A
double r = 1.0;　　　　 // B
double area = pi * r * r;　 // C
```

​	上面计算圆的面积的示例代码存在3个happens-before关系，如下。

+ A happens-before B。

+ B happens-before C。

+ A happens-before C。

​	在3个happens-before关系中，2和3是必需的，但1是不必要的。因此，JMM把happens-before要求禁止的重排序分为了下面两类。

+ **会改变程序执行结果的重排序。**

+ **不会改变程序执行结果的重排序。**

​	JMM对这两种不同性质的重排序，采取了不同的策略，如下。

+ **对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。**

+ **对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。**

![img](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1603787024&di=fd0860277e9990dd4861c164b30d35e5&src=http://pic4.zhimg.com/8bb99fb04ac47374d96a63d526e96a9b_r.jpg)

+ JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens-before B）。

+ JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，**JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行**。<u>例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</u>

### 3.7.2 happens-before的定义

​	happens-before的概念最初由Leslie Lamport在其一篇影响深远的论文（《Time，Clocks andthe Ordering of Events in a Distributed System》）中提出。Leslie Lamport使用happens-before来定义分布式系统中事件之间的偏序关系（partial ordering）。Leslie Lamport在这篇论文中给出了一个分布式算法，该算法可以将该偏序关系扩展为某种全序关系。

​	JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，<u>**JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证**（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）</u>。

​	《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义如下。

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

2. **两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）**。

​	上面的（1）是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！

​	上面的（2）是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，**happens-before关系本质上和as-if-serial语义是一回事**。

+ **as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。**

+ as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。
+ happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。

​	as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。

### 3.7.3 happens-bofore规则

> [《Java并发编程的艺术》 读书笔记 之 Java内存模型（七）happens-before](https://blog.csdn.net/lejustdoit/article/details/97259941)

《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则。

1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。

2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。

3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。

4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

5. start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。

6. join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

---

​	这里的规则1）、2）、3）和4）前面都讲到过，这里再做个总结。由于2）和3）情况类似，这里只以1）、3）和4）为例来说明。下图是volatile写-读建立的happens-before关系图。

![img](https://img-blog.csdnimg.cn/20190725142831624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlanVzdGRvaXQ=,size_16,color_FFFFFF,t_70)

+ 1 happens-before 2和3 happens-before 4由程序顺序规则产生。<u>由于编译器和处理器都要遵守as-if-serial语义，也就是说，as-if-serial语义保证了程序顺序规则</u>。因此，可以把程序顺序规则看成是对as-if-serial语义的“封装”。

+ 2 happens-before 3是由volatile规则产生。前面提到过，对一个volatile变量的读，总是能看到（任意线程）之前对这个volatile变量最后的写入。因此，volatile的这个特性可以保证实现volatile规则。

+ 1 happens-before 4是由传递性规则产生的。这里的传递性是由volatile的内存屏障插入策略和volatile的编译器重排序规则共同来保证的。

---

​	下面我们来看start()规则。假设线程A在执行的过程中，通过执行ThreadB.start()来启动线程B；同时，假设线程A在执行ThreadB.start()之前修改了一些共享变量，线程B在开始执行后会读这些共享变量。下图是该程序对应的happens-before关系图。

![img](https://img-blog.csdnimg.cn/20190725142843630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlanVzdGRvaXQ=,size_16,color_FFFFFF,t_70)

​	在上图中，1 happens-before 2由程序顺序规则产生。2 happens-before 4由start()规则产生。根据传递性，将有1 happens-before 4。这实意味着，线程A在执行ThreadB.start()之前对共享变量所做的修改，接下来在线程B开始执行后都将确保对线程B可见。

---

​	下面我们来看join()规则。假设线程A在执行的过程中，通过执行ThreadB.join()来等待线程B终止；同时，假设线程B在终止之前修改了一些共享变量，线程A从ThreadB.join()返回后会读这些共享变量。下图是该程序对应的happens-before关系图。

![img](https://img-blog.csdnimg.cn/20190725142901964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlanVzdGRvaXQ=,size_16,color_FFFFFF,t_70)

​	在上图中，2 happens-before 4由join()规则产生；4 happens-before 5由程序顺序规则产生。根据传递性规则，将有2 happens-before 5。这意味着，线程A执行操作ThreadB.join()并成功返回后，线程B中的任意操作都将对线程A可见。

## 3.8 双重检查锁定与延迟初始化

​	在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。**双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法**。本文将分析双重检查锁定的错误根源，以及两种线程安全的延迟初始化方案。

### 3.8.1 双重检查锁定与延迟初始化

​	在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只有在使用这些对象时才进行初始化。此时，程序员可能会采用延迟初始化。但要正确实现线程安全的延迟初始化需要一些技巧，否则很容易出现问题。比如，下面是非线程安全的延迟初始化对象的示例代码。

```java
public class UnsafeLazyInitialization {
  private static Instance instance;
  public static Instance getInstance() {
    if (instance == null) // 1：A线程执行
      instance = new Instance(); // 2：B线程执行
    return instance;
  }
}
```

​	在UnsafeLazyInitialization类中，假设A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化（出现这种情况的原因见3.8.2节）。

​	对于UnsafeLazyInitialization类，我们可以对getInstance()方法做同步处理来实现线程安全的延迟初始化。示例代码如下。

```java
public class SafeLazyInitialization {
  private static Instance instance;
  public synchronized static Instance getInstance() {
    if (instance == null)
      instance = new Instance();
    return instance;
  }
}
```

​	由于对getInstance()方法做了同步处理，synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。反之，如果getInstance()方法不会被多个线程频繁的调用，那么这个延迟初始化方案将能提供令人满意的性能。

​	在早期的JVM中，synchronized（甚至是无竞争的synchronized）存在巨大的性能开销。因此，人们想出了一个“聪明”的技巧：双重检查锁定（Double-Checked Locking）。人们想通过双重检查锁定来降低同步的开销。下面是使用双重检查锁定来实现延迟初始化的示例代码。

```java
public class DoubleCheckedLocking { // 1
  private static Instance instance; // 2
  public static Instance getInstance() { // 3
    if (instance == null) { // 4:第一次检查
      synchronized (DoubleCheckedLocking.class) { // 5:加锁
        if (instance == null) // 6:第二次检查
          instance = new Instance(); // 7:问题的根源出在这里
      } // 8
    } // 9
    return instance; // 10
  } // 11
}
```

​	如上面代码所示，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。上面代码表面上看起来，似乎两全其美。

+ 多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。

+ 在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象。双重检查锁定看起来似乎很完美，但这是一个错误的优化！在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。

### 3.8.2 问题的根源

> [双重检查锁定与延迟初始化](https://www.cnblogs.com/leekeggs/p/9386722.html)

​	前面的双重检查锁定示例代码的第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。

```java
memory = allocate();　　// 1：分配对象的内存空间
ctorInstance(memory);　 // 2：初始化对象
instance = memory;　　 // 3：设置instance指向刚分配的内存地址
```

​	上面3行伪代码中的2和3之间，可能会被重排序（在一些JIT编译器上，这种重排序是真实发生的，详情见参考文献1的“Out-of-order writes”部分）。2和3之间重排序之后的执行时序如下。

```java
memory = allocate();　　// 1：分配对象的内存空间
instance = memory;　　 // 3：设置instance指向刚分配的内存地址
// 注意，此时对象还没有被初始化！
ctorInstance(memory);　 // 2：初始化对象
```

​	根据《The Java Language Specification,Java SE 7 Edition》（后文简称为Java语言规范），所有线程在执行Java程序时必须要遵守intra-thread semantics。**intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。**上面3行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。

​	为了更好地理解intra-thread semantics，请看如下图所示的示意图（假设一个线程A在构造对象后，立即访问这个对象）。

![img](https://images2018.cnblogs.com/blog/1394203/201807/1394203-20180729194217017-644255183.png)

下面，再让我们查看多线程并发执行的情况。

![img](https://images2018.cnblogs.com/blog/1394203/201807/1394203-20180729194253013-791560731.png)

​	由于单线程内要遵守intra-thread semantics，从而能保证A线程的执行结果不会被改变。但是，当线程A和B按上图的时序执行时，B线程将看到一个还没有被初始化的对象。

​	回到本文的主题，DoubleCheckedLocking示例代码的第7行（`instance=new Singleton();`）如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化！下表是这个场景的具体执行时序。

| 时间 | 线程A                        | 线程B                                                   |
| ---- | ---------------------------- | ------------------------------------------------------- |
| t1   | A1：分配对象的内存空间       |                                                         |
| t2   | A2：设置instance指向内存空间 |                                                         |
| t3   |                              | B1：判断instance是否为空                                |
| t4   |                              | B2：由于instance不为null，线程B将访问instance引用的对象 |
| t5   | A2：初始化对象               |                                                         |
| t6   | A2：访问instance引用的对象   |                                                         |

​	这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会<u>访问到一个还未初始化的对象</u>。

​	在知晓了问题发生的根源之后，我们可以想出两个办法来实现线程安全的延迟初始化。

1. 不允许2和3重排序。

2. 允许2和3重排序，但不允许其他线程“看到”这个重排序。

​	后文介绍的两个解决方案，分别对应于上面这两点。

### 3.8.3 基于volatile的解决方案

​	对于前面的基于双重检查锁定来实现延迟初始化的方案（指DoubleCheckedLocking示例代码），只需要做一点小的修改（把instance声明为volatile型），就可以实现线程安全的延迟初始化。请看下面的示例代码。

```java
public class SafeDoubleCheckedLocking {
  private volatile static Instance instance;
  public static Instance getInstance() {
    if (instance == null) {
      synchronized (SafeDoubleCheckedLocking.class) {
        if (instance == null)
          instance = new Instance(); // instance为volatile，现在没问题了
      }
    }
    return instance;
  }
}
```

​	*注意：这个解决方案需要JDK 5或更高版本（因为从JDK 5开始使用新的JSR-133内存模型规范，这个规范增强了volatile的语义）。*

​	当声明对象的引用为volatile后，3.8.2节中的3行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止。上面示例代码将按如下的时序执行，如下图所示。

![img](https://images2018.cnblogs.com/blog/1394203/201807/1394203-20180729194309917-1189219015.png)

​	这个方案本质上是通过禁止上图中的2和3之间的重排序，来保证线程安全的延迟初始化。

### 3.8.4 基于类初始化的解决方案

​	**JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。**

​	基于这个特性，可以实现另一种线程安全的延迟初始化方案（这个方案被称之为Initialization On Demand Holder idiom）。

```java
public class InstanceFactory {
  private static class InstanceHolder {
    public static Instance instance = new Instance();
  }
  public static Instance getInstance() {
    return InstanceHolder.instance ;　　// 这里将导致InstanceHolder类被初始化
  }
}
```

​	假设两个线程并发执行getInstance()方法，下面是执行的示意图，如图所示。

![img](https://images2018.cnblogs.com/blog/1394203/201807/1394203-20180729194316897-1568897478.png)

​	这个方案的实质是：允许3.8.2节中的3行伪代码中的2和3重排序，但**不允许非构造线程（这里指线程B）“看到”这个重排序**。

​	初始化一个类，包括执行这个类的静态初始化和初始化在这个类中声明的静态字段。**根据Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化**。

1. T是一个类，而且一个T类型的实例被创建。

2. **T是一个类，且T中声明的一个静态方法被调用。**

3. T中声明的一个静态字段被赋值。
4. T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。
5. T是一个顶级类（Top Level Class，见Java语言规范的§7.6），而且一个断言语句嵌套在T内部被执行。

​	在InstanceFactory示例代码中，首次执行getInstance()方法的线程将导致InstanceHolder类被初始化（符合情况4）。

---

> [九. Java内存模型(四)](https://www.jianshu.com/p/12ee2eebfeab)
>
> [java内存模型之双重检测锁和延迟初始化](https://www.cnblogs.com/baichendongyang/p/13235467.html)
>
> [并发编程的艺术--第三章：Java内存模型](https://blog.csdn.net/qq_40722284/article/details/80456948)

​	由于Java语言是多线程的，多个线程可能在同一时间尝试去初始化同一个类或接口（比如这里多个线程可能在同一时刻调用getInstance()方法来初始化InstanceHolder类）。因此，在Java中初始化一个类或者接口时，需要做细致的同步处理。

​	**Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了**（事实上，Java语言规范允许JVM的具体实现在这里做一些优化，见后文的说明）。

​	对于类或接口的初始化，Java语言规范制定了精巧而复杂的类初始化处理过程。Java初始化一个类或接口的处理过程如下（这里对类初始化处理过程的说明，省略了与本文无关的部分；同时为了更好的说明类初始化过程中的同步处理机制，笔者{该书的作者}人为的把类初始化的处理过程分为了5个阶段）。

1. 第1阶段：通过在Class对象上同步（**即获取Class对象的初始化锁**），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。

   假设Class对象当前还没有被初始化（初始化状态state，此时被标记为state=noInitialization），且有两个线程A和B试图同时初始化这个Class对象。下图是对应的示意图。

   ![](https://upload-images.jianshu.io/upload_images/13068256-4bc58dd2204953c2.png)

   下表是这个示意图的说明

   | 时间 | 线程 A                                                       | 线程 B                                                       |
   | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | t1   | A1: 尝试获取 Class 对象的初始化锁。这里假设线程 A 获取到了初始化锁 | B1: 尝试获取 Class 对象的初始化锁，由于线程 A 获取到了锁，线程 B 将一直等待获取初始化锁 |
   | t2   | A2：线程 A 看到线程还未被初始化（因为读取到 state == noInitialization），线程设置 state = initializing |                                                              |
   | t3   | A3：线程 A 释放初始化锁                                      |                                                              |

2. 第2阶段：**线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待**。

   ![](https://upload-images.jianshu.io/upload_images/13068256-6df23f4851f035b0.png)

   | 时间 | 线程 A                                           | 线程 B                            |
   | ---- | ------------------------------------------------ | --------------------------------- |
   | t1   | A1: 执行类的静态初始化和初始化类中声明的静态字段 | B1：获取到初始化锁                |
   | t2   |                                                  | B2：读取到 state == initializing  |
   | t3   |                                                  | B3：释放初始化锁                  |
   | t4   |                                                  | B4：在初始化锁的 condition 中等待 |

3. 第3阶段：**线程A设置state=initialized，然后唤醒在condition中等待的所有线程**。

   ![](https://upload-images.jianshu.io/upload_images/13068256-f959f9a4868c8638.png)

   | 时间 | 线程A                                 |
   | ---- | ------------------------------------- |
   | t1   | A1：获取初始化锁                      |
   | t2   | A2：设置 state = initialized          |
   | t3   | A3：唤醒在 condition 中等待的所有线程 |
   | t4   | A4：释放初始化锁                      |
   | t5   | A5：线程 A 的初始化处理过程完成       |

4. 第4阶段：线程B结束类的初始化处理。

   ![](https://upload-images.jianshu.io/upload_images/13068256-d39e3329794df235.png)

   | 时间 | 线程 B                            |
   | ---- | --------------------------------- |
   | t1   | B1：获取初始化锁                  |
   | t2   | B2：读取到 state == initialized   |
   | t3   | B3：释放初始化锁                  |
   | t4   | B4：线程 B 的类初始化处理过程完成 |

   ​	线程 A 在第二阶段的 A1 执行类的初始化，并在第三阶段的 A4 释放初始化锁；线程 B 在第四阶段的 B1 获取同一个初始化锁，并在第四阶段的 B4 之后才开始访问这个类。根据 java 内存模型规范的锁规则，这里将存在如下的 happens-before 关系：

   ![](https://upload-images.jianshu.io/upload_images/13068256-cf9463ea4c15c6f1.png)

   ​	这个 happens-before 关系将保证：线程 A 执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程 B 一定能看到。

5. 第5阶段：线程C执行类的初始化的处理。

   ![](https://upload-images.jianshu.io/upload_images/13068256-ae56d528dd2bf57a.png)

   | 时间 | 线程 C                            |
   | ---- | --------------------------------- |
   | t1   | C1：获取初始化锁                  |
   | t2   | C2：读取到 state == initialized   |
   | t3   | C3：释放初始化锁                  |
   | t4   | C4：线程 C 的类初始化处理过程完成 |

   ​	在第3阶段之后，类已经完成了初始化。因此线程C在第5阶段的类初始化处理过程相对简单一些（前面的线程A和B的类初始化处理过程都经历了两次锁获取-锁释放，而线程C的类初始化处理只需要经历一次锁获取-锁释放）。

   ​	线程A在第2阶段的A1执行类的初始化，并在第3阶段的A4释放锁；线程C在第5阶段的C1获取同一个锁，并在在第5阶段的C4之后才开始访问这个类。根据Java内存模型规范的锁规则，将存在如下的happens-before关系。

   ![img](https://img-blog.csdn.net/20180526205054128?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzIyMjg0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   ​	这个 happens-before 关系将保证：线程A执行类的初始化时的写入操作，线程C一定能看到。

​	*注 1：这里的 condition 和 state 标记是本文虚构出来的。Java 语言规范并没有硬性规定一定要使用 condition 和 state 标记。JVM 的具体实现只要实现类似功能即可。*

​	*注 2：Java 语言规范允许 Java 的具体实现，优化类的初始化处理过程（对这里的第五阶段做优化），具体细节参见 java 语言规范的 12.4.2 章。*

​	通过对比**基于 volatile 的双重检查锁定**的方案和**基于类初始化**的方案，我们会发现基**于类初始化的方案的实现代码更简洁**。但**基于 volatile 的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。**

​	**字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。**

## 3.9 Java内存模型综述

​	前面对Java内存模型的基础知识和内存模型的具体实现进行了说明。下面对Java内存模型的相关知识做一个总结。

### 3.9.1 处理器的内存模型

​	顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。

​	根据对不同类型的读/写操作组合的执行顺序的放松，可以把**常见处理器的内存模型**划分为如下几种类型。

+ 放松程序中**写-读**操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。

+ 在上面的基础上，继续放松程序中**写-写**操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。

+ 在前面两条的基础上，继续放松程序中**读-写**和**读-读**操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。

​	注意，**这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）**。

​	下表展示了常见处理器内存模型的细节特征。

| 内存模型名称 | 对应的处理器 | Store-Load 重排序 | Store-Store重排序 | Load-Load 和Load-Store重排序 | 可以更早读取到其它处理器的写 | 可以更早读取到当前处理器的写 |
| ------------ | ------------ | ----------------- | ----------------- | ---------------------------- | ---------------------------- | ---------------------------- |
| TSO          | sparc-TSOX64 | Y                 |                   |                              |                              | Y                            |
| PSO          | sparc-PSO    | Y                 | Y                 |                              |                              | Y                            |
| RMO          | ia64         | Y                 | Y                 | Y                            |                              | Y                            |
| PowerPC      | PowerPC      | Y                 | Y                 | Y                            | Y                            | Y                            |

​	从上表中可以看到，**所有处理器内存模型都允许写-读重排序**，原因在第1章已经说明过：它们都使用了写缓存区。**写缓存区可能导致写-读操作重排序。**同时，我们可以看到这些处理器内存模型**都允许更早读到当前处理器的写，原因同样是因为写缓存区**。**由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。**

​	上表中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计得会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。

​	由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，<u>由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同</u>。图3展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图。

​	**JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型**。

![img](https://upload-images.jianshu.io/upload_images/13068256-1ca4866677d9b37b.png)

### 3.9.2 各种内存模型之间的关系

> [并发编程的艺术--第三章：Java内存模型](https://blog.csdn.net/qq_40722284/article/details/80456948)

​	**JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型**，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型、处理器内存模型和顺序一致性内存模型的强弱对比示意图。

​	从图中可以看出：常见的4种处理器内存模型比常用的3种语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，**越是追求执行性能的语言，内存模型设计得会越弱**。

![img](https://img-blog.csdn.net/20180526210038867?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzIyMjg0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 3.9.3 JMM的内存可见性保证

​	按程序类型，Java程序的内存可见性保证可以分为下列3类。

+ **单线程程序**。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。

+ **正确同步的多线程程序**。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。

+ **未同步/未正确同步的多线程程序**。<u>JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）</u>。

​	注意，**最小安全性保障与64位数据的非原子性写并不矛盾**。它们是两个不同的概念，它们“发生”的时间点也不同。**最小安全性保证对象默认初始化之后（设置成员域为0、null或false），才会被任意线程使用。最小安全性“发生”在对象被任意线程使用之前**。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。当发生问题时（处理器B看到仅仅被处理器A“写了一半”的无效值），这里虽然处理器B读取到一个被写了一半的无效值，但这个值仍然是处理器A写入的，只不过是处理器A还没有写完而已。**最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）**。<u>但最小安全性并不保证线程读取到的值，一定是某个线程写完后的值。最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。</u>

​	下图展示了这3类程序在JMM中与在顺序一致性内存模型中的执行结果的异同。

![img](https://img-blog.csdn.net/20180526210620451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzIyMjg0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	**只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。**

> 3.3.4 未同步程序的执行特性（摘录）
>
> **在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写操作具有原子性。当JVM在这种处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。**
>
> 注意，在JSR-133之前的旧内存模型中，一个64位long/double型变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，**任意的读操作在JSR-133中都必须具有原子性（即任意读操作必须要在单个读事务中执行）。**

### 3.9.4 JSR-133对旧内存模型的修补

​	**JSR-133对JDK 5之前的旧内存模型的修补主要有两个**。

+ **增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。**

+ **增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。**

```pseudocode
## 个人总结
## volatile读(防止volatile读和后面的普通读/volatile写/普通写重排序)

volatile读
LoadLoad
LoadStore

## volatile写(防止volatile和前面的普通写/volatile写/后续的普通读/volatile读重排序)

StoreStore
volatile写
StoreLoad

## happens-before中就有强调，volatile写一定先于同一个字段的volatile读

## final主要保证 final的写一定不会被重排序到构造函数外，再者final的写一定先于final被读取/被使用/被赋值给对象引用。
## final读()

LoadLoad
final

## final写

final
StoreStore
```

## 3.10 本章小结

​	本章对Java内存模型做了比较全面的解读。希望读者阅读本章之后，对Java内存模型能够有一个比较深入的了解；同时，也希望本章可帮助读者解决在Java并发编程中经常遇到的各种内存可见性问题。

# 第4章 Java并发编程基础

​	Java从诞生开始就明智地选择了内置对多线程的支持，这使得Java语言相比同一时期的其他语言具有明显的优势。线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。但是，过多地创建线程和对线程的不当管理也容易造成问题。本章将着重介绍Java并发编程的基础知识，从启动一个线程到线程间不同的通信方式，最后通过简单的线程池示例以及应用（简单的Web服务器）来串联本章所介绍的内容。

## 4.1 线程简介

### 4.1.1 什么是线程

​	现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫**轻量级进程（LightWeight Process）**，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。

​	一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。下面使用JMX来查看一个普通的Java程序包含哪些线程，代码清单(MultiThread.java)所示。

```java
public class MultiThread{
  public static void main(String[] args) {
    // 获取Java线程管理MXBean
    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    // 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息
    ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
    // 遍历线程信息，仅打印线程ID和线程名称信息
    for (ThreadInfo threadInfo : threadInfos) {
      System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.
                         getThreadName());
    }
  }
}
```

​	输出如下所示（输出内容可能不同）。

```none
[4] Signal Dispatcher　 // 分发处理发送给JVM信号的线程
[3] Finalizer　　　　 // 调用对象finalize方法的线程
[2] Reference Handler // 清除Reference的线程
[1] main　 　　　　 // main线程，用户程序入口
```

​	可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线程的同时运行。

> 这些在操作系统的笔记里有更理论的概念，同时也有Linux线程的概述

### 4.1.2 为什么要使用多线程

​	执行一个简单的“Hello,World!”，却启动了那么多的“无关”线程，是不是把简单的问题复杂化了？当然不是，因为正确使用多线程，总是能够给开发人员带来显著的好处，而使用多线程的原因主要有以下几点。

1. 更多的处理器核心

   ​	随着处理器上的核心数量越来越多，以及超线程技术的广泛运用，现在大多数计算机都比以往更加擅长并行计算，而处理器性能的提升方式，也从更高的主频向更多的核心发展。如何利用好处理器上的多个核心也成了现在的主要问题。

   ​	线程是大多数操作系统调度的基本单元，一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。

2. 更快的响应时间

   ​	有时我们会编写一些较为复杂的代码（这里的复杂不是说复杂的算法，而是复杂的业务逻辑），例如，一笔订单的创建，它包括插入订单数据、生成订单快照、发送邮件通知卖家和记录货品销售数量等。用户从单击“订购”按钮开始，就要等待这些操作全部完成才能看到订购成功的结果。但是这么多业务操作，如何能够让其更快地完成呢？

   ​	在上面的场景中，可以**使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列）**，如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。

3. 更好的编程模型

   ​	Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将其多线程化。一旦开发人员建立好了模型，稍做修改总是能够方便地映射到Java提供的多线程编程模型上。

### 4.1.3 线程优先级

​	现代操作系统基本采用**时分**的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。**线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性**。

​	在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。**设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占**。<u>在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定</u>，示例如代码清单(Priority.java)所示。

```java
package chapter04;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * 6-2
 */
public class Priority {
  private static volatile boolean notStart = true;
  private static volatile boolean notEnd   = true;

  public static void main(String[] args) throws Exception {
    List<Job> jobs = new ArrayList<Job>();
    for (int i = 0; i < 10; i++) {
      int priority = i < 5 ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;
      Job job = new Job(priority);
      jobs.add(job);
      Thread thread = new Thread(job, "Thread:" + i);
      thread.setPriority(priority);
      thread.start();
    }
    notStart = false;
    Thread.currentThread().setPriority(8);
    System.out.println("done.");
    TimeUnit.SECONDS.sleep(10);
    notEnd = false;

    for (Job job : jobs) {
      System.out.println("Job Priority : " + job.priority + ", Count : " + job.jobCount);
    }

  }

  static class Job implements Runnable {
    private int  priority;
    private long jobCount;

    public Job(int priority) {
      this.priority = priority;
    }

    public void run() {
      while (notStart) {
        Thread.yield();
      }
      while (notEnd) {
        Thread.yield();
        jobCount++;
      }
    }
  }
}
```

运行该示例，在该书作者机器上对应的输出如下。

```none
Job Priority : 1, Count : 1259592
Job Priority : 1, Count : 1260717
Job Priority : 1, Count : 1264510
Job Priority : 1, Count : 1251897
Job Priority : 1, Count : 1264060
Job Priority : 10, Count : 1256938
Job Priority : 10, Count : 1267663
Job Priority : 10, Count : 1260637
Job Priority : 10, Count : 1261705
Job Priority : 10, Count : 1259967
```

​	从输出可以看到线程优先级没有生效，优先级1和优先级10的Job计数的结果非常相近，没有明显差距。这表示**程序正确性不能依赖线程的优先级高低**。

​	*注意：**线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定**。笔者的环境为：Mac OS X 10.10，Java版本为1.7.0_71，经过笔者验证该环境下所有Java线程优先级均为5（通过jstack查看），对线程优先级的设置会被忽略。另外，尝试在Ubuntu 14.04环境下运行该示例，输出结果也表示该环境忽略了线程优先级的设置。*

### 4.1.4 线程的状态

> [Java中线程的状态](https://blog.csdn.net/zbw18297786698/article/details/53432587)

​	Java线程在运行的生命周期中可能处于下表所示的**6种不同的状态**，在给定的一个时刻，线程只能处于其中的一个状态。

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建，但是还没有调用start()方法              |
| RUNNABLE     | 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作"运行中" |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断） |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的 |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |

​	下面我们使用jstack工具（可以选择打开终端，键入jstack或者到JDK安装目录的bin目录下执行命令），尝试查看示例代码运行时的线程信息，更加深入地理解线程状态，示例如代码清单（ThreadState.java）所示。

```java
public class ThreadState {
  public static void main(String[] args) {
    new Thread(new TimeWaiting (), "TimeWaitingThread").start();
    new Thread(new Waiting(), "WaitingThread").start();
    // 使用两个Blocked线程，一个获取锁成功，另一个被阻塞
    new Thread(new Blocked(), "BlockedThread-1").start();
    new Thread(new Blocked(), "BlockedThread-2").start();
  }
  // 该线程不断地进行睡眠
  static class TimeWaiting implements Runnable {
    @Override
    public void run() {
      while (true) {
        SleepUtils.second(100);
      }
    }
  }
  // 该线程在Waiting.class实例上等待
  static class Waiting implements Runnable {
    @Override
    public void run() {
      while (true) {
        synchronized (Waiting.class) {
          try {
            Waiting.class.wait();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  // 该线程在Blocked.class实例上加锁后，不会释放该锁
  static class Blocked implements Runnable {
    public void run() {
      synchronized (Blocked.class) {
        while (true) {
          SleepUtils.second(100);
        }
      }
    }
  }
}
```

上述示例中使用的SleepUtils如（代码清单4-4 SleepUtils.java）所示

```java
public class SleepUtils {
  public static final void second(long seconds) {
    try {
      TimeUnit.SECONDS.sleep(seconds);
    } catch (InterruptedException e) {
    }
  }
}
```

运行该示例，打开终端或者命令提示符，键入“jps”，输出如下。

```shell
611
935 Jps
929 ThreadState
270
```

​	可以看到运行示例对应的进程ID是929，接着再键入“jstack 929”（这里的进程ID需要和读者自己键入jps得出的ID一致），部分输出如下所示。

```shell
// BlockedThread-2线程阻塞在获取Blocked.class示例的锁上
"BlockedThread-2" prio=5 tid=0x00007feacb05d000 nid=0x5d03 waiting for monitor
entry [0x000000010fd58000]
java.lang.Thread.State: BLOCKED (on object monitor)
// BlockedThread-1线程获取到了Blocked.class的锁
"BlockedThread-1" prio=5 tid=0x00007feacb05a000 nid=0x5b03 waiting on condition
[0x000000010fc55000]
java.lang.Thread.State: TIMED_WAITING (sleeping)
// WaitingThread线程在Waiting实例上等待
"WaitingThread" prio=5 tid=0x00007feacb059800 nid=0x5903 in Object.wait()
[0x000000010fb52000]
java.lang.Thread.State: WAITING (on object monitor)
// TimeWaitingThread线程处于超时等待
"TimeWaitingThread" prio=5 tid=0x00007feacb058800 nid=0x5703 waiting on condition
[0x000000010fa4f000]
java.lang.Thread.State: TIMED_WAITING (sleeping)
```

​	通过示例，我们了解到Java程序运行中线程状态的具体含义。线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如下图示。

![img](https://img-blog.csdn.net/20161202111003477)

​	由图中可以看到，线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。

​	*注意：**Java将操作系统中的运行和就绪两个状态合并称为运行状态**。阻塞状态是线程阻塞在进入`synchronized`关键字修饰的方法或代码块（获取锁）时的状态，但是**阻塞在`java.concurrent`包中Lock接口的线程状态却是等待状态，因为`java.concurrent`包中Lock接口对于阻塞的实现均使用了`LockSupport`类中的相关方法**。*	

### 4.1.5 Daemon线程

​	Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，**当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出**。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。

​	*注意：Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。*

​	**Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行**，示例如（代码清单4-5 Daemon.java）所示。

```java
public class Daemon {
  public static void main(String[] args) {
    Thread thread = new Thread(new DaemonRunner(), "DaemonRunner");
    thread.setDaemon(true);
    thread.start();
  }
  static class DaemonRunner implements Runnable {
    @Override
    public void run() {
      try {
        SleepUtils.second(10);
      } finally {
        System.out.println("DaemonThread finally run.");
      }
    }
  }
}
```

​	运行Daemon程序，可以看到在终端或者命令提示符上没有任何输出。main线程（非Daemon线程）在启动了线程DaemonRunner之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没有执行。

​	*注意：**在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。***

(要是直接kill父进程main，会发现这个Daemon变成僵尸进程，被INIT进程接管，被INIT接管后几秒之后该线程就被终结了，INIT进程号为1。亲测)

## 4.2 启动和终止线程

​	在前面章节的示例中通过调用线程的start()方法进行启动，随着run()方法的执行完毕，线程也随之终止，大家对此一定不会陌生，下面将详细介绍线程的启动和终止。

### 4.2.1 构造线程

​	在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。(代码清单4-6 Thread.java)所示的代码摘自`java.lang.Thread`中对线程进行初始化的部分。

```java
private void init(ThreadGroup g, Runnable target, String name,long stackSize,
                  AccessControlContext acc) {
  if (name == null) {
    throw new NullPointerException("name cannot be null");
  }
  // 当前线程就是该线程的父线程
  Thread parent = currentThread();
  this.group = g;
  // 将daemon、priority属性设置为父线程的对应属性
  this.daemon = parent.isDaemon();
  this.priority = parent.getPriority();
  this.name = name.toCharArray();
  this.target = target;
  setPriority(priority);
  // 将父线程的InheritableThreadLocal复制过来
  if (parent.inheritableThreadLocals != null)
    this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.
                                                                inheritableThreadLocals);
  // 分配一个线程ID
  tid = nextThreadID();
}
```

​	在上述过程中，<u>**一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行**。</u>

### 4.2.2 启动线程

​	线程对象在初始化完成之后，调用start()方法就可以启动这个线程。<u>线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要**线程规划器**空闲，应立即启动调用start()方法的线程</u>。

​	***注意：启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。***

### 4.2.3 理解中断

​	中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。

​	线程通过检查自身是否被中断来进行响应，线程通过方法`isInterrupted()`来进行判断是否被中断，也可以调用静态方法`Thread.interrupted()`对当前线程的中断标识位进行复位。**如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的`isInterrupted()`时依旧会返回false**。

​	<u>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如`Thread.sleep(longmillis)`方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</u>

​	在（代码清单4-7 Interrupted.java）所示的例子中，首先创建了两个线程，SleepThread和BusyThread，前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。

```java
public class Interrupted {
  public static void main(String[] args) throws Exception {
    // sleepThread不停的尝试睡眠
    Thread sleepThread = new Thread(new SleepRunner(), "SleepThread");
    sleepThread.setDaemon(true);
    // busyThread不停的运行
    Thread busyThread = new Thread(new BusyRunner(), "BusyThread");
    busyThread.setDaemon(true);
    sleepThread.start();
    busyThread.start();
    // 休眠5秒，让sleepThread和busyThread充分运行
    TimeUnit.SECONDS.sleep(5);
    sleepThread.interrupt();
    busyThread.interrupt();
    System.out.println("SleepThread interrupted is " + sleepThread.isInterrupted());
    System.out.println("BusyThread interrupted is " + busyThread.isInterrupted());
    // 防止sleepThread和busyThread立刻退出
    SleepUtils.second(2);
  }
  static class SleepRunner implements Runnable {
    @Override
    public void run() {
      while (true) {
        SleepUtils.second(10);
      }
    }
  }
  static class BusyRunner implements Runnable {
    @Override
    public void run() {
      while (true) {
      }
    }
  }
}
```

输出如下：

```none
SleepThread interrupted is false
BusyThread interrupted is true
```

​	从结果可以看出，抛出InterruptedException的线程SleepThread，其中断标识位被清除了，而一直忙碌运作的线程BusyThread，中断标识位没有被清除。

### 4.2.4 过期的suspend()、resume()和stop()

​	大家对于CD机肯定不会陌生，如果把它播放音乐比作一个线程的运作，那么对音乐播放做出的暂停、恢复和停止操作对应在线程Thread的API就是`suspend()`、`resume()`和`stop()`。

​	在（代码清单4-8 Deprecated.java）所示的例子中，创建了一个线程PrintThread，它以1秒的频率进行打印，而主线程对其进行暂停、恢复和停止操作。

```java
public class Deprecated {
  public static void main(String[] args) throws Exception {
    DateFormat format = new SimpleDateFormat("HH:mm:ss");
    Thread printThread = new Thread(new Runner(), "PrintThread");
    printThread.setDaemon(true);
    printThread.start();
    TimeUnit.SECONDS.sleep(3);
    // 将PrintThread进行暂停，输出内容工作停止
    printThread.suspend();
    System.out.println("main suspend PrintThread at " + format.format(new Date()));
    TimeUnit.SECONDS.sleep(3);
    // 将PrintThread进行恢复，输出内容继续
    printThread.resume();
    System.out.println("main resume PrintThread at " + format.format(new Date()));
    TimeUnit.SECONDS.sleep(3);
    // 将PrintThread进行终止，输出内容停止
    printThread.stop();
    System.out.println("main stop PrintThread at " + format.format(new Date()));
    TimeUnit.SECONDS.sleep(3);
  }
  static class Runner implements Runnable {
    @Override
    public void run() {
      DateFormat format = new SimpleDateFormat("HH:mm:ss");
      while (true) {
        System.out.println(Thread.currentThread().getName() + " Run at " +
                           format.format(new Date()));
        SleepUtils.second(1);
      }
    }
  }
}
```

​	输出如下（输出内容中的时间与示例执行的具体时间相关）。

```none
PrintThread Run at 17:34:36
PrintThread Run at 17:34:37
PrintThread Run at 17:34:38
main suspend PrintThread at 17:34:39
main resume PrintThread at 17:34:42
PrintThread Run at 17:34:42
PrintThread Run at 17:34:43
PrintThread Run at 17:34:44
main stop PrintThread at 17:34:45
```

​	在执行过程中，PrintThread运行了3秒，随后被暂停，3秒后恢复，最后经过3秒被终止。

​	通过示例的输出可以看到，suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是**不建议使用**的。

​	不建议使用的原因主要有：以**suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题**。同样，**stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。**

​	*注意：正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而暂停和恢复操作可以用后面提到的等待/通知机制来替代。*

### 4.2.5 安全地终止线程

​	在4.2.3节中提到的中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。

​	在（代码清单4-9 Shutdown.java）所示的例子中，创建了一个线程CountThread，它不断地进行变量累加，而主线程尝试对其进行中断操作和停止操作。

```java
public class Shutdown {
  public static void main(String[] args) throws Exception {
    Runner one = new Runner();
    Thread countThread = new Thread(one, "CountThread");
    countThread.start();
    // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束
    TimeUnit.SECONDS.sleep(1);
    countThread.interrupt();
    Runner two = new Runner();
    countThread = new Thread(two, "CountThread");
    countThread.start();
    // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束
    TimeUnit.SECONDS.sleep(1);
    two.cancel();
  }
  private static class Runner implements Runnable {
    private long i;
    private volatile boolean on = true;
    @Override
    public void run() {
      while (on && !Thread.currentThread().isInterrupted()){
        i++;
      }
      System.out.println("Count i = " + i);
    }
    public void cancel() {
      on = false;
    }
  }
}
```

​	输出结果如下所示（输出内容可能不同）。

```none
Count i = 543487324
Count i = 540898082
```

​	示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。**这种通过标识位或者中断操作的方式能够使线程在终止时有机会去<u>清理资源</u>，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅**。

## 4.3 线程间通信

​	线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，这将会带来巨大的价值。

### 4.3.1 volatile和synchronized关键字

> [四、Java线程间通信](https://www.jianshu.com/p/2a2ced84a637)

​	Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。

​	**关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性**。
​	举个例子，定义一个表示程序是否运行的成员变量`boolean on=true`，那么另一个线程可能对它执行关闭动作（on=false），这里涉及多个线程对变量的访问，因此需要将其定义成为`volatile boolean on＝true`，这样其他线程对它进行改变时，可以让所有线程感知到变化，因为所有对on变量的访问和修改都需要以共享内存为准。但是，过多地使用volatile是不必要的，因为它会降低程序执行的效率。

​	**关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。**

​	在（代码清单4-10 Synchronized.java）所示的例子中，使用了同步块和同步方法，通过使用javap工具查看生成的class文件信息来分析synchronized关键字的实现细节，示例如下。

```java
public class Synchronized {
  public static void main(String[] args) {
    // 对Synchronized Class对象进行加锁
    synchronized (Synchronized.class) {
    }
    // 静态同步方法，对Synchronized Class对象进行加锁
    m();
  }
  public static synchronized void m() {
  }
}
```

在Synchronized.class同级目录执行`javap–v Synchronized.class`，部分相关输出如下所示：

```none
public static void main(java.lang.String[]);
// 方法修饰符，表示：public staticflags: ACC_PUBLIC, ACC_STATIC
Code:
stack=2, locals=1, args_size=1
0: ldc #1　　// class com/murdock/books/multithread/book/Synchronized
2: dup
3: monitorenter　　// monitorenter：监视器进入，获取锁
4: monitorexit　　 // monitorexit：监视器退出，释放锁
5: invokestatic　　#16 // Method m:()V
8: return
public static synchronized void m();
// 方法修饰符，表示： public static synchronized
flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
Code:
stack=0, locals=0, args_size=0
0: return
```

​	上面class信息中，**对于同步块的实现使用了monitorenter和monitorexit指令**，而**同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成**的。无论采用哪种方式，其**本质是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器**。

​	**任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。**

​	下图描述了对象、对象的监视器、同步队列和执行线程之间的关系。

![img](https://upload-images.jianshu.io/upload_images/7378149-d4edab35ac9cb0eb.png)



​	从上图可以看到，**任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取**。

### 4.3.2 等待/通知机制

> [四、Java线程间通信](https://www.jianshu.com/p/2a2ced84a637)

​	一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦，体系结构上具备了良好的伸缩性，但是在Java语言中如何实现类似的功能呢？

​	简单的办法是让消费者线程不断地循环检查变量是否符合预期，如下面代码所示，在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。

```java
while (value != desire) {
  Thread.sleep(1000);
} doSomething();
```

​	上面这段伪代码在条件不满足时就睡眠一段时间，这样做的目的是防止过快的“无效”尝试，这种方式看似能够解实现所需的功能，但是却存在如下问题。

1. **难以确保及时性**。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化，也就是及时性难以保证。

2. **难以降低开销**。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。

​	以上两个问题，看似矛盾难以调和，但是Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。

​	等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类`java.lang.Object`上，方法和描述如下表所示。

| 方法名称       | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| notify()       | 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获得到了对象的锁 |
| notifyAll()    | 通知所有等待在该对象上的线程                                 |
| wait()         | 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，**需要注意，调用wait()方法后，会释放对象的锁** |
| wait(long)     | 超过等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 |
| wait(long,int) | 对于超时时间更细粒度的控制，可以达到纳秒                     |

​	等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。

​	在（代码清单4-11 WaitNotify.java）所示的例子中，创建了两个线程——WaitThread和NotifyThread，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知，示例如下所示。

```java
public class WaitNotify {
  static boolean flag = true;
  static Object  lock = new Object();

  public static void main(String[] args) throws Exception {
    Thread waitThread = new Thread(new Wait(), "WaitThread");
    waitThread.start();
    TimeUnit.SECONDS.sleep(1);

    Thread notifyThread = new Thread(new Notify(), "NotifyThread");
    notifyThread.start();
  }

  static class Wait implements Runnable {
    public void run() {
      // 加锁，拥有lock的Monitor
      synchronized (lock) {
        // 当条件不满足时，继续wait，同时释放了lock的锁
        while (flag) {
          try {
            System.out.println(Thread.currentThread() + " flag is true. wait @ "
                               + new SimpleDateFormat("HH:mm:ss").format(new Date()));
            lock.wait();
          } catch (InterruptedException e) {
          }
        }
        // 条件满足时，完成工作
        System.out.println(Thread.currentThread() + " flag is false. running @ "
                           + new SimpleDateFormat("HH:mm:ss").format(new Date()));
      }
    }
  }

  static class Notify implements Runnable {
    public void run() {
      // 加锁，拥有lock的Monitor
      synchronized (lock) {
        // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，
        // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回
        System.out.println(Thread.currentThread() + " hold lock. notify @ " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        lock.notifyAll();
        flag = false;
        SleepUtils.second(5);
      }
      // 再次加锁
      synchronized (lock) {
        System.out.println(Thread.currentThread() + " hold lock again. sleep @ "
                           + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        SleepUtils.second(5);
      }
    }
  }
}
```

​	输出如下（输出内容可能不同，主要区别在时间上）。

```none
Thread[WaitThread,5,main] flag is true. wait @ 22:23:03
Thread[NotifyThread,5,main] hold lock. notify @ 22:23:04
Thread[NotifyThread,5,main] hold lock again. sleep @ 22:23:09
Thread[WaitThread,5,main] flag is false. running @ 22:23:14
```

​	上述第3行和第4行输出的顺序可能会互换，而上述例子主要说明了调用wait()、notify()以及notifyAll()时需要注意的细节，如下。

1. **使用wait()、notify()和notifyAll()时需要先对调用对象加锁**。

2. 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。

3. notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。

4. notify()方法将等待队列中的一个等待线程从**等待队列**中移到**同步队列**中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，**被移动的线程状态由WAITING变为BLOCKED**。

5. **从wait()方法返回的前提是获得了调用对象的锁**。

​	从上述细节中可以看到，**等待/通知机制依托于同步机制**，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。

![img](https://upload-images.jianshu.io/upload_images/7378149-df730838a3bb208f.png)

​	上图中，WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了锁并进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到**SynchronizedQueue**中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。

### 4.3.3 等待/通知的经典范式

​	从4.3.2节中的WaitNotify示例中可以提炼出<u>等待/通知的经典范式</u>，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。

​	等待方遵循如下原则。

1. 获取对象的锁。

2. 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。

3. 条件满足则执行对应的逻辑。

```pseudocode
synchronized(对象) {
	while(条件不满足) {
		对象.wait();
	}
	对应的处理逻辑
}
```

​	通知方遵循如下原则。

1. 获得对象的锁。

2. 改变条件。

3. 通知所有等待在对象上的线程。

​	对应的伪代码如下。

```pseudocode
synchronized(对象) {
	改变条件
	对象.notifyAll();
}
```

### 4.3.4 管理输入/输出流

​	**管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存**。

​	管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。

​	在（代码清单4-12 Piped.java）所示的例子中，创建了printThread，它用来接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。

```java
public class Piped {
  public static void main(String[] args) throws Exception {
    PipedWriter out = new PipedWriter();
    PipedReader in = new PipedReader();
    // 将输出流和输入流进行连接，否则在使用时会抛出IOException
    out.connect(in);
    Thread printThread = new Thread(new Print(in), "PrintThread");
    printThread.start();
    int receive = 0;
    try {
      while ((receive = System.in.read()) != -1) {
        out.write(receive);
      }
    } finally {
      out.close();
    }
  }
  static class Print implements Runnable {
    private PipedReader in;
    public Print(PipedReader in) {
      this.in = in;
    }
    public void run() {
      int receive = 0;
      try {
        while ((receive = in.read()) != -1) {
          System.out.print((char) receive);
        }
      } catch (IOException ex) {
      }
    }
  }
}
```

​	运行该示例，输入一组字符串，可以看到被printThread进行了原样输出。

```none
Repeat my words.
Repeat my words.
```

​	对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。

### 4.3.5 Thread.join()的使用

​	如果一个线程A执行了**thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回**。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(longmillis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。

​	在（代码清单4-13 Join.java）所示的例子中，创建了10个线程，编号0~9，每个线程调用前一个线程的join()方法，也就是线程0结束了，线程1才能从join()方法中返回，而线程0需要等待main线程结束。

```java
public class Join {
  public static void main(String[] args) throws Exception {
    Thread previous = Thread.currentThread();
    for (int i = 0; i < 10; i++) {
      // 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回
      Thread thread = new Thread(new Domino(previous), String.valueOf(i));
      thread.start();
      previous = thread;
    }
    TimeUnit.SECONDS.sleep(5);
    System.out.println(Thread.currentThread().getName() + " terminate.");
  }
  static class Domino implements Runnable {
    private Thread thread;
    public Domino(Thread thread) {
      this.thread = thread;
    }
    public void run() {
      try {
        thread.join();
      } catch (InterruptedException e) {
      }
      System.out.println(Thread.currentThread().getName() + " terminate.");
    }
  }
}
```

​	输出如下。

```none
main terminate.
0 terminate.
1 terminate.
2 terminate.
3 terminate.
4 terminate.
5 terminate.
6 terminate.
7 terminate.
8 terminate.
9 terminate.
```

​	从上述输出可以看到，每个线程终止的前提是前驱线程的终止，每个线程等待前驱线程终止后，才从join()方法返回，这里涉及了等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。

​	代码清单4-14是JDK中Thread.join()方法的源码（进行了部分调整）。

```java
// 加锁当前线程对象
public final synchronized void join() throws InterruptedException {
  // 条件不满足，继续等待
  while (isAlive()) {
    wait(0);
  }
  // 条件符合，方法返回
}
```

​	当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。可以看到join()方法的逻辑结构与4.3.3节中描述的**等待/通知经典范式**一致，即**加锁、循环和处理逻辑3个步骤**。

### 4.3.6 ThreadLocal的使用

​	**ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构**。这个结构被附带在线程上，也就是说**一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值**。

​	可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。

​	在（代码清单4-15 Profiler.java）所示的例子中，构建了一个常用的Profiler类，它具有begin()和end()两个方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。

```java
public class Profiler {
  // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次
  private static final ThreadLocal<Long> TIME_THREADLOCAL = new ThreadLocal<Long>() {
    protected Long initialValue() {
      return System.currentTimeMillis();
    }
  };
  public static final void begin() {
    TIME_THREADLOCAL.set(System.currentTimeMillis());
  }
  public static final long end() {
    return System.currentTimeMillis() - TIME_THREADLOCAL.get();
  }
  public static void main(String[] args) throws Exception {
    Profiler.begin();
    TimeUnit.SECONDS.sleep(1);
    System.out.println("Cost: " + Profiler.end() + " mills");
  }
}
```

​	输出结果如下所示。

```java
Cost: 1001 mills
```

​	Profiler可以被复用在方法调用耗时统计的功能上，<u>在方法的入口前执行begin()方法，在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中，比如在AOP（面向方面编程）中，可以在方法调用前的切入点执行begin()方法，而在方法调用后的切入点执行end()方法，这样依旧可以获得方法的执行耗时</u>。

## 4.4 线程应用简介

### 4.4.1 等待超时模式

​	开发人员经常会遇到这样的方法调用场景：调用一个方法时等待一段时间（一般来说是给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。

​	前面的章节介绍了**等待/通知的经典范式，即加锁、条件循环和处理逻辑3个步骤**，而这种范式无法做到超时等待。而超时等待的加入，只需要对经典范式做出非常小的改动，改动内容如下所示。

​	假设超时时间段是T，那么可以推断出在当前时间now+T之后就会超时。

​	定义如下变量。

+ 等待持续时间：REMAINING=T。

+ 超时时间：FUTURE=now+T。

​	**这时仅需要wait(REMAINING)即可，在wait(REMAINING)返回之后会将执行：REMAINING=FUTURE–now。如果REMAINING小于等于0，表示已经超时，直接退出，否则将继续执行wait(REMAINING)。**

​	上述描述等待超时模式的伪代码如下。

```java
// 对当前对象加锁
public synchronized Object get(long mills) throws InterruptedException {
  long future = System.currentTimeMillis() + mills;
  long remaining = mills;
  // 当超时大于0并且result返回值不满足要求
  while ((result == null) && remaining > 0) {
    wait(remaining);
    remaining = future - System.currentTimeMillis();
  }
  return result;
}
```

​	可以看出，等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。

### 4.4.2 一个简单的数据库连接池示例

> [Java并发编程（五）Java并发编程基础](https://blog.csdn.net/weixin_41835916/article/details/80755980)

​	我们使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。

​	首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示例如（代码清单4-16 ConnectionPool.java）所示。

```java
public class ConnectionPool {
  private LinkedList<Connection> pool = new LinkedList<Connection>();
  public ConnectionPool(int initialSize) {
    if (initialSize > 0) {
      for (int i = 0; i < initialSize; i++) {
        pool.addLast(ConnectionDriver.createConnection());
      }
    }
  }
  public void releaseConnection(Connection connection) {
    if (connection != null) {
      synchronized (pool) {
        // 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接
        pool.addLast(connection);
        pool.notifyAll();
      }
    }
  }
  // 在mills内无法获取到连接，将会返回null
  public Connection fetchConnection(long mills) throws InterruptedException {
    synchronized (pool) {
      // 完全超时
      if (mills <= 0) {
        while (pool.isEmpty()) {
          pool.wait();
        }
        return pool.removeFirst();
      } else {
        long future = System.currentTimeMillis() + mills;
        long remaining = mills;
        while (pool.isEmpty() && remaining > 0) {
          pool.wait(remaining);
          remaining = future - System.currentTimeMillis();
        }
        Connection result = null;
        if (!pool.isEmpty()) {
          result = pool.removeFirst();
        }
        return result;
      }
    }
  }
}
```

​	由于java.sql.Connection是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过动态代理构造了一个Connection，该Connection的代理实现仅仅是在commit()方法调用时休眠100毫秒，示例如（代码清单4-17 ConnectionDriver.java）所示。

```java
public class ConnectionDriver {
  static class ConnectionHandler implements InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      if (method.getName().equals("commit")) {
        TimeUnit.MILLISECONDS.sleep(100);
      }
      return null;
    }
  }

  // 创建一个Connection的代理，在commit时休眠1秒
  public static final Connection createConnection() {
    return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(), new Class<?>[] { Connection.class },
                                               new ConnectionHandler());
  }
}
```

​	下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner获取、使用、最后释放连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如（代码清单4-18 ConnectionPoolTest.java）所示。

```java
public class ConnectionPoolTest {
  static ConnectionPool pool = new ConnectionPool(10);
  // 保证所有ConnectionRunner能够同时开始
  static CountDownLatch start = new CountDownLatch(1);
  // main线程将会等待所有ConnectionRunner结束后才能继续执行
  static CountDownLatch end;
  public static void main(String[] args) throws Exception {
    // 线程数量，可以修改线程数量进行观察
    int threadCount = 10;
    end = new CountDownLatch(threadCount);
    int count = 20;
    AtomicInteger got = new AtomicInteger();
    AtomicInteger notGot = new AtomicInteger();
    for (int i = 0; i < threadCount; i++) {
      Thread thread = new Thread(new ConnetionRunner(count, got, notGot),
                                 "ConnectionRunnerThread");
      thread.start();
    }
    start.countDown();
    end.await();
    System.out.println("total invoke: " + (threadCount * count));
    System.out.println("got connection: " + got);
    System.out.println("not got connection " + notGot);
  }
  static class ConnetionRunner implements Runnable {
    int count;
    AtomicInteger got;
    AtomicInteger notGot;
    public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) {
      this.count = count;
      this.got = got;
      this.notGot = notGot;
    }
    public void run() {
      try {
        start.await();
      } catch (Exception ex) {
      }
      while (count > 0) {
        try {
          // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null
          // 分别统计连接获取的数量got和未获取到的数量notGot
          Connection connection = pool.fetchConnection(1000);
          if (connection != null) {
            try {
              connection.createStatement();
              connection.commit();
            } finally {
              pool.releaseConnection(connection);
              got.incrementAndGet();
            }
          } else {
            notGot.incrementAndGet();
          }
        } catch (Exception ex) {
        } finally {
          count--;
        }
      }
      end.countDown();
    }
  }
}
```

​	上述示例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部结束之后，才使main线程从等待状态中返回。当前设定的场景是10个线程同时运行获取连接池（10个连接）中的连接，通过调节线程数量来观察未获取到连接的情况。线程数、总获取次数、获取到的数量、未获取到的数量以及未获取到的比率，如表4-3所示（书籍作者的机器CPU：i7-3635QM，内存为8GB，实际输出可能与此表不同）。

![这里写图片描述](https://img-blog.csdn.net/20180621153918867?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTgzNTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	从表中的数据统计可以看出，在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。虽然客户端线程在这种超时获取的模式下会出现连接无法获取的情况，但是它能够保证客户端线程不会一直挂在连接获取的操作上，而是“按时”返回，并告知客户端连接获取出现问题，是系统的一种自我保护机制。**数据库连接池的设计也可以复用到其他的资源获取的场景，针对昂贵资源（比如数据库连接）的获取都应该加以超时限制。**

### 4.4.3 线程池技术及其示例

​	对于服务端的程序，经常面对的是客户端传入的短小（执行时间短、工作内容较为单一）任务，需要服务端快速处理并返回结果。如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这在原型阶段是个不错的选择，但是面对成千上万的任务递交进服务器时，如果还是采用一个任务一个线程的方式，那么将会创建数以万记的线程，这不是一个好的选择。因为这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。

​	**线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。这样做的好处是，一方面，消除了频繁创建和消亡线程的系统资源开销，另一方面，面对过量任务的提交能够平缓的劣化**。

​	下面先看一个简单的线程池接口定义，示例如（代码清单4-19 ThreadPool.java）所示。

```java
public interface ThreadPool<Job extends Runnable> {
  // 执行一个Job，这个Job需要实现Runnable
  void execute(Job job);
  // 关闭线程池
  void shutdown();
  // 增加工作者线程
  void addWorkers(int num);
  // 减少工作者线程
  void removeWorker(int num);
  // 得到正在等待执行的任务数量
  int getJobSize();
}
```

​	客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。

​	接下来是线程池接口的默认实现，示例如（代码清单4-20 DefaultThreadPool.java）所示。

```java
public class DefaultThreadPool<Job extends Runnable> implements ThreadPool<Job> {
  // 线程池最大限制数
  private static final int MAX_WORKER_NUMBERS = 10;
  // 线程池默认的数量
  private static final int DEFAULT_WORKER_NUMBERS = 5;
  // 线程池最小的数量
  private static final int MIN_WORKER_NUMBERS = 1;
  // 这是一个工作列表，将会向里面插入工作
  private final LinkedList<Job> jobs = new LinkedList<Job>();
  // 工作者列表
  private final List<Worker> workers = Collections.synchronizedList(new
                                                                    ArrayList<Worker>());
  // 工作者线程的数量
  private int workerNum = DEFAULT_WORKER_NUMBERS;
  // 线程编号生成
  private AtomicLong threadNum = new AtomicLong();
  public DefaultThreadPool() {
    initializeWokers(DEFAULT_WORKER_NUMBERS);
  }
  public DefaultThreadPool(int num) {
    workerNum = num > MAX_WORKER_NUMBERS MAX_WORKER_NUMBERS : num < MIN_WORKER_
      NUMBERS MIN_WORKER_NUMBERS : num;
    initializeWokers(workerNum);
  }
  public void execute(Job job) {
    if (job != null) {
      // 添加一个工作，然后进行通知
      synchronized (jobs) {
        jobs.addLast(job);
        jobs.notify();
      }
    }
  }
  public void shutdown() {
    for (Worker worker : workers) {
      worker.shutdown();
    }
  }
  public void addWorkers(int num) {
    synchronized (jobs) {
      // 限制新增的Worker数量不能超过最大值
      if (num + this.workerNum > MAX_WORKER_NUMBERS) {
        num = MAX_WORKER_NUMBERS - this.workerNum;
      }
      initializeWokers(num);
      this.workerNum += num;
    }
  }
  public void removeWorker(int num) {
    synchronized (jobs) {
      if (num >= this.workerNum) {
        throw new IllegalArgumentException("beyond workNum");
      }
      // 按照给定的数量停止Worker
      int count = 0;
      while (count < num) {
        Worker worker = workers.get(count)
          if (workers.remove(worker)) {
            worker.shutdown();
            count++;
          }
      }
      this.workerNum -= count;
    }
  }
  public int getJobSize() {
    return jobs.size();
  }
  // 初始化线程工作者
  private void initializeWokers(int num) {
    for (int i = 0; i < num; i++) {
      Worker worker = new Worker();
      workers.add(worker);
      Thread thread = new Thread(worker, "ThreadPool-Worker-" + threadNum.
                                 incrementAndGet());
      thread.start();
    }
  }
  // 工作者，负责消费任务
  class Worker implements Runnable {
    // 是否工作
    private volatile boolean running = true;
    public void run() {
      while (running) {
        Job job = null;
        synchronized (jobs) {
          // 如果工作者列表是空的，那么就wait
          while (jobs.isEmpty()) {
            try {
              jobs.wait();
            } catch (InterruptedException ex) {
              // 感知到外部对WorkerThread的中断操作，返回
              Thread.currentThread().interrupt();
              return;
            }
          }
          // 取出一个Job
          job = jobs.removeFirst();
        }
        if (job != null) {
          try {
            job.run();
          } catch (Exception ex) {
            // 忽略Job执行中的Exception
          }
        }
      }
    }
    public void shutdown() {
      running = false;
    }
  }
}
```

​	从线程池的实现可以看到，**当客户端调用execute(Job)方法时，会不断地向任务列表jobs中添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态**。

​	添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（**避免将等待队列中的线程全部移动到阻塞队列中**）。

​	可以看到，**线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒**。

### 4.4.4 一个基于线程池技术的简单Web服务器

> [基于线程池技术的web服务器](https://www.cnblogs.com/wyq178/p/10507777.html)

​	目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取，这样用户就不会遇到一直等到一个图片完全下载完成才能继续查看文字内容的尴尬情况。

​	如果Web服务器是单线程的，多线程的浏览器也没有用武之地，因为服务端还是一个请求一个请求的顺序处理。因此，大部分Web服务器都是支持并发访问的。**常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术**。

​	下面通过使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求，示例如（代码清单4-21 SimpleHttpServer.java）所示。

```java
public class SimpleHttpServer {
  // 处理HttpRequest的线程池
  static ThreadPool<HttpRequestHandler> threadPool = new DefaultThreadPool
    <HttpRequestHandler>(1);
  // SimpleHttpServer的根路径
  static String basePath;
  static ServerSocket serverSocket;
  // 服务监听端口
  static int port = 8080;
  public static void setPort(int port) {
    if (port > 0) {
      SimpleHttpServer.port = port;
    }
  }
  public static void setBasePath(String basePath) {
    if (basePath != null && new File(basePath).exists() && new File(basePath).
        isDirectory()) {
      SimpleHttpServer.basePath = basePath;
    }
  }
  // 启动SimpleHttpServer
  public static void start() throws Exception {
    serverSocket = new ServerSocket(port);
    Socket socket = null;
    while ((socket = serverSocket.accept()) != null) {
      // 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行
      threadPool.execute(new HttpRequestHandler(socket));
    }
    serverSocket.close();
  }
  static class HttpRequestHandler implements Runnable {
    private Socket socket;
    public HttpRequestHandler(Socket socket) {
      this.socket = socket;
    }
    @Override
    public void run() {
      String line = null;
      BufferedReader br = null;
      BufferedReader reader = null;
      PrintWriter out = null;
      InputStream in = null;
      try {
        reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        String header = reader.readLine();
        // 由相对路径计算出绝对路径
        String filePath = basePath + header.split(" ")[1];
        out = new PrintWriter(socket.getOutputStream());
        // 如果请求资源的后缀为jpg或者ico，则读取资源并输出
        if (filePath.endsWith("jpg") || filePath.endsWith("ico")) {
          in = new FileInputStream(filePath);
          ByteArrayOutputStream baos = new ByteArrayOutputStream();
          int i = 0;
          while ((i = in.read()) != -1) {
            baos.write(i);
          }
          byte[] array = baos.toByteArray();
          out.println("HTTP/1.1 200 OK");
          out.println("Server: Molly");
          out.println("Content-Type: image/jpeg");
          out.println("Content-Length: " + array.length);
          out.println("");
          socket.getOutputStream().write(array, 0, array.length);
        } else {
          br = new BufferedReader(new InputStreamReader(new
                                                        FileInputStream(filePath)));
          out = new PrintWriter(socket.getOutputStream());
          out.println("HTTP/1.1 200 OK");
          out.println("Server: Molly");
          out.println("Content-Type: text/html; charset=UTF-8");
          out.println("");
          while ((line = br.readLine()) != null) {
            out.println(line);
          }
        }
        out.flush();
      } catch (Exception ex) {
        out.println("HTTP/1.1 500");
        out.println("");
        out.flush();
      } finally {
        close(br, in, reader, out, socket);
      }
    }
  }
  // 关闭流或者Socket
  private static void close(Closeable... closeables) {
    if (closeables != null) {
      for (Closeable closeable : closeables) {
        try {
          closeable.close();
        } catch (Exception ex) {
        }
      }
    }
  }
}
```

​	该Web服务器处理用户请求的时序图如下图所示。

![img](https://img-blog.csdn.net/20180528094427640?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzIyMjg0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img2018.cnblogs.com/blog/1066538/201903/1066538-20190317154517832-217382213.png)

​	在上图中，**SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理**。在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。

​	接下来，通过一个测试对比来认识线程池技术带来服务器吞吐量的提高。我们准备了一个简单的HTML页面，内容如（代码清单4-22 Index.html）所示。

```html
<html>
  <head>
    <title>测试页面</title>
  </head>
  <body >
    <h1>第一张图片</h1>
    <img src="1.jpg" />
    <h1>第二张图片</h1>
    <img src="2.jpg" />
    <h1>第三张图片</h1>
    <img src="3.jpg" />
  </body>
</html>
```

​	将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer，通过Apache HTTP server benchmarking tool（版本2.3）来测试不同线程数下，SimpleHttpServer的吞吐量表现。

​	测试场景是5000次请求，分10个线程并发执行，测试内容主要考察响应时间（越小越好）和每秒查询的数量（越高越好），测试结果如表4-4所示（本书籍的作者的机器CPU：i7-3635QM，内存为8GB，实际输出可能与此表不同）。

![img](https://img2018.cnblogs.com/blog/1066538/201903/1066538-20190317133903655-292483484.png)

​	可以看到，随着线程池中线程数量的增加，SimpleHttpServer的吞吐量不断增大，响应时间不断变小，线程池的作用非常明显。

​	但是，**线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。**

## 4.5 本章小结

​	本章从介绍多线程技术带来的好处开始，讲述了如何启动和终止线程以及线程的状态，详细阐述了多线程之间进行通信的基本方式和等待/通知经典范式。在线程应用示例中，使用了**等待超时**、**数据库连接池**以及**简单线程池**3个不同的示例巩固本章前面章节所介绍的Java多线程基础知识。最后通过一个简单的Web服务器将上述知识点串联起来，加深我们对这些知识点的理解。