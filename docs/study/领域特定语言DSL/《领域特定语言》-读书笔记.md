# 《领域特定语言》-读书笔记

> 以下图片均来源自网络

常见的领域特定语言DSL实现方式有：

+ XML
+ jsonpath
+ ...

可以说DSL是目的/目标，而具体可以通过XML、jsonpath等工具/手段实现。

比如希望有一种DSL能够简单表示json内某层级的对象数据，那么jsonpath就是一种不错的实现。

# 第1章 入门例子

## 1.1 哥特式建筑安全系统

> [《领域特定语言》一第1章 入 门 例 子1.1　哥特式建筑安全系统-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/176279)

​	假设有个客户，格兰特小姐，需要一套控制器系统，在触发某些机关后能完成开关密室，开关灯等事件。

![image](https://yqfile.alicdn.com/f3dd01663b06eb920f0882821f5d30273d440e55.png)

## 1.2 状态机模型

> [《领域特定语言》一1.2　状态机模型-WinFrom控件库|.net开源控件库|HZHControls官网](http://www.hzhcontrols.com/new-416582.html)

​	一旦团队达成共识，认为对于指定控制器如何运作而言，状态机是一个恰当的抽象，那么，下一步就是确保这个抽象能够运用到软件自身。如果人们在考虑控制器行为时，也要考虑事件、状态和转换，那么，我们希望这些词汇也可以出现在软件代码里。从本质上说，这就是**领域驱动设计（Domain–Driven Design）中的Ubiquitous Language [Evans DDD] 原则**，也就是说，我们在领域人员（那些描述建筑安全该如何运作的人）和程序员之间构建的一种共享语言。

​	对于Java程序来说，处理这种事，自然的方式就是以状态机为Domain Model [Fowler PoEAA]。状态机框架的类图见图1-2。
![image](https://yqfile.alicdn.com/d72e96639c5613ec7fba9d5eda990a52f2cf7336.png)

​	忽略简易状态机代码片段用例，主要就是需要实现State，Abstract Event，Command，Event，Transition、State Machine的代码。

## 1.3 为格兰特小姐的控制器编写程序

​	定义完状态机相关的类后，接下去就需要创建相关实例，并且将其关联起来，伪代码片段如下：

```pseudocode
Event doorClosed = new Event("doorClosed", "D1CL");
Event drawerOpened = new Event("drawerOpened", "D2OP");
Event lightOn = new Event("lightOn", "L1ON");
Event doorOpened = new Event("doorOpened", "D1OP");
Event panelClosed = new Event("panelClosed", "PNCL");
 
Command unlockPanelCmd = new Command("unlockPanel", "PNUL");
Command lockPanelCmd = new Command("lockPanel", "PNLK");
Command lockDoorCmd = new Command("lockDoor", "D1LK");
Command unlockDoorCmd = new Command("unlockDoor", "D1UL");
 
State idle = new State("idle");
State activeState = new State("active");
State waitingForLightState = new State("waitingForLight");
State waitingForDrawerState = new State("waitingForDrawer");
State unlockedPanelState = new State("unlockedPanel");
 
StateMachine machine = new StateMachine(idle);
 
idle.addTransition(doorClosed, activeState);
idle.addAction(unlockDoorCmd);
idle.addAction(lockPanelCmd);
 
activeState.addTransition(drawerOpened, waitingForLightState);
activeState.addTransition(lightOn, waitingForDrawerState);
 
waitingForLightState.addTransition(lightOn, unlockedPanelState);
waitingForDrawerState.addTransition(drawerOpened, unlockedPanelState);
 
unlockedPanelState.addAction(unlockPanelCmd);
unlockedPanelState.addAction(lockDoorCmd);
unlockedPanelState.addTransition(panelClosed, idle);
 
machine.addResetEvents(doorOpened)
```

​	之前的代码描述了如何构建状态机模型，而上面这段代码则是在配置一个特定的控制器。**我们常常会看到这样一种划分：一方面是程序库、框架或者组件的实现代码；另一方面是配置代码或组件组装代码**。从本质上说，这种做法分开了公共代码和可变代码。用公共代码构建一套组件，然后根据不同的目的进行配置。

​	配置代码还有另外一种表现形式：

```xml

<stateMachine start = "idle">
  <event name="doorClosed" code="D1CL"/>
  <event name="drawerOpened" code="D2OP"/>
  <event name="lightOn" code="L1ON"/>
  <event name="doorOpened" code="D1OP"/>
  <event name="panelClosed" code="PNCL"/>

  <command name="unlockPanel" code="PNUL"/>
  <command name="lockPanel" code="PNLK"/>
  <command name="lockDoor" code="D1LK"/>
  <command name="unlockDoor" code="D1UL"/>

  <state name="idle">
    <transition event="doorClosed" target="active"/>
    <action command="unlockDoor"/>
    <action command="lockPanel"/>
  </state>

  <state name="active">
    <transition event="drawerOpened" target="waitingForLight"/>
    <transition event="lightOn" target="waitingForDrawer"/>
  </state>

  <state name="waitingForLight">
    <transition event="lightOn" target="unlockedPanel"/>
  </state>

  <state name="waitingForDrawer">
    <transition event="drawerOpened" target="unlockedPanel"/>
  </state>

  <state name="unlockedPanel">
    <action command="unlockPanel"/>
    <action command="lockDoor"/>  
    <transition event="panelClosed" target="idle"/>
  </state>

  <resetEvent name = "doorOpened"/>
</stateMachine>
```

​	假如系统通过XML就可以完成状态机器的配置，XML比起直接用代码声明配置关系，有以下好处：

1. 变更状态机行为，只需要修改XML配置文件，无需修改java代码发布新的jar文件。（假设系统已经设计完成各种热加载机制，能方便解析XML配置项，完成对应的java版本的代码配置工作）
2. 可读性更好

​	往配置化的方向出发，下面还可以有另一种形式的配置：

```pseudocode
events
 doorClosed D1CL
 drawerOpened D2OP
 lightOn   L1ON
 doorOpened D1OP
 panelClosed PNCL
end
 
resetEvents
 doorOpened
end
 
commands
 unlockPanel PNUL
 lockPanel  PNLK
 lockDoor  D1LK
 unlockDoor D1UL
end
 
state idle
 actions {unlockDoor lockPanel}
 doorClosed => active
end
 
state active
 drawerOpened => waitingForLight
 lightOn  => waitingForDrawer
end
 
state waitingForLight
 lightOn => unlockedPanel
end
 
state waitingForDrawer
 drawerOpened => unlockedPanel
end
 
state unlockedPanel
 actions {unlockPanel lockDoor}
 panelClosed => idle
end
```

​	上面这种配置方式，比XML更简约易读，但是非图灵完备，只能描述应用的一小方面，需要配合其他语言才能完成整个控制器的工作。但是，**DSL的简单性意味着，它是易于编辑和处理的**。

​	DSL扮演领域专家和业务分析人员之间的交流媒介，虽然构建这种DSL也存在一些实际的困难，但能够在软件开发最困难的交流鸿沟上架起一座桥梁，其益处也让这种尝试物有所值。

​	现在，回顾一下XML的表示形式。这是一种DSL吗？我想说，它是。只不过它是用XML的语法载体而已─ 但是它依旧是DSL。这个例子引出了一个设计问题：哪种做法更好：为DSL定制语法，还是使用XML语法？XML更易于解析，因为人们已经熟悉了解析XML。（然而，同为定制语法编写解析器相比，为XML编写解析器花了我同样多的时间。）我要声明一点，定制语法易读得多，至少在这个例子里是这样的。然而，回顾一下这个选择，我们会发现，DSL核心部分的权衡也是一样的。<u>的确，我们可以认为，大多数XML配置文件本质上都是DSL</u>。

​	看看下面这段代码，它看上去像是这个问题的DSL吗？

```ruby
event :doorClosed, "D1CL"
event :drawerOpened, "D2OP"
event :lightOn, "L1ON"
event :doorOpened, "D1OP"
event :panelClosed, "PNCL"

command :unlockPanel, "PNUL"
command :lockPanel,  "PNLK"
command :lockDoor,  "D1LK"
command :unlockDoor, "D1UL"

resetEvents :doorOpened

state :idle do
  actions :unlockDoor, :lockPanel
  transitions :doorClosed => :active
end

state :active do
  transitions :drawerOpened => :waitingForLight,
  :lightOn => :waitingForDrawer
end

state :waitingForLight do
  transitions :lightOn => :unlockedPanel
end

state :waitingForDrawer do
  transitions :drawerOpened => :unlockedPanel
end

state :unlockedPanel do
  actions :unlockPanel, :lockDoor
  transitions :panelClosed => :idle
end
```

​	上面通过Ruby代码完成控制器配置的DSL具体实现，这里相当于DSL是目的，Ruby只是实现该目的而选择的一种语言工具。比如Lisp程序员通常会考虑在Lisp里创建DSL。

​	**文本DSL有两种，称为外部DSL（external DSL）和内部DSL（internal DSL）**。

+ 外部DSL：在主程序设计语言之外，用一种单独的语言表示领域专用语言。这种语言用的可能是定制语法，或者遵循另一种表现的语法，比如XML。
+ 内部DSL：用通用语言的语法表示的DSL。这种做法就是出于领域专用的目的，而按照某种风格来使用这种语言。

​	也许有人还听说一个术语，嵌入式DSL（embedded DSL），它是内部DSL的同义词。虽然这个术语应用得相当广泛，但我还是会避免使用它，因为“嵌入式语言”（embedded language）同样适用于在应用中嵌入的脚本语言，比如Excel里的VBA，Gimp里的Scheme。

​	回过头来考虑一下原来的Java配置代码。它是一种DSL吗？我想说，不是。这段代码感觉像是同API缝合在一起的，而上面的Ruby代码则更有声明式语言的感觉。这是否意味着无法用Java实现内部DSL呢？下面这段代码怎么样？
