# 《领域特定语言》-读书笔记

> + 以下图片均来源自网络
> + “我”皆指图书作者

常见的领域特定语言DSL实现方式有：

+ XML
+ jsonpath
+ ...

可以说DSL是目的/目标，而具体可以通过XML、jsonpath等工具/手段实现。

比如希望有一种DSL能够简单表示json内某层级的对象数据，那么jsonpath就是一种不错的实现。

# 第1章 入门例子

## 1.1 哥特式建筑安全系统

> [《领域特定语言》一第1章 入 门 例 子1.1　哥特式建筑安全系统-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/176279)

​	假设有个客户，格兰特小姐，需要一套控制器系统，在触发某些机关后能完成开关密室，开关灯等事件。

![image](https://yqfile.alicdn.com/f3dd01663b06eb920f0882821f5d30273d440e55.png)

## 1.2 状态机模型

> [《领域特定语言》一1.2　状态机模型-WinFrom控件库|.net开源控件库|HZHControls官网](http://www.hzhcontrols.com/new-416582.html)

​	一旦团队达成共识，认为对于指定控制器如何运作而言，状态机是一个恰当的抽象，那么，下一步就是确保这个抽象能够运用到软件自身。如果人们在考虑控制器行为时，也要考虑事件、状态和转换，那么，我们希望这些词汇也可以出现在软件代码里。从本质上说，这就是**领域驱动设计（Domain–Driven Design）中的Ubiquitous Language [Evans DDD] 原则**，也就是说，我们在领域人员（那些描述建筑安全该如何运作的人）和程序员之间构建的一种共享语言。

​	对于Java程序来说，处理这种事，自然的方式就是以状态机为Domain Model [Fowler PoEAA]。状态机框架的类图见图1-2。
![image](https://yqfile.alicdn.com/d72e96639c5613ec7fba9d5eda990a52f2cf7336.png)

​	忽略简易状态机代码片段用例，主要就是需要实现State，Abstract Event，Command，Event，Transition、State Machine的代码。

## 1.3 为格兰特小姐的控制器编写程序

​	定义完状态机相关的类后，接下去就需要创建相关实例，并且将其关联起来，伪代码片段如下：

```pseudocode
Event doorClosed = new Event("doorClosed", "D1CL");
Event drawerOpened = new Event("drawerOpened", "D2OP");
Event lightOn = new Event("lightOn", "L1ON");
Event doorOpened = new Event("doorOpened", "D1OP");
Event panelClosed = new Event("panelClosed", "PNCL");
 
Command unlockPanelCmd = new Command("unlockPanel", "PNUL");
Command lockPanelCmd = new Command("lockPanel", "PNLK");
Command lockDoorCmd = new Command("lockDoor", "D1LK");
Command unlockDoorCmd = new Command("unlockDoor", "D1UL");
 
State idle = new State("idle");
State activeState = new State("active");
State waitingForLightState = new State("waitingForLight");
State waitingForDrawerState = new State("waitingForDrawer");
State unlockedPanelState = new State("unlockedPanel");
 
StateMachine machine = new StateMachine(idle);
 
idle.addTransition(doorClosed, activeState);
idle.addAction(unlockDoorCmd);
idle.addAction(lockPanelCmd);
 
activeState.addTransition(drawerOpened, waitingForLightState);
activeState.addTransition(lightOn, waitingForDrawerState);
 
waitingForLightState.addTransition(lightOn, unlockedPanelState);
waitingForDrawerState.addTransition(drawerOpened, unlockedPanelState);
 
unlockedPanelState.addAction(unlockPanelCmd);
unlockedPanelState.addAction(lockDoorCmd);
unlockedPanelState.addTransition(panelClosed, idle);
 
machine.addResetEvents(doorOpened)
```

​	之前的代码描述了如何构建状态机模型，而上面这段代码则是在配置一个特定的控制器。**我们常常会看到这样一种划分：一方面是程序库、框架或者组件的实现代码；另一方面是配置代码或组件组装代码**。从本质上说，这种做法分开了公共代码和可变代码。用公共代码构建一套组件，然后根据不同的目的进行配置。

​	配置代码还有另外一种表现形式：

```xml

<stateMachine start = "idle">
  <event name="doorClosed" code="D1CL"/>
  <event name="drawerOpened" code="D2OP"/>
  <event name="lightOn" code="L1ON"/>
  <event name="doorOpened" code="D1OP"/>
  <event name="panelClosed" code="PNCL"/>

  <command name="unlockPanel" code="PNUL"/>
  <command name="lockPanel" code="PNLK"/>
  <command name="lockDoor" code="D1LK"/>
  <command name="unlockDoor" code="D1UL"/>

  <state name="idle">
    <transition event="doorClosed" target="active"/>
    <action command="unlockDoor"/>
    <action command="lockPanel"/>
  </state>

  <state name="active">
    <transition event="drawerOpened" target="waitingForLight"/>
    <transition event="lightOn" target="waitingForDrawer"/>
  </state>

  <state name="waitingForLight">
    <transition event="lightOn" target="unlockedPanel"/>
  </state>

  <state name="waitingForDrawer">
    <transition event="drawerOpened" target="unlockedPanel"/>
  </state>

  <state name="unlockedPanel">
    <action command="unlockPanel"/>
    <action command="lockDoor"/>  
    <transition event="panelClosed" target="idle"/>
  </state>

  <resetEvent name = "doorOpened"/>
</stateMachine>
```

​	假如系统通过XML就可以完成状态机器的配置，XML比起直接用代码声明配置关系，有以下好处：

1. 变更状态机行为，只需要修改XML配置文件，无需修改java代码发布新的jar文件。（假设系统已经设计完成各种热加载机制，能方便解析XML配置项，完成对应的java版本的代码配置工作）
2. 可读性更好

​	往配置化的方向出发，下面还可以有另一种形式的配置：

```pseudocode
events
 doorClosed D1CL
 drawerOpened D2OP
 lightOn   L1ON
 doorOpened D1OP
 panelClosed PNCL
end
 
resetEvents
 doorOpened
end
 
commands
 unlockPanel PNUL
 lockPanel  PNLK
 lockDoor  D1LK
 unlockDoor D1UL
end
 
state idle
 actions {unlockDoor lockPanel}
 doorClosed => active
end
 
state active
 drawerOpened => waitingForLight
 lightOn  => waitingForDrawer
end
 
state waitingForLight
 lightOn => unlockedPanel
end
 
state waitingForDrawer
 drawerOpened => unlockedPanel
end
 
state unlockedPanel
 actions {unlockPanel lockDoor}
 panelClosed => idle
end
```

​	上面这种配置方式，比XML更简约易读，但是非图灵完备，只能描述应用的一小方面，需要配合其他语言才能完成整个控制器的工作。但是，**DSL的简单性意味着，它是易于编辑和处理的**。

​	DSL扮演领域专家和业务分析人员之间的交流媒介，虽然构建这种DSL也存在一些实际的困难，但能够在软件开发最困难的交流鸿沟上架起一座桥梁，其益处也让这种尝试物有所值。

​	现在，回顾一下XML的表示形式。这是一种DSL吗？我想说，它是。只不过它是用XML的语法载体而已─ 但是它依旧是DSL。这个例子引出了一个设计问题：哪种做法更好：为DSL定制语法，还是使用XML语法？XML更易于解析，因为人们已经熟悉了解析XML。（然而，同为定制语法编写解析器相比，为XML编写解析器花了我同样多的时间。）我要声明一点，定制语法易读得多，至少在这个例子里是这样的。然而，回顾一下这个选择，我们会发现，DSL核心部分的权衡也是一样的。<u>的确，我们可以认为，大多数XML配置文件本质上都是DSL</u>。

​	看看下面这段代码，它看上去像是这个问题的DSL吗？

```ruby
event :doorClosed, "D1CL"
event :drawerOpened, "D2OP"
event :lightOn, "L1ON"
event :doorOpened, "D1OP"
event :panelClosed, "PNCL"

command :unlockPanel, "PNUL"
command :lockPanel,  "PNLK"
command :lockDoor,  "D1LK"
command :unlockDoor, "D1UL"

resetEvents :doorOpened

state :idle do
  actions :unlockDoor, :lockPanel
  transitions :doorClosed => :active
end

state :active do
  transitions :drawerOpened => :waitingForLight,
  :lightOn => :waitingForDrawer
end

state :waitingForLight do
  transitions :lightOn => :unlockedPanel
end

state :waitingForDrawer do
  transitions :drawerOpened => :unlockedPanel
end

state :unlockedPanel do
  actions :unlockPanel, :lockDoor
  transitions :panelClosed => :idle
end
```

​	上面通过Ruby代码完成控制器配置的DSL具体实现，这里相当于DSL是目的，Ruby只是实现该目的而选择的一种语言工具。比如Lisp程序员通常会考虑在Lisp里创建DSL。

​	**文本DSL有两种，称为外部DSL（external DSL）和内部DSL（internal DSL）**。

+ 外部DSL：在主程序设计语言之外，用一种单独的语言表示领域专用语言。这种语言用的可能是定制语法，或者遵循另一种表现的语法，比如XML。
+ 内部DSL：用通用语言的语法表示的DSL。这种做法就是出于领域专用的目的，而按照某种风格来使用这种语言。

​	*也许有人还听说一个术语，嵌入式DSL（embedded DSL），它是内部DSL的同义词。虽然这个术语应用得相当广泛，但我还是会避免使用它，因为“嵌入式语言”（embedded language）同样适用于在应用中嵌入的脚本语言，比如Excel里的VBA，Gimp里的Scheme。*

​	回过头来考虑一下原来的Java配置代码。它是一种DSL吗？我想说，不是。这段代码感觉像是同API缝合在一起的，而上面的Ruby代码则更有声明式语言的感觉。这是否意味着无法用Java实现内部DSL呢？下面这段代码怎么样？

```java
public class BasicStateMachine extends StateMachineBuilder {

  Events doorClosed, drawerOpened, lightOn, panelClosed;
  Commands unlockPanel, lockPanel, lockDoor, unlockDoor;
  States idle, active, waitingForLight, waitingForDrawer, unlockedPanel;
  ResetEvents doorOpened;

  protected void defineStateMachine() {
    doorClosed. code("D1CL");
    drawerOpened. code("D2OP");
    lightOn.  code("L1ON");
    panelClosed.code("PNCL");

    doorOpened. code("D1OP");

    unlockPanel.code("PNUL");
    lockPanel. code("PNLK");
    lockDoor.  code("D1LK");
    unlockDoor. code("D1UL");

    idle
      .actions(unlockDoor, lockPanel)
      .transition(doorClosed).to(active)
      ;

    active
      .transition(drawerOpened).to(waitingForLight)
      .transition(lightOn).to(waitingForDrawer)
      ;

    waitingForLight
      .transition(lightOn).to(unlockedPanel)
      ;

    waitingForDrawer
      .transition(drawerOpened).to(unlockedPanel)
      ;

    unlockedPanel
      .actions(unlockPanel, lockDoor)
      .transition(panelClosed).to(idle)
      ;
  }
}
```

​	虽然这段代码格式上有些奇怪，而且用到了一些不常见的编程约定，但它确实是有效的Java。这段代码我愿意称为 DSL；虽然同Ruby DSL相比，它有些乱，但它还是有DSL所需的声明流。

​	是什么让内部DSL不同于通常的API呢？这是一个很难回答的问题，稍后，在4.1节，我会花更多的时间来讨论，但它会归结为一种流，只不过用的是一种类语言的模糊记法而已。

​	也许，有人还碰到过内部DSL的另一个术语，连贯接口（fluent interface）。这个术语强调这样一个事实：内部 DSL实际上只是某种形式的API，只不过其设计考虑到了连贯性。鉴于这种差别，最好给非连贯 API一个名字（我用的术语是，命令）查询API（command–query API）。

## 1.4 语言和语义模型

​	在状态机模型例子里，DSL的角色就是组装状态机模型。因此，当解析定制语法的版本时，遇到：

```javascript
events
　doorClosed D1CL
```

​	会创建一个新的事件对象（`new Event("doorClosed","D1CL")`），把它保存在一边（在一个 “符号表”（第14章）里），这样，遇到`doorClosed=>active`时，就可以将它包含在一个转换里（使用`addTransition`）。这个模型就是个引擎，它提供了状态机的行为。事实上，可以说，这个设计的能力大多源自这样一个模型。如图1-4所示，**DSL所做的一切就是提供一种更可读的方式来组装这个模型**——这就是与开始的命令查询API不同的地方。

​	从DSL的角度来看，我把这个模型称为“语义模型”（第11章）。**谈及编程语言时，我们常常会提及语法（syntax）和语义（semantics）。语法描述程序的合法表达式，而在定制语法的DSL里所能描述的一切是由文法（grammar）决定的**。程序的语义是指，它代表着什么，也就是说，当执行时，它能做什么。在这个例子里，模型定义了语义。如果你习惯使用Domain Model [Fowler PoEAA] ，这里就可以认为语义模型是与之非常类似的东西。

![image](https://yqfile.alicdn.com/1f625ae59d9308c563afb8dbb6f821cc151cda6f.png)

​	（你可以查看一下“语义模型”（第11章），了解一下语义模型同Domain Model之间的差异，还有语义模型和抽象语法树之间的不同。）

​	我有一个观点，**对于一个设计良好的DSL而言，语义模型至关重要**。强烈建议，DSL应该使用语义模型。

​	<u>语义模型，能清晰地将**语言解析**和**结果语义**的关注点切分开</u>。我可以推究出状态机的运作机制，对状态机进行增强和调试，而无须顾及语言问题。通过命令–查询接口，就可以组装状态机测试模型。状态机模型和DSL可以独立演进，即便还没想好如何通过语言表示，依然可以为模型添加新特性。也许，最关键的点在于，模型可以独立测试，而无须涉及语言。确实，上面所有DSL的例子都构建在相同语义模型上，基于这个模型，可以创建出完全相同的配置对象。

​	**功能由模型提供，DSL增强模型的表达能力。正确的DSL让我们更容易理解一个特定状态机的运作机制。一些DSL甚至可以让我们在运行时配置模型。因此，DSL是对模型的一个有益补充**。

​	<u>DSL所带来的益处与状态机紧密相关，其所组成的某个特定模型就扮演了系统程序的角色。要改变状态机的行为，就需要修改模型中的对象及其相互关系。这种风格的模型通常称为“适应性模型”（第47章）</u>。这样得到的是一个模糊了代码和数据之间差异的系统，只看代码，是无法理解状态机行为的，还必须了解对象实例的连接方式。当然，从某种程度上 说，这总是对的，任何程序对不同的数据都会给出不同的结果，但在此有个极大的差异，因为状态对象的存在会在很大程度上改变系统的行为。

​	**适应性模型非常强大，但是通常也很难用，因为人们看不到任何定义特定行为的代码。DSL是有价值的，它提供了一种显式的方式表现代码，这种形式让人们对状态机编程有了感觉**。

​	<u>状态机可以很好地适用于适应性模型，原因在于，它是另一种计算模型。常规的编程语言提供了一种为机器编程的标准思考方式，多数情况下它运作良好</u>。但是，有时，我们需要一些不同的方式，比如“状态机”（第51章），“产生式规则系统”（第50章），或者“依赖网络”（第49章）。使用适应性模型是一种好的方式，它提供了另一种计算模型，DSL则简化了为这种模型编程的方式。本书稍后会描述“其他一些计算模型”（第7章），在那里，你会了解到它们是什么样子，以及如何实现。或许你曾听说，有人把这种使用DSL的方式称为**声明式编程**。

​	在讨论这个例子时，我采用的流程是：**首先构建模型，然后在此基础之上，用DSL封装出一个层次，对其进行操作**。之所以用这种方式进行描述，是因为我觉得这是一种简单的方式，有助于理解DSL如何用于软件开发。虽然模型优先的情况很常见，但它并不是唯一方式。在不同的场景下，我们可能会与领域专家交谈，假定他们可以理解状态机方式。稍后，我们和他们一起工作，创建出他们可以理解的DSL。在这种情况下，DSL和模型可以同步构建。

## 1.5 使用代码生成
