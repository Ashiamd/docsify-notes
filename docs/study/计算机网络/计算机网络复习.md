# 计算机网络复习

> 要回顾就详细地回顾，打破砂锅问到底=爽
>
> 推荐想继续再深入的可以再看看《计算机网络-自顶向下方法》和《TCP/IP详解卷1：协议》，后续看情况也会整理对应的笔记。

## 0. 计算机网络概述

### 0.1 网络组成

1. 边缘部分

   + 客户服务器方式C/S
   + 对等方式P2P

2. 核心部分

   + 电路交换

     建立连接（申请占用通信资源）-> 通话（一直占用通信资源） -> 释放连接（释放通信资源）

     适合数据量很大的实时性传输，==核心路由器之间可以使用电路交换==。

     建立连接后，一次性发送所有数据。

   + 报文交换

     每个中间路由器需要重新发送整个完整的报文。

   + 分组交换

     将报文拆分成多个分组后，每个中间路由器需要重新发送整个完整的分组。由于分组更小，时延也就更小。

     （理想情况下，比如一个报文平均分4分，从起点到终点，中间需要经过2路由时，那么第一个路由收到分组1，马上接收分组2，并且把分组1发送到第二个中间路由器。）

## 1. 计算机网络体系结构

### 1.1 OSI七层模型

> [协议数据单元PDU]([https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/8226389?fromtitle=PDU&fromid=1855#viewPageContent](https://baike.baidu.com/item/协议数据单元/8226389?fromtitle=PDU&fromid=1855#viewPageContent))

1. 物理层：电压、接口标准。位流(bit流)传输。
2. 数据链路层：数据如何封装，添加物理层地址（MAC）、碰撞检测、指数退让。数据帧传输。
   + ARP、RARP（功能上网络层，实际实现、工作是数据链路层）
3. 网络层：IP地址编址、选择最佳路径。分组传输（分组就是拆分报文，然后添加一些首部信息，这样获得所有分组后，可以按照顺序组合回成更高层的报文）
   + IP、ICMP
4. 传输层：可靠传输TCP（需建立会话）、不可靠传输UDP、流量控制。报文传输。
   + TCP、UDP
5. 会话层：服务和用户建立的绘画(ps:使用netstat -nb 可以检测主机建立连接的程序)
6. 表示层：数据加密、压缩。
7. 应用层：产生网络流量、与用户交互，传输PDU（可以理解为文件、电影、图片什么的）。
   + HTTP、FTP、STMP

### 1.2 网络安全和OSI参考模型

> [ADSL，Asymmetric Digital Subscriber Line](https://baike.baidu.com/item/ADSL/96520)

1. 物理层安全：比如整个办公楼的网线在装修时，都预留好了，每个楼层有网线接口插座。然后这些网线都连接到地下室的服务器，来上网。哪一天要是中间几层楼出租给别的公司了，那么这些公司要是也直接用这些网线，就能访问到地下室的服务器了，这样子地下室的服务器就可能被攻击。（解决方式：可以直接在地下室服务器上拔掉这条网线接口。）
2. 数据链路层安全：ADSL、AP密码等。
   1. ADSL，用户通过电话拨号上网，需要输入账号密码。这个账号密码和应用层的邮箱系统的账号密码是不同级别的。
   2. 无线AP，无线网卡。要是没有密码，那么每个人都可以通过笔记本的无线网卡，直接WiFi蹭别人的网了。

3. 网络层安全：IP限制网络访问。比如某公司限制研发部的IP网段可以连接外网，而运维部的IP网段不能访问外网。（可以通过防火墙实现IP限制等）

7. 应用层安全：SQL注入漏洞、上传漏洞、XSS攻击等。SQL注入比如数据库模糊查询；上传漏洞比如上传PHP文件，然后被服务器解释并运行。

## 2. 物理层

### 2.1 物理层基本概念

​	物理层解决如何在连接各种计算机的传输媒体上传输**数据比特流**的问题，而不是值具体的传输媒体。

​	物理层的主要任务描述为：确定与传输媒体的接口的一些特性，即：

+ 机械特性：例接口形状、大小、引线数目
+ 电气特性：例规定电压范围（-5V~5V）
+ 功能特性：例规定-5V表示0，+5V表示1
+ 过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤

### 2.2 基础知识

1. #### 典型的数据通信模型

   输入数据 --> PC --数字比特流(bit)--> 调制解调器--模拟信号-->公用电话网--模拟信号-->调制解调器--数字比特流--> PC --> 显示数据

2. #### 相关术语

   > [数字信号与模拟信号的区别是什么？](https://zhidao.baidu.com/question/857445.html)
   >
   > 其实最明显的区别就是数字信号是离散变化的，模拟信号是连续的。
   >
   > 数字信号的改变没有体现中间过程的弧线，就是垂直的上凸下凹的图，或者纯数字；
   >
   > 模拟信号的改变能体现中间变化过程，是连续的弯曲弧状波形。->需要采样、量化才能转化成数字信号。
   >
   > **数字信号的抗干扰性强**，就算波形变化大，只要能判断是凹还是凸即可分辨出01，而模拟信号不能直接根据凹凸情况判断01，如果波形变化大，就更容易失真了。

   > [只有模拟信号才有码元的概念吗](https://zhidao.baidu.com/question/1888737754927484548.html)
   > 首先自然界是没bai有数字信号du的 数字信号是为了处理zhi器处理而出现的 所以要先对模拟信号dao采样得到数字信号
   模拟信号转数字信号要经过：采样-量化-编码 再将得到的数字信号按需要处理后转回模拟信号 编码就是对量化后的电平用编码形式表示称为码元
   奈奎斯特定律说明了采样要求 当采样频率fs.max大于信号中最高频率fhmax的2倍时(fs.max>2fhmax) 采样之后的数字信号完整包含了模拟信息 不会发生频谱混叠
   
   通信的目的就是传送信息。
   
   数据（data）——运送信息的实体。
   
   信号（signal）——数据的**电气**的或**电磁**的表现。*（比如电压高低表示1和0，光纤光信号）*

   + **模拟信号**：代表消息的参数的取值是连续的。*（比如声音的波状图）*
   
   + **数字信号**：代表信息的参数的取值是离散的。*（比如数字0，1，2，5，10之类的）*
   
   **码元**（code）——在**使用时间域的波形**<u>表示数字信号</u>时，则代表不同离散数值的基00本波形就成为码元。
   
   在数字通信中常常用时间间隔相同的符号来表示一个二进制的数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度。**1码元可以携带nbit的信息量**。
   
   ```none
   # 码元 ，就这种上下垂直的波状的图，与模拟信号那种连续的波状不同
   ┏━━┓    ┏━━┓   ┏━━┓
   ┃  ┃▁▁┃  ┃▁▁┃  ┃
   ```
   
   > [数字信号与模拟信号的区别是什么？](https://zhidao.baidu.com/question/857445.html)
   >
   > 1、**数字信号在传输过程中不仅具有较高的抗干扰性，还可以通过压缩，占用较少的带宽，实现在相同的带宽内传输更多、更高音频、视频等数字信号的效果**。此外，数字信号还可用半导体存储器来存储，并可直接用于计算机处理。若将电话、传真、电视所处理的音频、文本、视频等数据及其他各种不同形式的信号都转换成数字脉冲来传输，还有利于组成统一的通信网。
   >
   > 2、模拟信号传输过程中,先把信息信号转换成几乎“一模一样”的波动电信号(因此叫“模拟”),再通过有线或无线的方式传输出去,电信号被接收下来后,通过接收设备还原成信息信号。
   
3. #### 信道

   **信道一般表示向一个方向传送信息的媒体。所以咱们说平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道**。

   + 单工通信（单向通信）：只能有一个方向的通信而没有反方向的交互。*（比如无线电广播，由广播台到收音机）*
   + 半双工通信（双向交替通信）：通信的双方都可以发送信息，但不能双方同时发送（接收）。*（比如对讲机）*
   + 全双工通信（双向同时通信）：通信的双方可以同时发送和接收信息。*（比如电话）*

4. #### 基带（baseband）信号和带通（band pass）信号

   > [为什么无线电通信要将低频信号调制到高频传输？](https://blog.csdn.net/li975242487/article/details/93859799)
   >
   > [什么是高频，什么是低频？](https://zhidao.baidu.com/question/495759961339275564.html)
   >
   > [2.4GWIFI和5G WIFI 有什么区别](https://www.bilibili.com/video/BV1qJ411T7ZQ/?spm_id_from=333.788.videocard.1)
   >
   > [Wi-Fi 网络中，2.4GHz 和 5GHz 各自有哪些优缺点？](https://www.zhihu.com/question/20001576)
   >
   > 5GHz WiFi频率更高（传播范围更小）-> 不重叠的频段更多(抗干扰好，传统2.4GHz仅使用3不重叠频段，5GHz使用22个频段) -> 速度快

   + 基带信号（基本频带信号）——**来自信源的信号**。像计算机输出的代码各种文字或图片文件的数据信号都属于基带信号。**基带信号就是发出的直接表达了要传输的信息的信号**，比如我们说话的声波就是基带信号。

   + 带通信号——把基带信号经过**载波调制**后，把信号的频率范围搬移到<u>较高的频段</u>以便在信道中传输（即仅在一段频率范围内能够通过信道）。

   由于在近距离范围内基带信号的衰减不大，从而信号内容不会发生变化，因此**在传输距离较近时，计算机网络都采用基带传输方式**。如从计算机到显示器、打印机等外设的信号就是基带传输的。

   ---

   + 高频（HF，High frequency）：是频率在3 ~ 30MHz 之间的信号频率，这只是对高频的狭隘理解。而高频是包括3MHz到X00GHz的频率范围都可以称为高频。
   + 低频（LF，Low frequency）：是指频带由30 KHz到300 KHz的无线电电波。

   **频率越高，传输损耗越大（比如穿透墙壁损耗能量大，导致最后获取到的信号基本是那少部分衍射、反射过来的信号），覆盖距离越小，绕射能力越弱（原理是衍射）**。

   低频段资源紧张，低频段的无线电波主要用于广播、点视、寻呼等系统。

   > [为什么无线电通信要将低频信号调制到高频传输？](https://blog.csdn.net/li975242487/article/details/93859799)
   >
   > - 基带信号频率低，波长长，当天线的长度为无线电信号波长的 1/4 时，天线的发射和接收转换效率最高，如果不调制到高频，天线需要做得很长；
   > - 空间中的频谱资源是有限的，每个信道都严格划分给固定用途，通过载波调制可以选择合适的信道进行传输；
   > - 高频要比低频传送的成本低效率高。利用高频的不同的载波，容易实现多路通信。

5. #### 几种基本的调制方法

   1. 调幅（AM）：载波的**振幅**随基带数字信号而变化。
   2. 调频（FM）：载波的**频率**随基带数字信号而变化。
   3. 调相（PM）：载波的**初始相位**随基带数字信号而变化。

6. #### 数据通信常用编码

   1. 单极性不归零码
   2. 双极性不归零码
   3. 单极性归零码
   4. 双极性归零码
   5. 曼彻斯特编码：一个时钟周期只可表示一个bit，并且必须通过两次采样才能得到一个bit，但它能携带时钟信号，且可表示没有数据传输。（*最前面3种没数据传输了的时候和传输0的时候，都是保持在表示0的那个电压/电平，无法区分数据到底是否结束传输了，不利于同步*）
   6. 差分曼彻斯特编码：**与曼彻斯特编码相同（其实也不完全一样就是了），但抗干扰性能强于曼彻斯特编码**。

7. #### 信道的极限容量

   + 信号在实际信道（带宽受限、有噪音、干扰和失真）传输，往往接收信号波形会相对发送信号波形有不同程度的失真。

   + **奈氏准则：在任何信道中，==码元==传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能**。*（比如录音后，3倍速播放，就听不清楚）*

   $$
   理想低通信道的最高码元传输速率 = 2W Baud
   $$

   ​			+ W是理想低通信道的带宽，单位HZ

   ​			+ **Baud是波特，是码元传输速率的单位**（若一个码元含有n个bit的信息量，那么1Baud = n bit/s）

   + 波特Baud与bit的区别：在**调制解调器**中经常用到波特Baud这个概念。bit是信息量，如果一个码元含有3个bit信息量，那么这个时候1波特Baud=3bit/s。

     *（比如光猫->光调制解调器，PC把数字信号通过光猫转模拟信号到网络传输，光猫在把接收到的模拟信号转回数字信号传到PC）*

8. #### 信噪比

   **香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率**。
   $$
   信道的极限信息传输速率C=Wlog2(1+S/N)b/s
   $$

   + W为信道的带宽，单位HZ
   + S为信道内所传信号的平均功率
   + N为信道内部的高斯噪声功率

   香农公式标明：*（土话说就是，周围噪音大的时候，语速放慢勉强能听清楚。比如你边放音乐边讲话，别人0.5倍速听你的讲话录音能勉强听清楚）*

   1. 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。
   2. 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种方法来实现无差错的传输。
   3. 若信道带宽W或信噪比S/N没有上限（当然实际信道不可能如此），则信道的极限信息传输速率C也就没有上限。
   4. 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。

9. #### 奈氏准则和香农公式的应用范围

   ```none
   {1}输入信息->{2}[[源点]]->{3}输入数据(数字信号)->{4}[[发送器(调制)]]->{5}发送信号(模拟信号)=>{6}[[传输系统]]=>{7}接收信号(模拟信号)->{8}[[接收器(解调)]]->{9}输出数据(数字信号)->{10}[[终点]]->{11}输出信息
   
   {5}~{7},码元传输速率受奈氏准则的限制(只作用于模拟信号)
   {3}~{9},信息传输速率受香农公式的限制(作用于数字信号、模拟信号)
   ```

   简言之：

   + **奈氏准则：作用于模拟信号**（信道上的==码元==传输，前面说过了，码元即使用时间域的波形来表示数字信号，代表不同离散数数值的基本波形就是码元。）
   + **香农公式：作用于数字信号和模拟信号**

### 2.3 传输媒体

> [网线的交叉线与直连线的区别](https://zhidao.baidu.com/question/540267708.html)
>
> 如果连接的双方地位不对等的，则使用平行线，例如电脑连接到路由器或交换机
> 如果连接的两台设备是对等的，则使用交叉线，例如电脑连接到电脑
> 一般来说，交换机接电脑用直通线，交换机接交换机用交叉线。即同种设备用交叉线。因为同种设备的网线的信号引脚都是相同的，所以需要使用交叉线进行调换。
> 但现在很多交换机都能够自动识别网线了，不管交叉还是直通，都能正常使用。
>
> [为什么相同设备的连接要用交叉线，不同设备的连接要用直通线？](https://zhidao.baidu.com/question/348105662.html)
>
> 同等设备直通线的话，发射端对发射端，接收端对接收端。会导致两方都无法发送和接收。不过目前已经被智能接口取代了，这个问题也就不存在了。
>
> [相同设备连接为什么使用交叉线？](https://blog.csdn.net/weixin_33859231/article/details/92720340)
>
> 白橙 橙 对应1 2 是发送；白绿 绿对应3 6 是接收。其他接口没有数据传输作用。直通线是网线两端线序都是一样的。相同设备网卡接口发送和接收一样的。
>
> 用直通线连接等于把相同设备的发送接口连结在另一相同设备的发送接口，接收接口对应接收接口是不能实现互联的。
>
> 顺便说下网线中白蓝 蓝色 白棕 棕 四条线没有传输数据的作用(还有说法是其他4条留作电话线通讯)，与其它线以一定角度拧在一起主要是减少电磁干扰的作用
>
> [关于交叉线和直连线](https://www.zybang.com/question/5ab1f21cd63440b857c21e4c0aab6e59.html)
>
> 568A的排线顺序从左到右依次为：绿白、绿、橙白、蓝、蓝白、橙、棕白、棕.
> 568B则为：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕.
> 其中1、2用于发送数据,3、6用于接收数据,4、5用于传输语音,7、8用于传输电源.
> 所谓的交叉线是指：一端是568A标准,另一端是568B标准的双绞线.
> 直连线则指：两端都是568A或都是568B标准的双绞线.
>
> 总之,同一层设备相连用交叉线；不同一层设备相连用直连线
>
> [一条网线有八根线，每一根都起什么作用？](https://zhidao.baidu.com/question/148596500.html)
>
> T568A标准连线顺序从左到右依次为:1-绿白、2-绿、3-橙白、4-蓝、5-蓝白、6-橙、7-棕白、8-棕。
>
> T568B标准连线顺序从左到右依次为:1-橙白、2-橙、3-绿白、4-蓝、5-蓝白、6-绿、7-棕白、8-棕。
>
> 常用的T568B，每根线负责的功能是：1 输出数据 (+) 2 输出数据 (-) 3 输入数据 (+) 4 保留为电话使用 5 保留为电话使用 6 输入数据 (-) 7 保留为电话使用 8 保留为电话使用
>
> [为什么不同网络设备之间的连接是使用直通线而不是交叉线，我觉得任何设备之间的连接都使用交叉线才合理啊？](https://www.zhihu.com/question/329393238/answer/724275696)
>
> <small>十兆、百兆环境的双绞线8芯里实际通讯的是1236芯，其他四根是预留。1236芯里面，一对是发送信号，一对是接收信号。早期设备的网卡没有自适应的功能，所以必须按照要求使用网线。交叉线又叫对等线，就是两个相同的设备连接要用交叉线对等线，交叉线就是1和3 2和6对调一下，正好对调收发。具体怎么连呢？比如两台计算机之间，两台交换机之间，两台路由器之间都要用对等线。比如电脑和交换机之间，交换机和路由器之间用直通线。特别有一点是电脑和路由器要用对等线，也就是说网卡只有两种，路由器的和电脑的一样所以要用交叉线。</small>

1. 导向传输媒体

   导向传输媒体中，**电磁波**沿着固定媒体传播。

   1. 双绞线

      + 屏蔽双绞线STP（抗干扰性较无屏蔽双绞线UTP更强）
      + 无屏蔽双绞线UTP

   2. 同轴电缆

      + 50Ω同轴电缆，用于数字传输，由于多用于基带传输，也叫基带同轴电缆；
      + 75Ω同轴电缆，用于模拟传输，即宽带同轴电缆；

   3. 光缆

      + 单模光纤：只传输一种电磁波模式。
      + 多模光纤：可传输多个电磁波模式。

      实际上，单模光纤和多模光纤的不同点，即纤芯直径大小，**单模细、多模粗**。**在有线点视网络中使用的光纤全是单模光纤，其传播特性好，带宽可达10GHZ**，可以在一根光纤中传输60套PAL-D电视节目。

2. 非导向传输媒体

   <u>非导向传输媒体就是指自由空间，其中的==电磁波传输被称为无线传输==</u>。**无线传输所使用的频段很广**。

   + **短波通信主要是靠电离层的反射，但短波通道的通信质量较差**。*（毕竟靠的反射，肯定会有部分损耗掉了）*

   + **微波在空间主要是直线传播**。*（地球是圆的，多建几个很高的发送塔接收和发送微波就可以了）*
     + 地面微波接力通信
     + 卫星通信

3. 集线器Hub

   + 工作特点：在网络中只起到信号放大和重发的作用，目的是扩大网络的传输范围，不具备信号的定向发送能力。

     *假如ABCD连接Hub，那么A->B的数据，B、C、D都会收到。一方面阻塞其他主机的传输线路，一方面其他主机若主动抓包数据会导致信息泄露。如果集线器总带宽12M，那么这里ABCD平均带宽只有3M*

   + 最大传输距离：100m*（不同的型号不同）*

   + 集线器是一个大的冲突域
   
   > [网段--百度百科]([https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5](https://baike.baidu.com/item/网段))
   >
   > [中继器--百度百科]([https://baike.baidu.com/item/%E4%B8%AD%E7%BB%A7%E5%99%A8?sefr=cr](https://baike.baidu.com/item/中继器?sefr=cr))

### 2.4 ==信道复用==

> [为什么要使用信道复用技术，常用的信道复用技术有哪些](https://zhidao.baidu.com/question/165577074.html)
>
> <small>时分复用技术与频分复用技术一样，有着非常广泛的应用，电话就是其中最经典的例子，此外时分复用技术在广电也同样取得了广泛地应用，如SDH，ATM，IP和HFC网络中CM与CMTS的通信都是利用了时分复用的技术。</small>
>
> SDH技术可真正实现租用电路的[带宽](https://baike.baidu.com/item/带宽)保证，安全性方面也优于VPN等方式。
>
> 中国移动、电信、[联通](https://baike.baidu.com/item/联通)、广电等电信运营[商都](https://baike.baidu.com/item/商都)已经大规模建设了基于SDH的骨干[光传输](https://baike.baidu.com/item/光传输)网络。
>
> [比特同步--百度百科]([https://baike.baidu.com/item/%E6%AF%94%E7%89%B9%E5%90%8C%E6%AD%A5](https://baike.baidu.com/item/比特同步))
>
> <small>“比特同步”是数据通信中最基本的同步方式，又称“位同步”。</small>
>
> <small>比特是数据传输的最小单位。</small>
>
> <small>比特同步是指接收端时钟已经调整到和发送端时钟完全一样。</small>
>
> <small>比特同步的方法有外同步法和自同步法。</small>

1. #### 频分复用FDM(Frequency Division Multiplexing)

   ​	不同的基带模拟信号通过不同调制器（modulator）进行调制，调成高频信号后，和其他载波调制后的高频信号合并后传输。由于合并前，每个信号所使用的频带不同，获取方根据不同的调制器针对不同频带解调，既可获取之前传输的基带模拟信号。

   > 不同频段不同用户

2. #### 时分复用TDM(Time Division Multiplexing)

   时分复用是将时间划分成一段段**等长**的时分复用帧(TDM帧)。

   每一个时分复用的用户在每一个TDM帧中占用**固定序号**的时隙。

   每一个用户所占用的时隙**周期性**地出现（其周期就是TDM帧的长度对应的时间）

   TDM信号也称为等时(isochronous)信号。

   **时分复用的所有用户是在不同的时间占用同样的频带宽度**。*（可能会造成线路资源的浪费，因为即时某几个用户不交互数据了， 依旧占有时间片）*

   > 同一频段下，不同时间片不同用户

3. #### 统计时分复用STDM(Statistic TDM)

   > [统计时分多路复用]([https://baike.baidu.com/item/%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/16600620?fromtitle=STDM&fromid=5495477&fr=aladdin](https://baike.baidu.com/item/统计时分多路复用/16600620?fromtitle=STDM&fromid=5495477&fr=aladdin))

   根据用户实际需要动态分配线路资源的时分复用方法。只有当用户有数据要传输时才给他分配线路资源，当用户暂停发送数据时，不给他分配线路资源，线路的传输能力可以被其他用户使用。采用统计时分复用时，每个用户的数据传输速率可以高于平均速率，最高可达到线路总的传输能力。

4. #### 波分复用WDM(Wavelength Division Multiplexing)

   本质上就是光的频分复用。

5. #### 码分复用CDM(Code Division Multiplexing)

   常用的名次是码分多址CDMA(Code Division Multiplexing Access)。

   各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。

   这种系统发送的信息有**很强的抗干扰能力**，其频谱类似于白噪声，不易被敌人发现。

   **每一个比特时间划分为m个短的间隔，称为码片（chip）**。
   
   *（原本1bit数据0or1需要至少m个bit去表示。码分复用也是类似频分复用一样，多个用户只要码型不同，发送的数据叠加后在网络传输，也能再根据不同的码型还原回原本的数据）*

> [多址技术--百度百科]([https://baike.baidu.com/item/%E5%A4%9A%E5%9D%80%E6%8A%80%E6%9C%AF/2497170](https://baike.baidu.com/item/多址技术/2497170))
>
> 多址技术是指实现小区内多用户之间，小区内外多用户之间通信地址识别的技术。**多址技术多用于无线通信**。多址技术又称为多址接入技术。
>
> + 频分多址FDMA，早期移动通信采用，各个用户使用不同频率的频道进行通信（信道利用率低）。
> + 时分多址TDMA，现在的**移动通信系统**多数采用这种多址技术。
> + 码分多址CDMA，这种技术比较复杂，但现在已经为不少移动通信系统所采用。在第三代移动通信系统中，也采用宽带码分多址技术。（码分多址一般还会配合其他的一起用）
> + 空分多址SDMA，是一种信道增容的方式，可以实现频率的重复使用，有利于充分利用频率资源。空分多址还可以与其它多址方式相互兼容，从而实现组合的多址技术，例如“空分-码分多址（SD-CDMA）”。
>
> 时分多址是以不同时隙实现通信。码分多址是以不同的代码序列来实现通信的。空分多址是以不同方位信息实现多址通信的。

### 2.5 数据传输系统

脉码调制PCM体制最初是在电话局之间的中继线上传送多路电话。

由于历史上的原理，PCM有两个互不兼容的国际标准，北美的24路PCM（简称T1）和欧洲的30路PCM（简称E1）。我国采用欧洲E1标准。

E1速率2.048Mb/s，而T1速率是1.544Mb/s。

<u>当需要更高的速率时，可采用复用的方法。</u>

### 2.6 宽带接入技术

> [x数字用户线]([https://baike.baidu.com/item/x%E6%95%B0%E5%AD%97%E7%94%A8%E6%88%B7%E7%BA%BF/5929900?fromtitle=xDSL&fromid=10770830&fr=aladdin](https://baike.baidu.com/item/x数字用户线/5929900?fromtitle=xDSL&fromid=10770830&fr=aladdin))
>
> [SDH--百度百科](https://baike.baidu.com/item/SDH/413593)
>
> <small>SDH以其明显的优越性已成为[传输网](https://baike.baidu.com/item/传输网)发展的主流。SDH技术与一些先进技术相结合，如光波分复用（WDM）、[ATM技术](https://baike.baidu.com/item/ATM技术)、Internet技术（Packet over SDH）等，使SDH网络的作用越来越大。SDH已被各国列入21世纪高速[通信网](https://baike.baidu.com/item/通信网)的应用项目，是电信界公认的数字[传输网](https://baike.baidu.com/item/传输网)的发展方向，具有远大的商用前景。</small>

1. xDSL*（比如ADSL，拨号上网）*

   标准模拟电话信号的频带被限制在300~400Hz范围内，单用户线本身实际可通过的信号频率仍然超过1MHz。

   **xDSL技术把0~4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用**。

   *（0~4kHZ Voice，26~108kHz Upstream，138~1104kHz Downstream）*

2. HFC网采用结点体系结构（光纤同轴混合网HFC，Hybrid Fiber Coax）

   HFC网是目前覆盖面很广的有线电视网CATV的基础上开发的一种**居民宽带接入网**。

   HFC网除可传送CATV外，还提供电话、数据和其他宽带交互性业务。

   现有额CATV网是树形拓扑结构的同轴电缆网络，它采用**模拟技术的频分复用**对电视节目进行单向传输。而HFC网则需要对CATV网进行改造。

3. FTTx技术

   FFx（光纤到......）也是一种实现宽带居民接入网的方案。*（x可代表不同意思）*

   + 光纤到家（Fiber To The Home）：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法（155Mb/s）。
   + 光纤到大楼（Fiber To The Building）：光纤进入大楼后就转为电信号，然后用电缆或双绞线分配到各用户。
   + 光纤到路边（Fiber To The Curb）：从路边到各用户可使用星形结构双绞线作为传输媒体（155Mb/s）。

> [**遇到的真事，来看看ISP是如何克扣你的带宽的**](http://www.chinadsl.net/forum.php?mod=viewthread&tid=72099)
>
> ADSL（PPPoE验证）：最大下载速度=标称链路速率Kbps\*0.9\*0.95/8
> LAN等（PPPoE验证）：最大下载速度=标称链路速率Kbps\*0.95/8
>
> [运营商对带宽进行限制的原理是怎样的？](https://www.zhihu.com/question/19811707)
>
> [深入探讨网络带宽问题](https://zhuanlan.zhihu.com/p/22875995)
>
> <small>在思科的设备上，某些类型的端口（比如最常用的以太口）默认实际只能使用75%的带宽，剩下那25%是拿来给网络间的各种协议和设备间的通讯用的</small>
>
> [运营商和带宽的那些事](https://zhuanlan.zhihu.com/p/24938843)
>
> [上行宽带和下行宽带是什么意思](https://zhidao.baidu.com/question/145323421.html)
>
> [不懂就问：宽带选择](https://www.v2ex.com/t/600331)
>
> [让宽带翻倍--多拨](https://post.smzdm.com/p/adwnx7zx/)
>
> [家用宽带实现“一号多拨”进而“带宽叠加”](https://zhuanlan.zhihu.com/p/42431093)

## 3. 数据链路层

### 3.1 数据发送模型

主机H1 -------》（ 电话网）-------》路由器R1-------》（局域网）-------》路由器R2-------》（广域网）-------》路由器R3-------》（局域网）-------》主机H2

​	层次上看数据流动，那么只有主机H1和主机H2需要经过TCP/IP五层网络模型，而中间存储和转发的路由器R1~R3仅经过三层（物理层、数据链路层、网络层）

​	**在数据链路层，我们只关心数据帧的传输**，不关心下层物理层采用的传输介质是双绞线、同轴电缆、光纤还是其他，也不关心其信道复用技术采用的是频分多路复用FDM、时分复用TDM、统计时分复用STDM、波分复用WDM、码分多址CDMA还是其他。

### 3.2 数据链路层的信道类别

主要包括两种类别：

1. **点对点信道**：使用一对一的点对点通信方式。*(PPP协议)*
2. **广播信道**：使用一对多的广播通信方式，过程较复杂。广播信道上连接的主机很多，因此必须使用专用的<u>共享信道协议</u>来协调这些主机的数据发送。*(CSMA/CD协议)*

> [PPP （点对点协议(Point to Point Protocol)）--百度百科]([https://baike.baidu.com/item/PPP/6660214?fromtitle=PPP%E5%8D%8F%E8%AE%AE&fromid=1988803&fr=aladdin](https://baike.baidu.com/item/PPP/6660214?fromtitle=PPP协议&fromid=1988803&fr=aladdin))
>
> [CSMA/CD--百度百科](https://baike.baidu.com/item/CSMA%2FCD)

### 3.3 链路和数据链路

> [链路--百度百科]([https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF/9410314?fr=aladdin](https://baike.baidu.com/item/链路/9410314?fr=aladdin))
>
> 链路指无源的点到点的物理连接。
>
> 有线通信时，链路指两个节点之间的物理线路，如电缆或光纤。无线电通信时，链路指基站和终端之间传播电磁波的路径空间。水声通信时链路指换能器和水听器之间的传播声波的路径空间。

+ 链路（link）：是从一个结点到相邻结点的一段物理链路，中间没有任何其他的交换结点。

  *一条链路只是一条通路的一个组成部分。*

+ 数据链路（data link）：除了物理线路(链路)外，还必须有**通信协议**来控制这些数据的传输。若把实现这些协议的<u>硬件和软件</u>加到链路上，就构成了数据链路。

  *现最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。*

  *一般的适配器都包括了<u>数据链路层和物理层</u>这两层的功能。*

### 3.4 数据链路层传输数据--帧

> [帧 （网络术语，表示网络传输单位）--百度百科]([https://baike.baidu.com/item/%E5%B8%A7/23750184#viewPageContent](https://baike.baidu.com/item/帧/23750184#viewPageContent))
>
> 数据在网络上是以很小的称为帧（Frame）的单位传输的，帧由几部分组成，不同的部分执行不同的功能。在以太网数据传输中，节点在发送数据之后的一定时间内，由于传输的非实时性，存在着遭遇碰撞的可能。节点发送的帧很小且2个冲突节点相距很远。
>
> [MTU最大传输单元--百度百科]([https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83?fromtitle=mtu&fromid=508920](https://baike.baidu.com/item/最大传输单元?fromtitle=mtu&fromid=508920))
>
> [为什么最小帧长度是64字节](https://blog.csdn.net/jasonchen_gbd/article/details/80170309)
>
> [什么是MTU？为什么MTU值普遍都是1500？](https://blog.csdn.net/passionkk/article/details/100538418)

帧的组成大致如下：

```none
（帧头）（帧数据部分，受MTU限制大小<=1500字节【以太网标准】）（帧尾FCS）
```

*中间的帧数据部分，用于封装上层网络层的IP数据报（或其他网络层数据）。*

数据链路层数据帧传输时，向下至物理层，仍是以普通的数字信号（0101）的形式传输。*至于之后物理层是否转换数字信号为模拟信号，或者把基带信号载波调制成带通信号在高频段传输，信道复用技术采用哪种，无需数据链路层关心。*

### 3.5 数据链路层三大基本问题

1. **封装成帧**
2. **透明传输**
3. **差错检测**（差错控制）

*（现数据链路层一般仅进行差错检测，具体的差错控制->错误重传、纠错等，需要上层实现。主要是避免数据链路层过于臃肿，不利于后面的上层协议设计，且数据链路层要是自主“错误”地多次进行重传、纠错，容易拥塞网络。在某些情况下，数据链路层也提供纠错、重传机制，比如现代的**无线**通信，在链路层采用ARQ协议）*

#### 3.5.1 封装成帧

> [数据链路层的三个基本问题：封装成帧 透明传输 差错检测](https://blog.csdn.net/azsx02/article/details/69387317)

1. 概念：

+ 封装成帧（framing）就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。

  *（<u>帧头帧尾限界处的字节数据，通常是不可打印的控制字符</u>，尽可能地避免和帧数据部分的内容冲突。）*

  *（接收端数据链路层，根据首部和尾部的标记，从（物理层）比特流中识别帧的开始和结束。）*

+ 首部和尾部的一个重要作用就是进行帧定界。

  *（当然不止如此，不同的数据链路层协议的数据帧的帧头和帧尾的功能不尽相同，通常帧尾内还包括FCS，用于判别数据是否在传输时出现错误）*

2. 思考问题：

   如果帧未发送完，发送端除了问题，只能重发该帧。接收端却接受到了“半截子帧”，它回抛弃吗？为什么？

   答：**不管是接收到含有帧头（SOH）的前半部分“子帧”还是接受到含有帧尾（EOT）的后半部分“子帧”，由于不是一个完整的帧，数据链路层都会抛弃该帧。只有完整地含有帧头（SOH）帧尾（EOT）的帧，才会被保留。**

#### 3.5.2 透明传输

1. 问题

前面**封装成帧**说了，帧头帧尾是不可打印的字符，分别是帧头SOH和帧尾EOT。

+ 若传输的数据是ASCII码中的“可打印字符（共95个）”集时，帧头帧尾的识别不会出现问题。
+ 若传输的数据不是仅由“可打印字符”组成时，就会出现问题。

eg：`【帧头SOH】(帧数据部分....EOT.....)【帧尾EOT】 `该帧被接收端接收时，会将帧数据部分含有的`EOT`字符识别成帧尾，导致后面的所有数据被当作无效帧而丢弃。=> 接收端接收`【帧头SOH】....EOT`，舍弃`.....【帧尾EOT】`。

*（传输二进制数据，比如图片、影视等二进制文件时，就容易出现上述问题）*。

2. 解决方案

+ 字节填充法（byte stuffing）
+ 字符填充法（character stuffing）
+ 零比特填充法
+ ....

这里介绍**字节填充法**：

​	发送端的数据链路层在数据中出现控制字符`SOH`或者`EOT`的前面插入一个不可打印字符*（控制字符）*`ESC`（十六进制编码1B）。

​	*==字节填充==(byte stuffing)或==字符填充==(character stuffing)——**接收端的数据链路层在数据送回网络层之前删除之前插入的转换字符。***

​	如果转义字符也出现数据当中，那么应在转移字符之前插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。

eg：

`【帧头SOH】(原始数据...EOT...SOH...ECS.....SOH....)【帧尾EOT】`

经过**字节填充**后，预发送的数据如下：

`【帧头SOH】(原始数据...ESC EOT...ESC SOH...ESC ECS.....ESC SOH....)【帧尾EOT】`

#### 3.5.3 差错检测

> [BER （比特出错概率）--百度百科](https://baike.baidu.com/item/BER/20180314)
>
> [信噪比--百度百科]([https://baike.baidu.com/item/%E4%BF%A1%E5%99%AA%E6%AF%94](https://baike.baidu.com/item/信噪比))
>
> <small>狭义来讲是指放大器的输出信号的功率与同时输出的噪声功率的比，常常用分贝数表示，设备的信噪比越高表明它产生的噪声越少。一般来说，信噪比越大，说明混在信号里的噪声越小，声音回放的音质量越高，否则相反。信噪比一般不应该低于70dB，高保真音箱的信噪比应达到110dB以上。</small>

+ 概念

1. 帧在传输过程中，可能产生**比特差错**：1可能会变成0，而0也可能会变成1。*（根据前面物理层的知识，可以猜想是电压突然出现问题，或者高频信号在空气或其他介质中传输收到噪音干扰，等）*

2. 在一段时间内，传输错误的比特占所传输比特总数的比率称为**误码率**BER（Bit Error Rate）。

3. **<u>误码率与信噪比有很大的关系</u>**。*（信噪比SNR，SIGNAL-NOISE RATIO，物理层知识，S/N，S为信道内传输信号的平均功率，N为信道内部的高斯噪音功率，越高越好）*

4. 为了保证数据传输的**可靠性**（比如纠错，或者丢失重传等措施，这些实际由上层协议保证。），在计算机网络传输数据时，必须采用各种差错检测措施。

*（数据链路层只检查出错误帧并丢弃，不纠错，不重传。纠错和重传等其他动作，由上层协议实现。上层对被丢弃的帧无感知。）*

+ 应对手段

  **<u>在帧尾加入冗余校验码</u>FCS**。

  在数据链路层传送的帧中，广泛使用了**循环冗余检验CRC**技术。*(只是其中一种生成FCS的技术)*

  在发送端，先把数据划分为组。假定每组k个比特。假设带传送的一组数据M=101001（现在k=6）。我们在M的后面再添加供差错检测用的n位冗余码一起发送。

  *FSC( frame check sequence)帧检验序列的CRC计算方式*

  + 用二进制的模2运算进行2<sup>n</sup>乘M的运算，这相当于在M后面添加n个0。
  + 得到的（k+n）位的数除以事先选定好的长度为（n+1）位的除数P，得出商是Q而余数是R，余数R比除数P少1位，即R是n位。R就是CRC计算出来的FSC了。

  *（CRC的除数P和冗余码位数n由数据链路层协议商定，无需用户自己指定，理论上除数位数越多相对越可靠。大致知道计算方式即可）*

> [数据链路层的三个基本问题：封装成帧 透明传输 差错检测](https://blog.csdn.net/azsx02/article/details/69387317)
>
> 现实的通信链路都不会是理想的。传输过程中，1可能变成0, 0 可能变成1 。这就叫比特差错。——误码率。 误码率和信噪比有很大的关系。
>
> 因此，在计算机网络传输数据时，必须采用各种差错控制技术。目前在数据链路层广泛使用了循环冗余检验（CRC）的检错技术。
>
> 在数据链路层的CRC检验都是用**硬件**完成的，处理很迅速，因此不会延误数据的传输。
>
> 为什么数据链路层要以帧为单位来传送数据呢？因为如果不以帧为单位，就无法加入冗余码来进行差错检验。
>
> 传输差错分为两类：一类就是前面所说的最基本的比特差错。第二类：收到的帧出现了帧丢失、帧重复和帧失序。（停止等待协议，ARQ）。
>
> 数据链路层并不需要给网络层提供“可靠传输”的服务。<u>过去OSI的观点是：必须让数据链路层向上提供可靠传输。因此在CRC的基础上，增加了帧编号、确认和重传机制。</u>
>
> <u>而现在的互联网采用了区别对待的方法：</u>
>
> <u>对于通信质量良好的**有线**传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的TCP协议）来完成。</u>
>
> <u>对于通信质量较差的**无线**传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</u>

> [ARQ--百度百科](https://baike.baidu.com/item/ARQ/7402812?fr=aladdin)
>
> 自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中[数据链路层](https://baike.baidu.com/item/数据链路层/4329290)的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制。
>
> 传统[自动重传请求](https://baike.baidu.com/item/自动重传请求)分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。后两种协议是[滑动窗口](https://baike.baidu.com/item/滑动窗口)技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为[连续ARQ协议](https://baike.baidu.com/item/连续ARQ协议)。三者的区别在于对于出错的数据[报文](https://baike.baidu.com/item/报文)的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。除了传统的ARQ，还有混合ARQ（Hybrid-ARQ）。
>
> 在现代的无线通信中，ARQ主要应用在**无线**链路层。比如，在WCDMA和cdma2000无线通信中都采用了选择性重传ARQ和混合ARQ。
>
> 优点：比较简单 。因而被广泛的应用在[分组交换](https://baike.baidu.com/item/分组交换)网络中。
>
> 缺点：1.通信信道的利用率不高，也就是说，信道还远远没有被数据比特填满。2.是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送[数据包](https://baike.baidu.com/item/数据包)来纠正错误的方法也严重的影响了它的传输速度。

+ 帧检验序列FCS

  在数据后面添加上的冗余码称为**帧检验序列FCS**（Frame Check Sequence）。

  **循环冗余检验CRC（Cyclic Redundancy Check）和帧检验序列FCS并不等同**。

  + CRC是一种常用的**检错方法**，而FCS是添加在数据后面的冗余码。*（只检错，不纠错也不重传）*
  + FCS可以用CRC这种方法得出，但CRC并非是获得FCS唯一方法。

+ 小结：CRC差错检验技术*（其实前面也都讲得很详细了，这里就再总结一下）*

  仅用循环冗余检验CRC差错检测技术只能做到**无差错接受**（accept）。

  + “无差错接受”：“凡是接收到的帧（即不包括被丢弃的帧），我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。也就是“接收端数据链路层接收到的帧都没有传输差错（有差错的帧就丢弃，不接收了）”。

    *（当然这个只是理想情况，实际就算加了FCS字段，出现数据错误时也可能正好接收端FCS检验计算出来余数也是0-->0表示数据无出错，只不过概率很小。）*

  **要做到“可靠传输”（即发送什么就收到什么），就必须再加上确认和重传机制。**

  + 考虑：帧重复、帧丢失、帧乱序的情况

  **可以说“CRC是一种<u>无比特差错</u>，而不是<u>无传输差错</u>的检验机制”，**

  *（OSI/RM模型的观点：数据链路层要做到无传输差错。）<u>实际上，无线传输时就会考虑在数据链路层实现无传输差错，而有线传输通常只做到无比特差错。</u>*

### 3.6 PPP点对点协议(Point to Point Protocol)

> [PPP点对点协议(Point to Point Protocol)--百度百科](https://baike.baidu.com/item/PPP/6660214#viewPageContent)
>
> 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接（底层up）。PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。
>
> 这些分组及其响应选择一些 PPP 参数，和进行网络层配置（此前如有PAP或CHAP验证先要通过验证），NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。
>
> 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。

#### 3.6.1 PPP概述

> [为什么访问某个网站（公网），wireshark抓包看不到以太帧里的ppp报文？](https://bbs.51cto.com/thread-1318487-1-1.html)
>
> [想看看ppp协议 , 怎么用wireshark抓?](https://www.zhihu.com/question/365438716?sort=created)
>
> <small>PPP帧一般用于广域网，在以太网环境直接抓包抓不到，一般在路由器要发送数据到其他路由上（ISP提供的节点）就自动封装成PPP帧再向外传输。所以要抓包PPP帧，得连线路由器，抓包路由器上的数据。</small>

现在全世界使用得最多的数据链路层协议，是点对点协议PPP（Point to Point Protocol）。

<u>用户使用拨号电话线接入**因特网**时，一般都是使用PPP协议</u>。

*（补充下，前面物理层的ADSL早期也是用电话线上网，但是能够同时上网和讲电话（频段/频谱不同）；而更早的拨号上网，如果打电话就不能上网，上网就不能打电话，会占用电话线。）*

#### 3.6.2 PPP协议应该满足的要求

> [简述ppp协议在进行同步传输喝异步传输时分别采用什么方法保证透明传输](https://zhidao.baidu.com/question/210995037.html)
>
> 异步传输使用字节填充方法，同步传输使用零比特填充方法

+ 简单——这是首要的要求
+ 封装成帧*（注意MTU限制）*
+ 透明性*（透明传输，帧定界判别问题；异步线路用字节填充，同步线路用零比特填充）*
+ 多种网络层协议*（会标识传输的帧数据部分是IP数据报、安全性认证PAP或者其他...）*
+ 多种类型链路*（物理层兼容，光纤、同轴电缆、双绞线等）*
+ 差错检测*（确保无差错接收，CRC等技术）*
+ 检测连接状态*（比如拨号上网，返回各种网络状态信息）*

+ 最大传输单元*（MTU，以太网的标准是<=1500Byte）*

+ 网络层地址协商*（比如拨号上网后，分配IP地址）*
+ 数据压缩协商*（比如多个0或者多个1协商怎么简写表示，然后接收后再还原）*

#### 3.6.3 PPP协议不需要满足的要求

+ 纠错
+ 流量控制
+ 序号
+ 多点线路
+ 半双工或单工链路

#### 3.6.4 PPP协议的组成

```none
3| 上层协议(如IP、IPX、AppleTalk)
-
 | 网络控制协议NCP(针对每一个网络层协议)
2| 链路控制协议LCP
 | 高级数据链路控制协议HDLC(并不是PPP的组成部分，和PPP同样是数据链路层协议)
-
1| 物理层(如 EIA/TIA-232、V.24、V.35 ISDN)
```

+ 数据链路层协议可以用于异步串行或同步串行介质
+ 它使用LCP（链路控制协议）建立并维护数据链路连接
+ 网络控制协议NCP允许在点到点连接上使用多种网络层协议

*（比如ADSL拨号上网，只有LCP身份认证通过了，才能到NCP放行网络层，给你分配IP）*

> [HDLC协议--百度百科]([https://baike.baidu.com/item/HDLC%E5%8D%8F%E8%AE%AE/9441935?fr=aladdin](https://baike.baidu.com/item/HDLC协议/9441935?fr=aladdin))
>
> HDLC协议使用统一的帧格式，运用方便；采用<u>零比特插入法</u>，易于硬件实现，且支持任意的位流传输，实现信息的透明传输；<u>全双工</u>通信，[吞吐率](https://baike.baidu.com/item/吞吐率/1555673)高，在未收到应答帧的情况下，可连续发送信息帧，提高数据链路传输的效率；采用CRC帧校验序列，可防止漏帧，提高信息传输的可靠性。 
>
> 主要有四个特点：
>
> 1·对于任何一种比特流都可透明传输。
>
> 2·较高的数据链路传输效率。
>
> 3·所有的帧都有帧校验序列（[FCS](https://baike.baidu.com/item/FCS/22504028)），传输可靠性高。
>
> 4·用统一的帧格式来实现传输。

#### 3.6.5 PPP协议帧格式

> [PPP点对点协议(Point to Point Protocol)--百度百科](https://baike.baidu.com/item/PPP/6660214#viewPageContent)
>
> PPP采用7EH作为一帧的开始和结束标志（F）；其中地址域（A）和控制域（C）取固定值（A=FFH，C=03H） ；协议域（两个字节）取0021H表示IP分组，取8021H表示网络控制数据，取C021H表示链路控制数据；帧校验域（FCS）也为两个字节，它用于对信息域的校验。若信息域中出现7EH，则转换为（7DH，5EH）两个字符。当信息域出现7DH时，则转换为（7DH，5DH）。当信息流中出现ASCII码的控制字符（即小于20H），即在该字符前加入一个7DH字符。

|      | F(7E) | A(FF) | C(03) | 协议 | 信息部分 | FCS  | F(7E) |
| ---- | ----- | ----- | ----- | ---- | -------- | ---- | ----- |
| 字节 | 1     | 1     | 1     | 2    | <=1500   | 2    | 1     |

*（地址域A取固定值FF很好理解，因为是点到点协议，所以A->B不会出现A->C的情况，链路两端的地址是固定的，没必要特地标识）*

协议字段：

| 字节数据 | 表示类型                  |
| -------- | ------------------------- |
| 0x0021   | PPP帧的信息字段，IP数据报 |
| 0xC021   | 信息字段是PPP链路控制数据 |
| 0x8021   | 表示这是网络控制数据      |
| 0xC023   | 信息字段是安全性认证PAP   |
| 0xC025   | 信息字段是LQR             |
| 0xC223   | 信息字段是安全性认证CHAP  |

#### 3.6.6 PPP的透明传输

1. **字节填充**

   问题：信息字段中出现标志字段的值，可能被误认为是“标志字段”，如何处理？

   + 将信息字段中出现的每个0x7E字节转变成2字节序列（0x7D，0x5E）
   + 若信息字段中出现一个0x7D的字节，则将其转变成2字节序列（0x7D，0x5D）
   + 若信息字段中出现ASCII码的控制字符（即数值小于0x20的字符），则在该字段前面要假如一个0x7D字节，同时将该字符的编码加以改变。

2. **零比特填充方法**

   > [零比特填充法--百度百科]([https://baike.baidu.com/item/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95](https://baike.baidu.com/item/零比特填充法))

   PPP协议用在SONET/SDH链路时，是使用同步传输（一连串的比特连续传送）。这时PPP协议采用**零比特填充法**实现透明传输。

   在发送端，只要发现有5个连续1，则立即填入一个0。接收端对帧中的比特进行扫描。每当发现5个连续的1时，就把这5个连续1后的一个0删除。

*字节填充针对传输字节的情况，零比特填充针对传输比特的情况。*

> [SONET和SDH技术简介](https://blog.csdn.net/weixin_43751619/article/details/85008395)
>
> [SONET/SDH--百度百科](https://baike.baidu.com/item/SONET%2FSDH/2231992)
>
> [SONET--百度百科](https://baike.baidu.com/item/SONET/2440753?fr=aladdin)
>
> [SONET/SDH](https://www.jianshu.com/p/9bb81ff4a2ff)
>
> 简言之，即光同步数字传输网，定义了一组在光纤上传输光信号的速率和格式。

#### 3.6.7 PPP不使用序号和确认机制

​	PPP协议之所以不使用序号和确认机制时出于一下的考虑：

+ 在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理。
+ 在**因特网**环境下，PPP的信息字段放入的数据是IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。
+ 帧检验序列FCS字段可保证无差错接受。

#### 3.6.8 PPP协议的工作状态

​	当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。

​	PC机向路由器发送一系列的LCP分组（封装成多个PPP帧）。*(LCP进行身份校验)*

​	<u>这些分组及其响应选择一些PPP参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。</u>

​	<u>通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。</u>

> [IPCP--百度百科](https://baike.baidu.com/item/IPCP/11049069?fr=aladdin)
>
> [NCP是什么意思？](https://zhidao.baidu.com/question/583045569.html)
>
> [我想问一下，IP地址不是固定的吗，为什么说是网络控制协议NCP临时分配的呢？](https://zhidao.baidu.com/question/2272939370381570788.html)
>
> [TCP/IP：PPP点对点协议中的NCP是干什么用的](https://zhidao.baidu.com/question/258496531.html)
>
> 因特网是由大量的异构网络通过路由器相互连接起来的。而你说的网络层是指的我们用的最多的以太网的网络层，它主要运行IP协议。路由器可以连接不同的网络，即支持不同的网络层协议。所以**PPP链路的两端的NCP根据网络层的不同协议互相交换网络层特定的网络控制分组**。总之，<u>PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PPP协议进行通信</u>。
> 如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块（如分配IP地址）时就要使用NCP中支持IP的协议——IP控制协议**IPCP**(IP Control Protocol)。IPCP分组也封装成PPP帧在PPP链路上传送。

#### 3.6.9 PPP应用举例(cisco packet tracer模拟)

> [PPPoE报文格式及交互详解](https://blog.csdn.net/xinyuan510214/article/details/79635015)

```none
Router1:
	hostname router1
	username router2 password xxx
	interface Serial0
	ip address 192.168.16.1 255.255.255.0
	clockrate 1000000
	ppp authentication chap

Router2:
	hostname router2
	username router1 password xxx
	interface Serial0
	ip address 192.168.16.2 255.255.255.0
	ppp authentication chap
```

#### 3.6.10 PPPoE

> [PPPOE--百度百科](https://baike.baidu.com/item/PPPOE/139247?fr=aladdin)
>
> **PPPoE**（英语：Point-to-Point Protocol Over Ethernet），[以太网](https://baike.baidu.com/item/以太网)上的点对点协议，是将[点对点协议](https://baike.baidu.com/item/点对点协议)（PPP）封装在[以太网](https://baike.baidu.com/item/以太网)（Ethernet）框架中的一种网络隧道协议。由于协议中集成PPP协议，所以实现出传统[以太网](https://baike.baidu.com/item/以太网)不能提供的[身份验证](https://baike.baidu.com/item/身份验证)、[加密](https://baike.baidu.com/item/加密)以及[压缩](https://baike.baidu.com/item/压缩)等功能，也可用于缆线调制解调器（cable modem）和[数字用户线路](https://baike.baidu.com/item/数字用户线路)（DSL）等以[以太网](https://baike.baidu.com/item/以太网)协议向用户提供接入服务的协议体系。

使用时的**缺点**：

1. **使用Internet前，需先透过PPPoE进行拨接，而非计算机引导后立即上网。**（引导后立即上网，详见[DHCP](https://baike.baidu.com/item/DHCP)，有些ISP有提供第1台PC自DHCP获取固定IP）
2. 部分[ISP](https://baike.baidu.com/item/ISP)会对PPPoE的连线用户采取定时断线，以节省营运成本及IP地址的占用，故对于需长时间挂网的用户较不利。但也有部分ISP为提供用户选择PPPoE可发配非固定IP或固定IP的服务。
3. 目前[Windows XP](https://baike.baidu.com/item/Windows XP)之后的[Windows](https://baike.baidu.com/item/Windows)，[Mac OS X](https://baike.baidu.com/item/Mac OS X)、[Linux](https://baike.baidu.com/item/Linux)等操作系统等皆已内置PPPoE的拨接功能，更早期的操作系统需另行安装PPPoE的拨接程序，如Enternet 300、RAS PPPoE等。

发展前景：

​	PPPoE是从窄带技术演化而来，**PPP最早就是专门为电话线上网而设计的**，当宽带普及后，为了兼容以前的电话线用户习惯，故在宽带网络中继承了PPP技术。**PPPoE是一种过渡技术，目前已经基本处于淘汰阶段**。原因如下：
　　1、PPPoE是一种2层链路技术，正常下无法穿透三层交换机，若要在三层交换机传输，就必须做trunk，即把三层当作二层交换机使用。这导致不能充分发挥三层交换机的潜能，三层交换机的很多高级功能都无法使用，从而浪费了宝贵的网络设备资源。也给整体网络规划造成了一定的复杂性。**如果一开始采用了PPPoE认证，那么以后想要使用三层交换机网络规划功能，调整整体网络，那么将是一个巨大的工作量。**
　　2、**宽带使用PPPoE方式，将造成不必要的带宽损耗，而且上网速度比正常宽带速度要慢一个级别**。原因是采用PPPoE比正常宽带包，多了2个协议层，一个是PPPoE协议层，另一个就是PPP协议层，这几个协议层头会增加到正常数据包头部里，在传输数据过程中，多出了不少额外数据，拨号握手过程也比正常多了好几个步骤。
　　3、2004年开始，ARP攻击在网络流行时，PPPoE由于自身与ARP无关的特点，使其具有天然免疫优势，所以，当时很多场合对PPPoE有较高的需求。
　　但经过近10年网络发展，随着各种安全软件普及，如360、电脑管家、以及各种杀毒软件等都早已具有防止ARP攻击功能。因此，ARP攻击已经彻底消失殆尽。PPPoE的各种缺点已经越来越不适应宽带网络的发展。
　　4、**PPPoE客户端一般都会采用操作系统自带的PPPoE，但设置比较麻烦，有很多步骤，普通家庭用户若不熟悉，大多数根本搞不定，此时维护人员必须挨家挨户进行上门设置，这给网络维护带来了很大工作量**。非常不利宽带网络用户的发展和运营，将经常接到用户关于PPPoE的使用投诉。
　　5、PPPoE的效率比较低，从PPPoE协议模型可以看出，BAS汇聚了用户的所有数据流，它必须将每一个PPPoE包都拆开检查处理，这在很大程度上是沿袭了传统的PPP处理的方式，一旦用户很多，数据包数量很大，解封装速度就需要很快，BAS很大的精力花在检测用户的数据包上，容易形成接入的“瓶颈”。
　　6、PPPoE由于采用了二层链路方式，所以在防止ARP三层包攻击方式具有很大安全性，但**PPPoE自身却存在着协议不安全性，因为PPPoE认证是采用广播方式，在网段内只要装个网络嗅探器，都能截获到PPPoE包，并能做任意修改重定向**。关于PPPoE安全漏洞详细描述见最后参考资料《PPPoE验证缺陷所带来的危害》

> [PPP方式是何种上网方式？](https://zhidao.baidu.com/question/8513222.html?qbl=relate_question_0&word=PPP%BA%CDADSL)
>
> [ppp协议和adsl怎样实现上网](https://zhidao.baidu.com/question/1769095541273979180.html)
>
> 通过ADSL方式上网的计算机大都是通过以太网卡（Ethernet）与互联网相连的。同样使用的还是普通的TCP/IP方式，并没有附加新的协议。另外一方面，调制解调器的拨号上网，使用的是PPP协议，即Point to Point Protocol，点到点协议，该协议具有用户认证及通知IP地址的功能。PPP over Ethernet（PPPoE）协议，是在以太网络中转播PPP帧信息的技术，尤其适用于ADSL等方式。
>
> [ADSL与PPPOE的区别](https://zhidao.baidu.com/question/2201578230052978748.html)
>
> [PPPOE 详解](https://blog.csdn.net/u011857683/article/details/84703669)
>
> [vBRAS技术介绍及运营商网络部署](https://baijiahao.baidu.com/s?id=1662011320646541735&wfr=spider&for=pc)

### 3.7 局域网

#### 3.7.1 局域网的拓扑结构

+ 星形网
+ 总线网*（最早的以太网Ethernet正是这种）*
+ 环形网*(骨干网络用得多，现局域网用得少)*
+ 树形网
+ ...

> [局域网拓扑结构-百度百科]([https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/10183336?fr=aladdin](https://baike.baidu.com/item/局域网拓扑结构/10183336?fr=aladdin))

#### 3.7.2 局域网的特点和优点

​	*局域网最主要的特点是：网络作为一个单位所拥有，且地理范围和站点数量均有限。*

​	局域网具有如下的一些主要优点：

+ 具有==广播功能==，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。
+ 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。
+ 提高了系统的可靠性、可用性和生存性。

*（广域网肯定就不广播了，不然要是大家都广播，带宽就被占满了。不过也有黑客用DOS或者DDOS强行占满攻击目标的带宽，使攻击目标网络瘫痪或者无法正常处理请求。）*

#### 3.7.3 局域网通信媒体

1. 静态划分通道（物理层）

   *（如果不借助设备而是网管协商并设置不现实，因为繁琐，且经常需要变动。所以局域网的网线一般用不到以下技术）*

   + 频分复用-FDM
   + 时分复用-TDM
   + 波分复用-WDM
   + 码分复用-CDMA

2. 动态媒体接入控制（多点接入）
   + **随机接入**（主要被以太网采用）*（不需要手动配置一堆东西）*
   + 受控接入，如多点线路探寻（polling）或轮询。（目前已不再被采用）

#### 3.7.4 早期以太网

​	最初的以太网是将多计算机都连接到一根总线上。当初认为这样的连接方式既简单又可靠，因为总线上没有源器件。

<small>*（连接总线的主机通信时占用整个线路，单通道，不存在使用信道复用技术）*</small>

​	比如总线上连接A、B、C、D四台主机，某一时刻A->B发送数据，此时总线上的每一个工作的计算机（除A自己）都能检测到A发送的数据信号。由于只有计算机B的地址与数据帧首部写入的地址一致，因此只有B接收这个数据帧。

<small>*（其他的主机其实也接收到数据帧了，不过判断目的地址与自己不同，就丢弃了。所以如果在这里强行抓包，是可以获取到数据的-->存在数据泄露的安全问题）*</small>

​	**具有广播特性的总线上实现了一对一的通信**。

<small>*（其实就是，不管谁发数据，总线上都广播该数据，霸占整个线路。早期这种）*</small>

### 3.8 载波监听多点接入/碰撞检测--以太网使用CSMA/CD协议

> [现代的以太网适配器还实现CSMA/CD协议吗？](https://www.zhihu.com/question/26701425?sort=created)
>
> <small>10BASE-T、100BASE-TX 和 1000BASE-T 双绞线以太网依然适用 CSMA/CD，不过 100BASE-TX 及以上非全交换网络的可靠性几乎是 0，一般以全交换形式组网用不到 CSMA/CD 罢了。10GBASE-T及以上，以及光纤以太网均不适用 CSMA/CD。</small>
>
> <small>若在1000Mbps网络中，直接是采用全双工的机制，而不好采用CSMA/CD的机制，在协议这一块就对1000Mbps以上的网络其CSMA/CD的机制就没有支持好。主要原因是，在1000Mbps的网络中，不好定义网络的最小时隙，从而节点无法很好的完成信道捕获的工作(比如交换机需要时间清理缓存，腾出空间接收数据帧之类的)。</small>
>
> [对于早已抛弃CSMA/CD的千兆以太网，甚至万兆以太网，以太网最小帧还有什么意义？](https://www.zhihu.com/question/372079821)
>
> **1000Mbps半双工还是采用CSMA/CD（即还能用集线器Hub），1000Mbps全双工模式则抛弃CSMA/CD。**
>
> **而万兆彻底抛弃CSMA/CD，只能全双工，只能用交换机switch，不可能有集线器Hub。**

 	CSMA/CD（Carrier Sence Multiple Access with Collision Detection）。

+ **"多点接入"表示许多计算机以多点接入的方式连接在一根总线上。**

+ **"载波监听"是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免碰撞。**

+ **"碰撞检测"就是用电子技术检测总线上有没有其他计算机发送的数据信号。**

<small>*（前面点到点通信用的PPP协议，这里局域网广播则用CSMA/CD协议。）*</small>

<small>*（前面物理层的香农公式可知，要是数据碰撞了，可理解为发送中的数据遭到了噪音，那么对数据最后的转换会造成干扰。在单信道传输情况下，总线广播必须避免碰撞，碰撞上了谁的数据也别指望能被识别成功。）*</small>

#### 3.8.1 碰撞检测

​	**"碰撞检测"即计算机边发数据边检测信道上的信号电压大小。**

+ 当几个站同时在总线上发送数据时，总线上的信号摆动肢将会增大（互相叠加）。
+ 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了**碰撞**。
+ 所谓"碰撞"就是发生了冲突。因此<u>"碰撞检测"也被称为"冲突检测"</u>。

​	**检测到碰撞后**

+ <u>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</u>
+ <u>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</u>

*<small>（这里说遇到碰撞后随机事件后再次发送，其实也不完全算随机，有一定的计算公式，后面会提及具体算法。**二进制指数退避算法**）</small>*

> [二进制指数退避算法--百度百科]([https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95/3405081?fr=aladdin](https://baike.baidu.com/item/二进制指数退避算法/3405081?fr=aladdin))

####  3.8.2 CSMA/CD重要特性

​	使用CSMA/CD协议的以太网**不能进行全双工通信**，只能进行双向交替通信（**半双工通信**）。

​	<small>*（因为通信占用整个信道，且广播发送。）*</small>

​	<small>每个站在发送数据之后的一小段时间内，存在遭遇碰撞的可能性。这种发送的不确定性使得整个以太网的平均通信量远小于以太网的最高数据率。</small>

#### 3.8.3 争用期和最短有效帧长

​	**最先发送数据帧的站点，在发送数据帧后至多经过`2τ`（`传播时延*2`）就可以知道发送的数据帧是否遭到了碰撞**。

+ 以太网的争用期
  + 以太网的端到端往返时延`2τ`称为**争用期**（碰撞窗口）。通常取**51.2μs**作为争用期的长度。
  + 对于10Mb/s以太网，争用期内可发送512bit，即64字节。
  + **以太网在发送数据时，若前64字节未发生冲突，则后续的数据就不会发生冲突**。

+ 最短有效帧长

  + 如果发生冲突，就一定是在发送前64字节之内。
  + 由于一检测到冲突就立即中止发送，<u>这时已经发送出去的数据一定小于64字节</u>。

  + 以太网规定了最短有效帧长为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。

> 应该有不少好奇宝宝想知道这个**51.2μs**到底怎么计算来的
>
> [在传统以太网中,为什么要有最小帧长度和最大帧长度的限制?](https://www.cnblogs.com/yhl1234/archive/2009/02/03/1192085.html)
>
> [为什么最小帧长度是64字节](http://blog.sina.com.cn/s/blog_7d84d0d20101216d.html)
>
> [搞懂CSMA/CD，你就明白为什么以太网最小帧是64字节。](http://blog.sina.com.cn/s/blog_6bc2727c0102w9mi.html)
>
> [为什么以太网把争用期定为51.2us?](https://zhidao.baidu.com/question/526084236219275325.html)
>
> [对于早已抛弃CSMA/CD的千兆以太网，甚至万兆以太网，以太网最小帧还有什么意义？](https://www.zhihu.com/question/372079821)

#### 3.8.4 ==二进制指数类型退避算法==

​	发生碰撞的站点在停止发送数据后，要推迟（退避）一个随机时间，然后再重新发送数据。

+ 确定**基本退避时间**，一般是取为争用期**`2τ`**

+ 定义参数`k`
  $$
  k = Min[重传次数，10]
  $$
  
+ 从整数集合\[0，1，......，（2<sup>k</sup>-1）\]中随机取一个数，记为`г`。**重传所需的时延就是`г`倍的基本退避时间**。

+ 当**重传达到16次仍不能成功时，即丢弃该帧**，并向高层报告。

*(无需用户参与，二进制指数避让算法由CSMA/CD协议实现，也就是我们直接使用具体的设备就好了。)*

> [二进制指数退避算法--百度百科]([https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95/3405081?fr=aladdin](https://baike.baidu.com/item/二进制指数退避算法/3405081?fr=aladdin))

### 3.9 以太网

#### 3.9.1 以太网的两个标准

> [以太网标准--百度百科]([https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A0%87%E5%87%86/21570982?fr=aladdin](https://baike.baidu.com/item/以太网标准/21570982?fr=aladdin))
>
> 为了使网络系统中的软硬件设备不受生产厂家和型号等不同的限制，制定了各种各样的标准来保证他们之间的相互通，以太网标准就是其中之一。
>
> 以太网标准即以太网规定的包括物理层的连线、电信号和介质访问层协议的内容。

+ DIX Ethernet V2是世界上第一个局域网产品（以太网）的规约。

+ IEEE的802.3标准

  <small>DIX Ethernet V2标准与IEEE的802.3标准只有很小的差别，因此可以将802.3局域网简称为“以太网”。严格来说，"以太网"应当是指符合DIX Ethernet V2 标准的局域网。</small>

#### 3.9.2 以太网与数据链路层的两个子层

​	为了让数据链路层能更好地适应多种局域网标准呢，802委员会局域网的数据链路层拆分成两个子层：

+ 逻辑链路控制LLC（Logical Link Control）子层<small>*（基本弃用了，有些设备压根就不带这个了）*</small>
+ **媒体接入控制==MAC==（Medium Access Control）子层**

​	*与接入到传输媒体有关的内容基本都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。*

​	*由于TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网，因此现在802委员会制定的逻辑链路控制子层LLC（即802.2标准）的作用已经不大了。*

​	*<u>很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议。</u>*	

#### 3.9.3 以太网提供的服务

*以太网提供的服务是不可靠的交付，即尽最大努力的交付。*

*当接收站受到有差错的数据帧时就丢弃此帧，其他什么也不做。差错纠正由高层来决定。*

*如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。*

概述如下：

+ 服务不可靠
+ 差错帧丢弃，纠错由高层实现
+ 重传数据帧和普通数据帧格式相同

> 实际上，数据链路层也存在支持差错重传的协议，比如ARQ
>
> [ARQ--百度百科](https://baike.baidu.com/item/ARQ/7402812?fr=aladdin)
>
> + 停等式ARQ	
> + 回退n帧的ARQ
> + 选择性重传ARQ
> + 混合ARQ
>
> **在现代的无线通信中，ARQ主要应用在无线链路层**。比如，在WCDMA和cdma2000无线通信中都采用了选择性重传ARQ和混合ARQ。
>
> 优点：比较简单 。因而被广泛的应用在[分组交换](https://baike.baidu.com/item/分组交换)网络中。
>
> 缺点：1.通信信道的利用率不高，也就是说，信道还远远没有被数据比特填满。2.是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送[数据包](https://baike.baidu.com/item/数据包)来纠正错误的方法也严重的影响了它的传输速度。

#### 3.9.4 利用集线器Hub组成以太网

​	*传统（早期）以太网最初是使用粗同轴电缆，后来演变到使用便宜的同轴电缆。再后来发展为使用更便宜和更灵活的双绞线。不用电缆而使用无屏蔽双绞线。*

​	*每个站需要采用两队双绞线，分别用于发送和接收。*

​	*这种以太网采用星形拓扑，在星形的中心则添加一种可靠性非常高的设备叫作集线器（Hub）*

使用集线器Hub<small>（物理层设备）</small>组织的以太网，就是一个冲突域。*（现在这种方式基本弃用了）*

#### 3.9.5 集线器的Hub一些特点

​	集线器是使用电子器件来<u>模拟实际电缆线</u>的工作，因此整个系统仍然像一个传统的以太网那样运行。*集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。*

​	**使用集线器的以太网在逻辑上仍然是一个总线网，各工作站使用的还是CSMA/CD协议，并共享逻辑上的总线**。

​	集线器很像一个多接口的转发器，工作在物理层。

*（集线器Hub没啥智商，受到流进某一接口的数据，就直接往集线器的其他Hub接口广播发送）*

#### 3.9.6 常见以太网标准(网线)

> [以太网标准--百度百科]([https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A0%87%E5%87%86/21570982?fr=aladdin#3](https://baike.baidu.com/item/以太网标准/21570982?fr=aladdin#3))

**10BASE-T**的通信距离稍短，每个站到集线器的距离不超过**100m**，这种`10Mb/s`速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。

**10BASE-T**双绞线以太网的出现，是局域网发展史上一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。

#### 3.9.7 以太网的信道利用率

​	以太网的信道被占用的情况：

​	争用期长度为`2τ`，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。

​	帧长为L（bit），数据发送速率为C（b/s），因此帧的发送时间为L/C = T<sub>0</sub>（s）。

​	**一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到<u>发送成功且信道转为空闲</u>（即再经过时间`τ`使得信道上无信号在传播）时为止，是==发送一帧==所需的平均时间。**

``` none
|--------------- 发生碰撞 ---------------|++++++++ 占用期 ++++++++|
| 争用期 | 争用期 | 争用期...争用期 | 争用期| ......发送成功........  |
|  2τ   |  2τ   |  2τ  ...  2τ  |  2τ  | \\\\\\T0\\\\\\\\\\\  τ |
```

> 回顾之前网络概述，提到过计算机网络的时延，包括4部分：发送时延、传播时延、处理时延、排队时延。
>
> [发送时延--百度百科]([https://baike.baidu.com/item/%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6/10411985?fr=aladdin](https://baike.baidu.com/item/发送时延/10411985?fr=aladdin))

#### 3.9.8 以太网的信道利用率：参数а

​	要提高以太网的通信利用率，就必须减小`τ`<small>（传播时延）</small>与`T0`<small>(发送时延)</small>之比。在以太网中定义了参数`а`，它是以太网单程端到端时延`τ`与帧的发送时间`T0`之比：
$$
а=\frac{τ}{T_0}
$$

+ `a`—>0表示一发生碰撞就可以立即检测出来，并立即停止发送，因而信道利用率很高。
+ `a`越大，表明争用期所占比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。 

**对以太网参数的要求**

+ 当数据率一定时，以太网的连线的长度受到限制，否则`τ`的数值会太大。
+ 以太网的帧长不能太短，否则`T0`的值会太小，使`a`值太大。

**信道利用率的最大值**

+ 在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一站立即发送数据。

+ 发送一帧占用线路的时间是`T0+τ`<small>(也就是前面提到的发送成功且线路恢复空闲的所需时间)</small>，而帧本身的发送时间是`T0`。于是我们可以计算出**理想情况下的极限信道利用率S<sub>max</sub>为**：
  $$
  Smax =\frac{T_0}{T_0+τ}=\frac{1}{1+a}
  $$

### 3.10 MAC

#### 3.10.1 MAC层的硬件地址(MAC地址)

> [802.3帧和Ethernet II帧](http://blog.sina.com.cn/s/blog_eb8b39050102wi7f.html)

<small>前面3.9.2介绍过，以太网802委员会将数据链路层拆分成两层逻辑链路控制子层LLC和媒体接入控制子层MAC。前者LLC现在基本弃用了。</small>

​	在局域网中，**硬件地址**又被称为**物理地址**，或**MAC地址**。

​	<u>802标准所说的"地址"严格地讲应当是每一站的”名字“或标识符。</u>

​	但鉴于大家都早已习惯了将这种48位的”名字“称为”地址“，所以这里也直接这么说，虽然这种说法不严谨。

+ IEEE的注册管理机构RA负责向厂家分配地址字段的前三个字节（即高位24位）。
+ 地址字段中的后三个字节（即低位24位）由厂家自行指派，称为<u>扩展标识符</u>，必须保证生产出的适配器没有重复地址。
+ 一个地址块可以生成2<sup>24</sup>个不同的地址。这种**48位**地址称为MAC-48，它的通用名称是`EUI-48`。
+ **"MAC地址"实际上就是适配器地址或适配器标识符`EUI-48`**。

*（厂家标识符24bit | 商品编码24bit）大概这个样子。MAC在硬件出厂前就设置在硬件内了。*

​	*<small>网卡芯片的MAC出厂固定不能修改，但我们可以制定计算机用我们自定义的MAC地址通讯，而不用网卡自带的MAC地址。</small>*

​	*<small>win10通过CMD输入`ifconfig /all`可以查看MAC地址</small>*

​	*<small>有些对网络用户鉴权较严格的网络，会通过MAC等手段验证连接网络的用户的身份。（比如某些校园网，只有在学校系统注册过身份的MAC地址能够连通校园网。）</small>*

​	*<small>接入同一台交换机switch的两个设备要是拥有相同MAC，则两者皆无法连通网络。</small>*

#### 3.10.2 适配器检查MAC地址

​	适配器从网络上每收到一个**MAC帧**就首先用硬件检查MAC帧中的MAC地址。

+ 如果是发往本站的帧则收下，然后再进行其他的处理。
+ 否则就将此帧丢弃，不再进行其他的处理。

​	"发往本站的帧"包括以下三种帧：

+ 单播（unicast）帧（一对一）
+ 广播（broadcast）帧（一堆全体）
+ 多播（multicast）帧（一对多）

#### 3.10.3 MAC帧格式

> [802.3帧和Ethernet II帧](http://blog.sina.com.cn/s/blog_eb8b39050102wi7f.html)

​	常用的以太网MAC帧格式有两种标准：

+ **DIX Ethernet V2标准**
+ **IEEE 的 802.3 标准**

​	**==最常用的MAC帧是以太网V2的格式==**。

![img](https://bkimg.cdn.bcebos.com/pic/3b87e950352ac65c18921eccf0f2b21192138afd?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5)

+ 数据字段的正式名称是MAC客户数据字段<small>（可封装IP数据报）</small>，最小长度64字节-18字节的首部和尾部=数据字段的最小长度（46字节）。当数据字段的长度小于46字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的MAC帧不小于64字节。
+ FCS字段4字节。*当传输媒体的误码率为1\*10<sup>-8</sup>时，MAC子层可使未检测到的差错小于1\*10<sup>-14</sup>*
+ **在帧的前面插入的8字节中第一个字段共7个字节，是前同步码，用来迅速实现MAC帧的比特同步。第二个字段就是帧开始定界符，表示后面的信息就是MAC帧**。

<u>由于**以太网使用曼彻斯特编码**（物理层、数字信号），其表示0和1时都有电平跳变，所以能够区分数据0和停止传输数据这两种情况。再加上**以太网**传输数据时有"帧间最小间隔"的限制，所以以太网传输MAC帧只需要告知帧开始定界符，而没必要告知帧结束定界符。</u>

> [mac帧--百度百科]([https://baike.baidu.com/item/mac%E5%B8%A7/6156345?fr=aladdin](https://baike.baidu.com/item/mac帧/6156345?fr=aladdin))
>
> [短帧间间隔--百度百科]([https://baike.baidu.com/item/%E7%9F%AD%E5%B8%A7%E9%97%B4%E9%97%B4%E9%9A%94/22307951?fr=aladdin](https://baike.baidu.com/item/短帧间间隔/22307951?fr=aladdin))
>
> [曼彻斯特编码--百度百科]([https://baike.baidu.com/item/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81/8902319?fr=aladdin](https://baike.baidu.com/item/曼彻斯特编码/8902319?fr=aladdin))
>
> [以太网MAC帧格式](https://blog.csdn.net/hhpingyear/article/details/80216680)
>
> [以太网中的MAC帧没有帧定界符，为什么点对点通信中的PPP帧需要帧定界符？](https://zhidao.baidu.com/question/168429599.html)
>
> [ppp协议有字节表示数据的开头和结尾Mac帧为什么没有？](https://www.zhihu.com/question/55734189)
>
> **PPP帧一般工作在因特网，而MAC帧工作在以太网**。在使用CSMA/CD机制的以太网（一般1000Mbps及以上的以太网络，CSMA/CD支持不好，因为不好定义帧间最小间隔），由于以太网使用曼彻斯特编码，可以辨别无信号和信号0，再加上以太网规定了短帧间间隔，即可以直接根据是否还有接受到数据直接判断MAC的数据帧结束，所以没必要再添加帧尾定界符。
>
> [MAC真向下传到物理层时为什么要加上同步码？？ ](https://zhidao.baidu.com/question/24095641.html)
>
> （个人理解是就是，帧头定界符前面加上同步码，方便数据接受方设备即时进入处理数据的状态。打个比方，交换机A突然收到某处发来的没有同步码的数据帧，内部临时进行操作，然后才能开始处理发过来的数据帧，这时候都可能已经丢失几个bit了。那如果加了同步码（7bit），等于还有前7位时可以进入正式处理接收数据的状态。）
>
> [同步传输--百度百科]([https://baike.baidu.com/item/%E5%90%8C%E6%AD%A5%E4%BC%A0%E8%BE%93/2007281?fr=aladdin](https://baike.baidu.com/item/同步传输/2007281?fr=aladdin))
>
> [请教关于PPP帧MAC帧和HDLC帧的问题 ](http://www.txrjy.com/asktech/question.php?qid=2180)
>
> [PPP帧格式 与 MAC帧格式的区别](https://www.eefocus.com/lubee/blog/10-10/197201_5fa0a.html)
>
> [网络的数据链路层什么时候将数据封装成PPP帧什么时候封装成MAC帧？](https://zhidao.baidu.com/question/101677997.html)
>
> 当同步或者异步线路使用[PPP协议](https://www.baidu.com/s?wd=PPP协议&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)封装的时候，需要PPP帧格式通过LCP ,身份验证，NCP等建立会话链路。
>
> 因为PPP帧是属于PPP协议范围内，而PPP协议是广域网协议，所以在广域网中发送数据时，可能将数据封装成PPP帧。
> 而MAC帧是以太网帧，以太网是局域网，所以在以太网中发送数据时，可能将数据封装成MAC帧。

#### 3.10.4 无效的MAC帧

+ 帧的长度不是整数个字节
+ 用收到的帧检验序列FCS查出有差错
+ 数据字段的长度不在46-1500字节之间。

有效的MAC帧长度为64-1518字节之间。对于检查出的无效MAC帧就简单地丢弃，以太网不负责重传丢失的帧。

#### 3.10.5 帧间最小间隔

​	**帧间最小间隔为9.6μs，相当于96bit的发送时间**。

​	一个站在检测到总线开始空闲后，还要等待9.6μs才能再次发送个数据。

​	这样做时**为了使刚刚接受到数据帧的站的数据缓存来得及清理，做好接收下一帧的准备**。

### 3.11 物理层、数据链路层的网络设备(组网)考虑

#### 3.11.1 在物理层考虑扩展

用集线器扩展局域网优点

+ 使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。
+ 扩大了局域网覆盖的地理范围。

用集线器扩展局域网的缺点

+ **碰撞域增大了，但总的吞吐量并未提高。** *<small>（毕竟广播数据，占用总线）</small>*

+ 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将他们互连起来。

#### 3.11.2 在数据链路层考虑扩展

> [网桥--百度百科]([https://baike.baidu.com/item/%E7%BD%91%E6%A1%A5/99310?fr=aladdin](https://baike.baidu.com/item/网桥/99310?fr=aladdin))
>
> [如何通俗地解释什么是网桥？](https://www.zhihu.com/question/67473683)

在数据链路层扩展局域网是使用**网桥**。

**网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后再确认将该帧转发到哪一个接口。**

#### 3.11.3 使用网桥扩展以太网：好与坏

好：

+ 过滤通信量。*（如果MAC-端口表显示在获取数据的这个端口就存在目的地址，那么就不用再广播到其他接口。）*
+ 扩大了物理范围。*（毕竟是集线器Hub的升级版）*
+ 提高了可靠性。*（网桥有缓存再转发的功能，但是缓存再转发也意味着更加耗时）*
+ **可互连不同物理层、不同MAC子层和不同速率（如10Mb/s和100Mb/s以太网）的局域网**。*（传统集线器就做不到）*

坏：

+ 存储转发增加了时延*（补充，查MAC-端口表后，其实转发到另一个端口也还是广播另一头的整个总线）*
+ <u>在MAC子层并没有流量控制功能</u>。*（MAC子层主要就传输数据，前面提到的基本弃用了的LLC子层就能提供一些类似流控制的功能）*
+ 具有不同MAC子层的网段桥接在一起时时延更大。*（毕竟网桥还是广播转发的数据）*
+ <u>网桥只适合用户数不太多（不超过几百个）和通信量不太大的局域网，否则有时还会因传播过多的**广播信息**而产生网络拥塞。这就是所谓的**广播风暴**</u>。

> [广播风暴--百度百科]([https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E9%A3%8E%E6%9A%B4/3574878?fr=aladdin](https://baike.baidu.com/item/广播风暴/3574878?fr=aladdin))
>
> 广播风暴（broadcast storm）简单的讲是指当广播数据充斥网络无法处理，并占用大量[网络带宽](https://baike.baidu.com/item/网络带宽/6120475)，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”。一个[数据帧](https://baike.baidu.com/item/数据帧/10571824)或包被传输到本地[网段](https://baike.baidu.com/item/网段/11026985) （由[广播域](https://baike.baidu.com/item/广播域/5293530)定义）上的每个[节点](https://baike.baidu.com/item/节点/865052)就是广播；由于[网络拓扑](https://baike.baidu.com/item/网络拓扑/4804125)的设计和连接问题，或其他原因导致广播在网段内大量复制，传播[数据帧](https://baike.baidu.com/item/数据帧/10571824)，导致网络性能下降，甚至[网络瘫痪](https://baike.baidu.com/item/网络瘫痪/5928979)，这就是广播风暴。

#### 3.11.4 透明网桥

目前使用得最多的网桥就是**透明网桥**（transparent bridge）

"透明"是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。*（反正网桥会学习MAC-端口表，用户无需参与学习过程。）*

透明网桥是一种**即插即用设备**，其标准是IEEE 802.1D。

> [透明网桥--百度百科]([https://baike.baidu.com/item/%E9%80%8F%E6%98%8E%E7%BD%91%E6%A1%A5](https://baike.baidu.com/item/透明网桥))
>
> <small>透明网桥(transparent bridge)的标准是802.1D。支持这种设计的人首要关心的是完全透明。按照他们的观点，装有多个[LAN](https://baike.baidu.com/item/LAN)的单位在买回IEEE标准网桥之后，只需把连接插头插入网桥，就万事大吉。透明网桥是一种[即插即用](https://baike.baidu.com/item/即插即用/627180)设备，只要把网桥接入[局域网](https://baike.baidu.com/item/局域网/98626)，不需要改动硬件和软件，无需设置地址开关，无需装入[路由表](https://baike.baidu.com/item/路由表/2707408)或参数，网桥就能工作。</small>
>
> + 自学习和转发帧
> + 逆向学习算法
> + 生成树算法STP（Spanning Tree Protocol）*(避免环路导致的广播风暴)*
> + 透明网桥的路径选择算法归纳
> + 优缺点

#### 3.11.5 透明网桥的自学习算法

​	按照以下**自学习算法**处理收到的帧和建立转发表。

+ 若从A发出的帧从接口x进入了某网桥，那么从这个接口出发沿相反方向一定可以把一个帧传送到A。
+ 网桥每收到一个帧，就记下其<u>源地址</u>和进入网桥的<u>接口</u>，作为转发表中的一个项目。
+ 在建立转发表时把帧首部中的源地址写在"地址"这一栏的下面。
+ 在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把"地址"栏下面已经记下的源地址当作目的地址，而把记下的地址直接当作转发接口。

​	网桥在转发表中登记了以下三个信息

+ 地址
+ 接口
+ **帧进入网桥的时间**

​	这是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。另外，以太网上的工作站并非总是接通电源的。

​	**把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息**。这样就使得网桥中的转发表能反应当前网络的最新拓扑状态。*<small>黑客可以利用这点搞ARP欺骗等，导致网络产生广播风暴，谁也别想上网。</small>*

#### 3.11.6 透明网桥的自学习和帧转发-小结

​	网桥收到一帧后先进行**自学习**。查找转发表中与收到帧的<u>源地址</u>有无相匹配的项目。如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。

​	**转发帧**。查找转发表中与收到帧的<u>目的地址</u>有无相匹配的项目。

+ 如没有，则通过**所有其他接口**（但进入网桥的接口除外）转发。*（接口广播）*

+ 如有，则按转发表中给出的接口进行转发。*（如果那个接口连接多个主机，那这多个主机都能收到广播）*

+ 若转发表中给出的接口就是该帧进入网桥的接口，则应**丢弃**这个帧（因为这时不需要经过网桥进行转发）。

#### 3.11.7 透明网桥的生成树算法STP

​	互联在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两站之间只有一条路径。

​	为了避免产生的转发的帧在网络中不断地兜圈子。*（广播风暴）*

​	<u>为了得出能够反应网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新</u>。

> [快速生成树--百度百科]([https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%A0%91](https://baike.baidu.com/item/快速生成树))
>
> [生成树协议--百度百科]([https://baike.baidu.com/item/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE](https://baike.baidu.com/item/生成树协议))
>
> <small>STP的工作过程如下：首先进行根网桥的选举，其依据是网桥优先级（bridge priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）。</small>
>
> [STP （生成树协议）--百度百科](https://baike.baidu.com/item/STP/2813395)
>
> [详细讲述STP过程](https://wenku.baidu.com/view/6f75ddb987c24028905fc376.html)

### 3.12 多接口网桥：交换机switch

> [交换机--百度百科]([https://baike.baidu.com/item/%E4%BA%A4%E6%8D%A2%E6%9C%BA/103532?fr=aladdin](https://baike.baidu.com/item/交换机/103532?fr=aladdin))
>
> [网桥和交换机有什么区别？](https://zhidao.baidu.com/question/65634069.html?qbl=relate_question_0&word=%CD%F8%C7%C5%CA%C7%C8%AB%CB%AB%B9%A4%CD%A8%D0%C5%C2%F0)
>
> [三层交换机和路由器的区别](https://www.cnblogs.com/josie-xu/p/10477177.html)
>
> [交换机mac表的获取？](https://www.zhihu.com/question/58187639/answer/155994550)

​	1990年问世的<u>交换式集线器</u>（switch hub），可明显地提高局域网的性能。

​	交换式集线器常被称为**以太网交换机**（switch）或**第二层交换机**（表明此交换机工作在数据链路层）。

​	以太网交换机通常都有十几个接口。因此，以太网交换机**实质上就是一个多接口的网桥**，可见交换机工作在数据链路层。

​	交换机特点：

+ 以太网交换机的每个接口都直接与主机相连，并且一般都工作在**全双工方式**。*（网桥）*
+ 交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。*（每根连接交换机的网线拥有自己的独享带宽）*
+ 以太网交换机由于使用了专用的交换结构芯片，其交换速率就比较高。

### 3.13 虚拟局域网VLAN

#### 3.13.1 VLAN

> [网段--百度百科]([https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5](https://baike.baidu.com/item/网段))
>
> 网段（network segment）一般指一个计算机网络中使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分。
>
> [虚拟局域网--百度百科]([https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91?fromtitle=VLAN&fromid=320429](https://baike.baidu.com/item/虚拟局域网?fromtitle=VLAN&fromid=320429))
>
> 在计算机网络中，一个二层网络可以被划分为多个不同的广播域，一个广播域对应了一个特定的用户组，默认情况下这些不同的广播域是相互隔离的。不同的广播域之间想要通信，需要通过一个或多个路由器。这样的一个广播域就称为VLAN。

​	交换机switch的使用使得VLAN的创建称为可能。*（言外之意就是有了交换机后才有VLAN的概念）*

​	**虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组**。

+ 这些网段具有某些共同的需求。
+ **每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个VLAN**。

虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。

**一个VLAN=一个广播域=逻辑网段（子网）**

*（交换机switch可以设置接口对应的VLAN，比如某交换机共24个接口，默认24个接口共同在一个默认的VLAN。如果我们手动修改，配置成后12个接口在新建的VLAN2里，那么连接前12接口的设备无法通过该交换机直接与后12接口的设备进行通讯。）*

> [如何实现交换机不同VLAN、不同网段之间互访？](https://baijiahao.baidu.com/s?id=1627869451704710992&wfr=spider&for=pc)
>
> 通过VLAN能够有效的降低局域网的广播包，提升局域网的网络性能；划分VLAN需要通过支持命令行的二层交换机，普通交换机无法实现VLAN划分。
>
> **实现不同VLAN之间的访问，有两种方式：一种是通过三层交换机，通过默认网关的方式实现不同VLAN之间的访问；一种是通过路由器，利用路由器的子端口和默认路由的方式实现访问。**

#### 3.13.2 跨交换机的VLAN

> [【求助】关于抓包查看vlan号](https://forum.huawei.com/enterprise/zh/thread-325493.html)
>
> 只有一个VLAN的时候，帧上是不会添加VLAN ID的。
>
> [关于vlan的抓包，大神来看一看](https://bbs.51cto.com/thread-1568817-1.html)
>
> [为什么vlan id 的数值范围是1~1094？不是4096？](https://zhidao.baidu.com/question/528320221.html)
>
> VLANID的范围是1—4094，但是某些交换机只支持1—1005。其中，1是默认VLAN，一般用于设备管理，只能使用这个VLAN，但不能删除它。2～1000用于Ethernet VLANs，可以建立、使用和删除这些NLAN。1002—1005预留给FDDI和Token Ring VLANs使用，1025～4096是扩展VLAN ID，其他为保留ID号。

​	在两个交换机switch-A、switch-B上都划分前一半端口属于VLAN1，后一半端口属于VLAN2。将财务部4台计算机PC-a~d平均分配到switch-A、switch-B的VLAN1接口上，然后将销售部的4台计算机PC-e~h平均分配到switch-A、switch-B的VLAN2接口上。为了确保两个交换机上的VLAN1能够直接通信，可以使用一根网线将switch-A、switch-B前半部分属于VLAN1的接口相连，同理用一个网线把switch-A、switch-B的后半部分属于VLAN2的接口相连。这样财务部的计算机PC-a、b、c、d就属于同一逻辑网段了，而销售部同理PC-e、f、g、h属于同一个逻辑网段。

​	按照上面的方法，如果有10个VLAN跨这两个交换机switch-A、switch-B，每一个VLAN使用一根网线连接两个交换机，这也太浪费交换机端口和网线了。而更好的方法就是，使用**干道链路**。

交换机的端口有两种类型：

1. **访问端口**：访问端口只能属于某一个VLAN，它只能承载某一个VLAN的流量，连接访问端口的链路称为访问链路。
2. **中继端口**：中继端口能够同时承载多个VLAN的流量，**连接中继端口的链路称为干道链路**。**数据帧进入干道链路时需要添加帧标记（或称VLAN ID），离开干道链路时去掉帧标记**，这个过程对计算机来说是透明的。

干道链路采用**统计时分复用**（STDM），会在数据帧上标记所属的VLAN（如果网络内就只有一个VLAN就不会标记），然后通过干道链路访问另一个交换机switch的同一个VLAN区域。

**交换机组件的网络，如果需要多个VLAN通过的链路就需要配置为干道链路。如果链路上只需要单一VLAN的数据通过就可以配置为访问链路。** *（言外之意就是交换机连接交换机，不一定就是干道链路，因为接入层的交换机虽然接入汇聚层的交换机，但是其switch没有进行VLAN的划分，即属于一整个默认的VLAN。而假如另外三个接入层交换机各通过一条线接入汇聚层的交换机，且这三个交换机switch都平均分配自己的端口到VLAN1、VLAN2、VLAN3，那么他们接入汇聚层交换机的三条链路都是干道链路，需要通过**统计时分复用STDM**来共用带宽。）*

> [干道技术--百度百科]([https://baike.baidu.com/item/%E5%B9%B2%E9%81%93%E6%8A%80%E6%9C%AF/11066073?fr=aladdin](https://baike.baidu.com/item/干道技术/11066073?fr=aladdin))
>
> 实际上，无论划分了多少个VLAN，都可以通过这样一条只占用两个[交换机](https://baike.baidu.com/item/交换机)接口的干道实现各自VLAN之间的通信，而不会占用过多的交换端口，这种技术称为干道技术。

#### 3.13.3 ISL标记

> [ISL--百度百科](https://baike.baidu.com/item/ISL/931931?fr=aladdin)
>
> ISL & DISL：[思科](https://baike.baidu.com/item/思科)交换链路内协议和动态 ISL 协议（ISL & DISL：Cisco Inter-Switch Link Protocol and Dynamic ISL Protocol） 交换链路内协议（ISL），是思科私有协议，主要用于维护[交换机](https://baike.baidu.com/item/交换机/103532)和[路由器](https://baike.baidu.com/item/路由器/108294)间的通信流量等 VLAN 信息。

ISL干道使VLAN能够跨骨干。

+ 通过特定集成电路来实现
+ <u>不需要在客户计算机上采取配置，客户机不能够看到ISL头</u>
+ 在交换机之间，路由器和交换机，交换机和支持ISL网卡的服务器之间配置

#### 3.13.4 虚拟局域网帧格式

​	虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标记（tag），用来指明发送该帧的工作站属于哪一个虚拟局域网。

```none
802.3 MAC帧
[6字节=目的地址][6字节=源地址]【4字节=VLAN标记】[2字节=长度/类型][46字节~1500字节=数据][4字节=FCS]
```

### 3.14 不同规格的以太网

#### 3.14.1 100BASE-T 以太网

​	速率达到或超过100Mb/s的以太网称为**高速以太网**

​	在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE 802.3 的CSMA/CD协议。100BASE-T以太网又被称为**快速以太网（Fast Ethernet）**。

100Base-T以太网的物理层：

+ 100BASE-TX：使用2对UTP5类线或者屏蔽双绞线STP
+ 100BASE-FX：使用2对光纤
+ 100BASE-T4：使用4对UTP3类线或5类线。

#### 3.14.2 100Base-T特点

​	可在**全双工**方式下工作而无冲突发生。因此，不使用CSMA/CD协议。

​	MAC帧格式仍然是802.3标准规定的。

​	**保持最短帧长不变**，但将一个网段的<u>最大电缆长度减小到100m</u>。**帧间时间间隔从原来的9.6μs该为现在的0.96μs**。

*（可全双工，因为接口可缓存，有阻塞队列，所以收发不影响。）*

#### 3.14.3 吉比特以太网

​	允许在1Gb/s下**全双工和半双工**两种方式工作。

​	使用802.3协议规定的帧格式。

​	**在半双工方式下使用CSMA/CD协议**（全双工方式不需要使用CSMA/CD协议）

​	**与10BASE-T和100BASE-T技术向后兼容**。

​	**当吉比特以太网工作在全双工方式时（即通信双方可同时进行发送和接收数据），<u>不使用载波延伸和分组突发</u>**。

物理层：

1. 1000BASE-X		基于**光纤**通道的物理层：
+ 1000BASE-SX	SX表示短波长
  
+ 1000BASE-LX	LX表示长波长
  
+ 1000BASE-CX	CX表示铜线
2. 1000BASE-T

   + 使用4对5类UTP

#### 3.14.4 10吉比特以太网

​	10吉比特以太网与10Mb/s，100Mb/s和1Gb/s以太网的**帧格式完全相同**。

​	10吉比特以太网还**保留了802.3标准规定的以太网最小和最大帧长，便于升级**。*<small>（其实很多类似的，都是因为早期设定已经出了很多对应的设备和用于实际网络了，不方便改标准什么的，所以就沿用呗。）</small>*

​	**10吉比特以太网不再使用铜线而只是用光纤作为传输媒体**。

​	10吉比特以太网只工作在**全双工**方式，因为没有争用问题，也**不使用CSMA/CD协议**。

#### 3.14.5 端到端的以太网传输

​	**10吉比特以太网的出现，以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而实现了端到端的以太网传输**。*<small>（毕竟我大中华就是一个大局域网呗。）</small>*

这种工作方式的好处是：

+ 成熟的技术
+ 互操作性很好
+ 在广域网中使用以太网时价格便宜
+ **统一的帧格式**简化了操作和管理*（MAC帧）*

#### 3.14.6 使用高速以太网进行宽带接入

​	以太网已成功把速率提高到1~10Gb/s。所覆盖的地理范围也扩展到城域网和广域网，因此现在人们正在尝试使用以太网进行宽带接入。*<small>（也就是ISP收费啦）</small>*

​	**以太网接入的重要特点是它可提供双向的宽带通信，并且可根据用户对宽带的需求灵活地进行宽带升级**。

​	采用以太网接入可实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率和降低了传输的成本。

*（比如很多人家里已经是光纤到户了，但是光纤只是传输介质，ISP网络提供商并没说就给你宽带套餐升级到1Gb/s，只不过用了光纤后，方便以后你升级套餐成1Gb的宽带。简言之，介质决定上限，但是具体宽带大小还是给钱越多带宽越多。）*

> [运营商对带宽进行限制的原理是怎样的？](https://www.zhihu.com/question/19811707)
>
> [深入探讨网络带宽问题](https://zhuanlan.zhihu.com/p/22875995)
>
> [运营商和带宽的那些事](https://zhuanlan.zhihu.com/p/24938843)
>
> [pppoe协议，adsl，宽带，以太网这几者之间的关系是什么啊？](https://www.zhihu.com/question/25847423)

## 4. 网络层

*由于网络层即以上的，之前就很熟悉了，所以有些简单的概念之类的，就没有再记太详细之类的了。*

### 4.1 网络层提供的两种服务

> [分组(网络专有名词)--百度百科]([https://baike.baidu.com/item/%E5%88%86%E7%BB%84/7360586?fr=aladdin](https://baike.baidu.com/item/分组/7360586?fr=aladdin))
>
> 这个术语通常用来一般性地表示任何类型的[报文](https://baike.baidu.com/item/报文)。
>
> 报文(message)是网络中交换与传输的[数据单元](https://baike.baidu.com/item/数据单元/1415766)，即站点一次性要发送的[数据块](https://baike.baidu.com/item/数据块/107672)。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。
>
> [虚电路服务--百度百科]([https://baike.baidu.com/item/%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1/9032436?fr=aladdin](https://baike.baidu.com/item/虚电路服务/9032436?fr=aladdin))
>
> <small>[虚电路](https://baike.baidu.com/item/虚电路)服务是指是一种**面向连接**的，使所有[分组](https://baike.baidu.com/item/分组/7360586)顺序到达目的端的<u>可靠性数据传输服务</u>。[数据报](https://baike.baidu.com/item/数据报)服务是一种**无连接**的，使分组按照独立路由到达目的端的<u>数据传输服务</u>。</small>

网络层关注如何将**分组**从源端沿着网络路径送达目的端。

*<small>在计算机网络领域中，网络层应该向传输层提供怎么样的服务（"面向连接"还是"无连接"）曾引起了长期的争论。</small>*

*<small>争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统</small>*

两种服务：网络层应该向传输层提供怎么样的服务？

+ 虚电路服务（需建立连接，基本不再使用）
+ **数据报服务**

*现一般认为，**可靠性传输，需要端系统(传输层)去实现**。网络中路由器丢包不要求上一个路由器重发。*

#### 4.1.1  电信网：虚电路（弃用）

> [电信网--百度百科]([https://baike.baidu.com/item/%E7%94%B5%E4%BF%A1%E7%BD%91/148140?fr=aladdin](https://baike.baidu.com/item/电信网/148140?fr=aladdin))
>
> <small>电信网(telecommunication network)是构成多个用户相互通信的多个电信系统互连的通信体系，是人类实现远距离通信的重要基础设施，利用电缆、无线、光纤或者其它[电磁系统](https://baike.baidu.com/item/电磁系统/822874)，传送、发射和接收标识、文字、图像、声音或其它信号。</small>

虚电路表示这只是一条逻辑上的连接，**分组**都沿着这条逻辑连接按照**存储转发**方式传送,而并不是真正建立了一条物理连接。

注意，**电路交换的电话通信是先建立了一条真正的连接**。*<small>因此分组交换的虚连接和电路交换的连接只是类似，完全不一样。</small>*

*假设有PC1+++++Router1、Router2、Router3++++++PC2，PC1连接到Router1~3，并且这些Router下一跳都是PC2。如果PC1和PC2建立虚连接时，采用PC1->Router3->PC2,那么之后PC1发送给PC2的所有分组都沿着这条虚电路传送（除非中间这个Router3与其中一方连接出问题，才会重新PC1才会重新和其他Router建立虚连接。）*

> [虚电路的工作原理是什么](https://zhidao.baidu.com/question/814307086912888932.html)
>
> [虚电路（交换虚电路和永久虚电路）](https://blog.csdn.net/z594934262/article/details/83043938)
>
> *<small>交换虚电路（Switched visual circut）是发送方向网络发送请求建立连接时与计算机终端建立起来的连接。一旦建立连接后，即可发送数据，并且保证数据到达接收方。这种虚电路灵活，随时建立，缺点是建立需要耗费时间。</small>*
>
> *<small>永久虚电路（Permanent visual circut）是客户与电信运营商约定好的数据通道，随时能用，不像SVC那样灵活，但是可以用于需要即时通信的设备</small>*

#### 4.1.2 虚电路与数据报服务比较

| 对比的方面                                | 虚电路服务                                                   | 数据报服务                                                   |
| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 思路                                      | 可靠通信应当由网络来保证（虚连接）                           | 可靠通信应当由用户主机来保证（端系统来实现可靠传输）         |
| 连接的建立                                | 必须有（必须提前设置每个路由转发的路径）                     | 不需要（灵活，路由器可自行学习路由表）                       |
| 终点地址                                  | 仅在连接建立阶段使用，每个分组使用短的虚电路号。             | 每个分组都有完善地址                                         |
| 分组的转发                                | <u>属于同一条虚电路的分组均按照同一路由进行转发</u>          | 每个分组独立选择路由进行转发（由路由器选择）                 |
| 当结点出故障时                            | <u>所有通过故障的结点的虚电路均不能工作</u>                  | 出故障的结点可能会丢失分组，一些路由有可能会发生变化         |
| 分组的顺序                                | 总是按发送顺序到达终点（低效率，且上层也不一定对数据顺序有要求） | 到达终点时不一定按照发送顺序（因为每个分组可能经过的路由都不一样） |
| <u>端到端</u>的**差错处理**和**流量控制** | 可以由网络负责，也可以由用户主机负责（即虚电路保证了，或者用户通过更上层的协议实现） | 由用户主机负责（需要用户通过更上层的协议去实现）             |

*可以自己在cmd里用`tracert www.baidu.com`跟踪路由玩玩。*

#### 4.1.3 因特网：数据报服务

网络层向上只提供简单灵活的、**无连接的**、<u>尽最大努力交付</u><small>(比如中间某路由缓存容量20分组，结果一瞬间收到100分组，只保留20个，其余直接丢弃，也不会叫上一个路由重传。)</small>的数据报服务。

网络在发送分组时，**不需要先建立连接**。每一个分组（即IP数据报）独立发送，与其前后的分组无关（不进行编号）。

**网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。**

尽最大努力交付的好处：

+ 由于传输网络不提供端到端的可靠服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网得交换机相比较）。
+ 如果主机（即端系统）中的进程之间的通信需要是可靠的，那么久由网络中的主机的运输层（传输层）负责（包括差错处理、流量控制等）。
+ 采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。
+ 因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。

### 4.2 网络互联

#### 4.2.1 物理层、数据链路层、网络层设备

中间设备又称为中间系统或中继（relay）系统

+ 物理层中继系统：转发器（repeater）*（集线器Hub等）*
+ 数据链路层中继系统：网桥或桥接器（bridge）、交换机（switch）等
+ 网络层中继系统：路由器（router）等
+ ~~网络层以上的中继系统：网关（gateway）~~（现在说的网关，一般指路由器的通信接口）

#### 4.2.2 网络互连的设备：路由器

当中继系统是转发器或网桥时，一般并不称之为网络互联，因为这仅仅是把一个网络扩大了，而这仍然是一个网络（同一个网段）。

~~网关由于比较复杂，目前用得少。~~*（和现在一般所说的“网关”概念不同，就不提了，省得混淆）*

互联网都是指用**路由器**进行互联的网络。

<u>由于历史的原因，许多有关TCP/IP的文献都将网络层使用的路由器称为网关</u>。

*(可以从系统的网络配置查看IP地址、子网掩码、默认网关。默认网关就是路由器接口的IP地址，一般默认取当前网段的第一个主机号。如果计算机没配置网关，就没法访问其他网段。)*

*（默认网关，或叫默认路由，只能配置一个。比如我主机2网卡，要是网卡1配置默认网关是连接因特网的路由器，而网卡2配置的默认网关是连接本地内网NAS的路由器，那么因特网某PCping我的时候，我能收到，单次PC每两次ping请求才能收到一次回应，50%丢包。因为我配置两默认网关，那么主机会认为两个网关地位相同，都能用于访问其他网段，导致每两次ping回应中，有一次回应从网卡1法中返回，一次从网卡2返回-->本地内网NAS路由器发现自己路由表不存在对应的路由，直接丢包）*

#### 4.2.3 网络互联的问题

互联在一起的网络进行通信，需要解决的一些问题：

+ 不同寻址方案
+ 不同的最大分组长度
+ 不同的网络接入机制*（ADSL拨号、光纤接入、无线接入...）*
+ 不同的超时控制
+ 不同的差错恢复方法
+ 不同的状态报告方法
+ 不同的路由选择技术
+ 不同的用户接入控制
+ 不同的服务（面向连接服务和无连接服务）
+ 不同的管理与控制方式

#### 4.2.4 互联网络和虚拟互联网络

*互联网络，物理上多个网段都有物理链路连接，多个路由器直接相连，然后路由器再连接交换机、主机设备。虚拟互联网络，主机所在网络接入互联网。*

*所谓的虚拟互联网络也就是逻辑互联网络，它的意思就是互联起来的各种物理网络的异构性本来就是客观存在的，但我们利用IP协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。*

使用IP协议的虚拟互联网络可简称为IP网。

使用虚拟互联网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的各个网络异构细节。

### 4.3 IP协议

> [ifconfig 中的 eth0 eth0:1 eth0.1 与 lo](https://www.cnblogs.com/jokerjason/p/10695189.html)

#### 4.3.1 IP协议简介

网际协议IP是TCP/IP体系中两个最主要的协议之一。与IP协议配套使用的还有四个协议：

+ **地址解析协议ARP（Address Resolution Protocol）**
+ **逆地址解析协议RARP（Reverse Address Resolution Protocol）**

+ **网际控制报文协议ICMP（Internet Control Message Protocol）**
+ **网际组管理协议IGMP（Internet Group Management Protocol）**

一般，ARP和RARP也被直接被合起来说成ARP（毕竟，ARP是知道IP获取MAC，而RARP是知道MAC获取IP，都是IP和MAC的对应问题）

#### 4.3.2 网络层4个协议之间层次

```none
应用层			|HTTP|FTP|DNS|
传输层			|TCP    |UDP |
网络层			|		ICMP IGMP|
			  |   IPv4         |
			  |ARP	           |
网络接口层     |Ethernet|ATM|Frame Relay|
```

**其中IPv4依赖ARP（这里把ARP和RARP合起来了），ICMP、IGMP依赖IPv4**。*（依赖的意思就是，没有前者，就没法工作了。）*

#### 4.3.3 IP层次结构

> [IPv6--百度百科](https://baike.baidu.com/item/IPv6/172297?fr=aladdin)
>
> IPv6是英文“Internet Protocol Version 6”（互联网协议第6版）的缩写，是互联网工程任务组（[IETF](https://baike.baidu.com/item/IETF/2800318)）设计的用于替代[IPv4](https://baike.baidu.com/item/IPv4/422599)的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址 。
>
> 由于IPv4最大的问题在于网络地址资源不足，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍  。
>
> **互联网数字分配机构（[IANA](https://baike.baidu.com/item/IANA/2800158)）在2016年已向国际互联网工程任务组（IETF）提出建议，要求新制定的国际互联网标准只支持IPv6，不再兼容IPv4。**

1. 层次化IP地址将32位的IP地址分为网络号（网络ID）和主机号（主机ID）。*（这里说的IPv4，现IPv6是64位）*

2. 网络地址（也可以称为网络号）唯一指定了每个网络。同一网络中的每台计算机都共享相同的网络地址，并用它作为自己IP地址的一部分。

3. 分类IP地址

   每一类地址都由两个固定长度的字段组成，网络号（net-id）标识主机（或路由器）所连接到的网络，主机号（host-id）标识该主机（或路由器）。

   两级的IP地址可以记为`IP地址::={<网络号>,<主机号>}`

   + A类地址（前8位主机号，0开头）1.0.0.0~126.255.255.255

   + B类地址（前16位主机号，10开头）128.0.0.0~191.255.255.255

   + C类地址（前24位主机号，110开头）192.0.0.0~223.255.255.255

   + D类地址（1110开头，**组播地址也叫多播地址**）224.0.0.0~239.255.255.255

   + E类地址（1111开头，保留研究用）240.0.0.0~255.255.255.255

**只要看前4bit就可以区分IP地址类别了**。

常用的三种类别的IP地址

| 网络类别 | 最大网络数                    | 第一个可用的网络号 | 最后一个可用的网络号 | 每个网络中最大的主机数 |
| -------- | ----------------------------- | ------------------ | -------------------- | ---------------------- |
| A        | 126（2<sup>7</sup>-2）        | 1                  | 126                  | 16,777,214             |
| B        | 16,383（2<sup>14</sup>-1）    | 128.1              | 191.255              | 65,534                 |
| C        | 2,097,151（2<sup>21</sup>-1） | 192.0.1            | 223.255.255          | 254                    |

> [C类IP地址--百度百科]([https://baike.baidu.com/item/C%E7%B1%BBIP%E5%9C%B0%E5%9D%80/308393?fr=aladdin](https://baike.baidu.com/item/C类IP地址/308393?fr=aladdin))

#### 4.3.4 特殊的几个地址

+ 127.0.0.1 本地环回地址
+ 169.254.0.0 （DHCP分配IP失败时，windows默认设置这个网段）
+ 10.0.0.0（一般大企业内网网段，因为主机数量多）
+ 172.16.0.0 ~ 172.31.0.0（企业常用的局域网网段）
+ 192.168.0.0 ~ 192.168.255.0（一般家用路由器出厂设置的IP都是192.168.xx.xx）

> [169.254.136.228是什么类型的IP地址？](https://zhidao.baidu.com/question/1308421757617347299.html)
>
> [为什么现实中很少使用10.0.0.0网络？](https://www.zhihu.com/question/271834310)
>
> [10.0.0.0的IP是什么东西？](https://zhidao.baidu.com/question/1046103478108825579.html)

#### 4.3.5 子网掩码的作用

​	子网掩码（subnet mask）又叫网络掩码、地址掩码，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。

*如果一台计算机的IP地址配置为172.16.122.204，子网掩码为255.255.0.0。将其IP地址和子网掩码都写成二进制，进行与运算，即1和1与运算得1，0或1和0做与运算都得0。这样经过IP地址和子网掩码昨晚与运算后，主机位不管是什么值都归零，网络位得值保持不变，这样就得到该计算机所处的网段为172.16.0.0。*

#### 4.3.6 子网划分

**主机号不能全0或者全1（全0就是网络号了；全1是广播地址）**。

一个网段的情况

​	某公司两部分，每个部门100台计算机，通过交换机连接，组成局域网，通过路由器连接Internet。这两部门200台计算机使用192.168.0.0C类网络，该网段的子网掩码为255.255.255.0，连接局域网的路由器接口配置使用该网段的第一个可用的IP地址192.168.0.1。

*（虽然路由器可以使用该网段的任何可用IP地址，为了避免该网段计算机的地址和路由器的地址冲突，一般路由器设置为该网段的第一个可用的IP地址或最后一个可用的IP地址。）*

1. 划分成两个子网

   A子网：192.168.0.\[0xxx,xxxx\]*(可用主机号1~126，全0的0和全1的127舍去)* *(网关192.168.0.1，取第一个主机号)*

   B子网：192.168.0.\[1xxx,xxxx\]*(可用的主机号129~254，全0的128和全1的255舍去)* *(网关192.168.0.129，取第一个主机号)*

   子网掩码：255.255.255.0 -> 255.255.255.128【1000,0000】

   ```none
   | A子网			|	B子网			  |
   0----------------128----------------255
   ```

   **每个子网是原本的1/2，子网掩码往右移动一位（每后移动1位，划分1/2）**。

2. 划分成四个子网

   A子网 192.168.0.[00...]

   B子网 192.168.0.[01...]

   C子网 192.168.0.[10...]

   D子网 192.168.0.[11...]

   子网掩码：255.255.255.0 -> 255.255.255.192【1100,0000】

   ``` none
   | A子网 | B子网  |  C子网  |  D子网  |
   0------64------128------192------255
   ```

   **每个子网是原来的1/2 * 1/2，子网掩码向右移动两位。**

3. 等分八个子网

   A子网 192.168.0.[000...]

   B子网 192.168.0.[001...]

   C子网 192.168.0.[010...]

   D子网 192.168.0.[011...]

   E子网 192.168.0.[100...]

   F子网 192.168.0.[101...]

   G子网 192.168.0.[110...]

   H子网 192.168.0.[111...]

   子网掩码：255.255.255.0 -> 255.255.255.224【1110,0000】

   ```none
   8个子网，2^3 >= 8 ，移动3位
   (1) 0 128 255
   (2) 0 64 128 192 255
   (3) 0 32 64 96 128 160 192 224 255
   ```

   **每个子网是原来的1/2 \* 1/2 \* 1/2，子网掩码向右移动3位。**

**乘以几次1/2，子网掩码向右移动几位。**

划分不了的情况：

1. 200划分成50和150：

   0---128---255，150>128，不可能拆出某个>=150的子网。

2. ....

一些其他划分情况：

1. 180划分成10，20，50，100

   100<1281;	50<64;	20<32;	10 <16

   （1）0---128---255 （128~255给100）

   （2）0---64---128---255 （64~128给50）

   （3）0---32---64---128---255 （32~64给20）

   （4）0---16---32---64---128---255 （16~32给10）

2. 判断192.168.201.168/30和192.168.201.169/30哪个是正常的主机地址。

   30说明只有后2位是主机号。2<sup>2</sup>=4，得168/4余0，即168后两位是00，那么169后两位是01，由于主机号不能全0or全1，所以169才是正确的。

3. 判断192.168.0.67/26的子网掩码

   64 < 67 < 128，0---\[64---128\]---192---255，向右移动2位，所以子网掩码是192.168.0.64（主机号全0）。

**子网掩码作用，与IP做与运算，判断目标地址和源地址是否同一网段（同一主机号），同一网段则直接ARP请求解析MAC地址，然后发送数据给对方；如果不同网段，则发送到默认网关（默认路由），访问其他网段（路由器根据路由表判断怎么走）。**

> [同一网段内的两台主机通信是否需要路由器？](https://www.zhihu.com/question/41496681)

#### 4.3.7 超网

> [超网--百度百科]([https://baike.baidu.com/item/%E8%B6%85%E7%BD%91/10504849?fr=aladdin](https://baike.baidu.com/item/超网/10504849?fr=aladdin)) *（建议看看最下面的"应用举例，练练手"）*
>
> 超网(supernetting)是与[子网](https://baike.baidu.com/item/子网/1186929)类似的概念--[IP地址](https://baike.baidu.com/item/IP地址/150859)根据[子网掩码](https://baike.baidu.com/item/子网掩码/100207)被分为独立的[网络地址](https://baike.baidu.com/item/网络地址/9765459)和[主机地址](https://baike.baidu.com/item/主机地址/9765500)。超网（supernetting），也称无类别域间路由选择（CIDR），它是集合多个同类互联网地址的一种方法。
>
> <small>目前盛行的外部网关协议边界网关协议（BGP）以及开放式最短路径优先（OSPF）路由协议都支持超网技术。</small>
>
> [访问控制列表--百度百科]([https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8/1844390?fromtitle=ACL&fromid=362453&fr=aladdin](https://baike.baidu.com/item/访问控制列表/1844390?fromtitle=ACL&fromid=362453&fr=aladdin))
>
> 访问控制列表(ACL)是一种基于包过滤的[访问控制技术](https://baike.baidu.com/item/访问控制技术/5652430)，它可以根据设定的条件对接口上的数据包进行过滤，允许其通过或丢弃。访问控制列表被广泛地应用于[路由器](https://baike.baidu.com/item/路由器/108294)和三层[交换机](https://baike.baidu.com/item/交换机/103532)，借助于访问控制列表，可以有效地控制用户对网络的访问，从而最大程度地保障网络安全。
>
> <small>1）限制网络流量、提高网络性能。例如，ACL可以根据数据包的协议，指定这种类型的数据包具有更高的优先级，同等情况下可预先被网络设备处理。 </small>
>
> <small>2）提供对通信流量的控制手段。 </small>
>
> <small>3）提供网络访问的基本安全手段。 </small>
>
> <small>4）在网络设备接口处，决定哪种类型的通信流量被转发、哪种类型的通信流量被阻塞。 </small>
>
> <small>例如，用户可以允许E- mail通信流量被路由，拒绝所有的Telnet通信流量。例如，某部门要求只能使用WWW这个功能，就可以通过ACL实现；又例如，为了某部门的保密性，不允许其访问外网，也不允许外网访问它，就可以通过ACL实现。</small>

现有两计算机PC-A和PC-B分别连接到交换机Switch1和Switch2，且Switch1和Switch2相连*（即数据链路层上，两计算机位于同一个网段）*。Switch2连接Router。已知PC-A（IP：192.168.0.2；net mask：255.255.255.0；gateway：192.168.0.1），而PC-B（IP：192.168.1.2；net mask：255.255.255.0；gateway：192.168.1.1），由于主机号不同*（网络层，A和B不在同一网段）*，导致A和B通讯还不能直接通过链路层交换机Switch就完成，必须再经过路由器。*（理想：A->Switch1->Switch2->B；现实：A->Switch1->Switch2->Router->Switch2->B）*

很明显本来两层（物理层、数据链路层）就能完成的通讯，现在变成三层（物理层、数据链路层、网络层），效率更低了。为解决这种问题，就需要**超网**。

将两个PC的IP地址写成2进制形式，容易发现前23位数字相同（8+8+7），那么只要保留前23位作为网络号，后面不同的部分作为主机号即可，即修改两者的子网掩码为255.255.254.0。*（子网掩码向前移动一位，网络号相同）*

```none
192.168.【0000 0000】.0
192.168.【0000 0001】.0
255.255.【1111 1111】.0
255.255.【1111 1110】.0 => 255.255.254.0 # 合并A和B子网后，新的子网掩码
```

#### 4.3.8 互联网上计算机通信过程

**IP地址与MAC地址应用：网络层及以上，使用IP地址；链路层及以下，使用硬件地址。**

M1~M6表示MAC地址，Router有两个接口对应不同MAC地址

```none
PC1(M1) === Switch1 === Router1(M2,M3) === Router2(M4,M5) === Switch2 === PC2(M6) 
```

PC1 ===> PC2 发送数据报，经过以下几个流程：

1. PC1(M1) ==> Switch1 ==> Router(M2)；MAC帧源地址M1，目的地址M2；MAC帧数据部分（IP数据报，内容不变）
2. Router1(M3) ==> Router2(M4)；MAC帧首部修改，源地址M3，目的地址M4；MAC帧数据部分（IP数据报，内容不变）
3. Router2(M5) ==> PC2(M6)；MAC帧首部修改，源地址M5，目的地址M6；MAC帧数据部分（IP数据报，内容不变）

**数据传输时，只有MAC的源地址和目的地址被修改**（毕竟链路层就靠这个识别路径的）。

1. **交换机基于数据帧的MAC地址转发数据帧，路由器基于数据包的IP地址转发数据包。**

2. **数据包在传输过程不变，过网络设备数据帧要用新的物理层地址重新封装。**
3. **MAC地址决定了数据帧下一跳哪个设备接收，而IP地址决定了数据包的起点和终点。**

#### 4.3.9 为什么不直接使用硬件地址进行通信

​	*<small>由于全世界存在各种各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。</small>*

​	*<small><u>连接到因特网的主机都拥有统一的IP地址（指公网IP）</u>，它们之间的通信就像连接在同一个网络上那样简单方便。因为调用ARP来寻找某个路由器或者主机的硬件地址都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</small>*

### 4.4 ARP&RARP

#### 4.4.1 ARP和RARP概述

> [IP （网络之间互连的协议）]([https://baike.baidu.com/item/IP/224599?fromtitle=IP%E5%8D%8F%E8%AE%AE&fromid=131947&fr=aladdin](https://baike.baidu.com/item/IP/224599?fromtitle=IP协议&fromid=131947&fr=aladdin))
>
> IP主要包含三方面内容：IP编址方案、分组封装格式及分组转发规则。
>
> **IP分组的转发规则**:路由器在间接交付中，若路由表中有到达目标网络的路由，则把数据包传送给路由表指明的下一跳路由器；如果没有路由，但路由表中有一个**默认路由**，则把数据报传送给指明的默认路由器；如果两者都没有，则丢弃[数据包](https://baike.baidu.com/item/数据包/489739)并报告错误。
>
> **IP分片**：如果数据包的大小超过了出口链路的最大传输单元时，则会将该IP分组分解成很多足够小的片段，以便能够在目标链路上进行传输。这些IP分片重新封装一个IP包独立传输，并在到达目标主机时才会被重组起来。
>
> **IP分组结构**：一个IP分组由首部和数据两部分组成。首部的前20字节是所有IP分组必须具有的，也称固定首部。在首部固定部分的后面是一些可选字段，其长度是可变的。
>
> 在传送IP信息包时，一定会指明源地址与目的地址。源地址当然只有一个，但是目的地址却可能代表单一或多部设备。根据目的地址的不同，区分为3种传送方式：**单点传送、广播传送以及多点传送**。
>
> [ARP （地址解析协议）--百度百科](https://baike.baidu.com/item/ARP/609343?fr=aladdin)
>
> [主机](https://baike.baidu.com/item/主机/455151)发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并**保留一定时间**，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，**局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存**；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个[ARP欺骗](https://baike.baidu.com/item/ARP欺骗)。
>
> [RARP（反向地址转换协议）--百度百科]([https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE/2991811?fromtitle=RARP&fromid=610685&fr=aladdin](https://baike.baidu.com/item/反向地址转换协议/2991811?fromtitle=RARP&fromid=610685&fr=aladdin))
>
> [gratuitous ARP--百度百科]([https://baike.baidu.com/item/gratuitous%20ARP/5635432?fromtitle=%E5%85%8D%E8%B4%B9ARP&fromid=23700671&fr=aladdin](https://baike.baidu.com/item/gratuitous ARP/5635432?fromtitle=免费ARP&fromid=23700671&fr=aladdin))
>
> Gratuitous ARP也称为免费ARP，[无故ARP](https://baike.baidu.com/item/无故ARP/8030661)。Gratuitous ARP不同于一般的ARP请求，它并非期待得到ip对应的[mac地址](https://baike.baidu.com/item/mac地址/1254181)，而是**当主机启动的时候，将发送一个Gratuitous arp请求，即请求自己的[ip地址](https://baike.baidu.com/item/ip地址/150859)的mac地址。**

IP地址 ==> ARP == （IGMP组播） ==> 物理地址MAC

物理地址MAC ==> RARP == （IGMP组播） ==> IP地址

*（所有的动态路由协议都属于IP协议。）*

*(ARP协议存在重大安全隐患。ARP欺骗、中间人攻击等)*

#### 4.4.2 ARP概述

> [为什么arp查询要在广播帧中发送,而arp响应要用单播帧](https://zhidao.baidu.com/question/2203631599373243148.html)
>
> 查询前是不知道目的主机具体的mac地址，通过广播的方式，让局域网所有主机收到这个以太网帧，而只有目的主机会从接收的帧中解出ip数据报并知道了源主机的ip地址，然后发送一个arp响应的时候就只需要单播就能找到源主机了，同时更新arp表
>
> [pc收到不是自己的arp广播请求pc会更新arp缓存表吗](https://zhidao.baidu.com/question/618882596273652372.html)
>
> 答案是**可能会也可能不会**。
> 是这样：在同一局域网内，A（我）要和B通信（只知道B的IP），我就要发一个arp请求的包，当然所有的主机都会收到这个包，当主机C也收到这个请求时，就会和自己的arp缓存对比，如果arp中无此IP的记录，就直接忽略，如果有此IP的MAC记录，就会更新这个IP---MAC记录（一般是这样）。
> 但是如果开启了**arp报文学习功能**，对于没有过记录的IP，会新建一个arp表项，记下A的IP----MAC。
> 如果关闭了arp报文学习功能，对于没有过记录IP也不会新建arp表项，就不会记下A的IP和MAC地址。但是如果曾经有过A的IP---MAC记录，就检查一下这个MAC和当前收到的arp包中的MAC是否一样，不一样就会更新A的MAC。

​	<u>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址</u>。

​	每一个主机都设有一个**ARP高速缓存（ARP cache）**，里面由所在的就局域网上的各主机和路由器的**IP地址到硬件地址的映射表**。

​	当主机A欲向本地局域网上的某个主机B发送IP数据报时，就现在其ARP高速缓存中查看有无主机B的IP地址。如有，就可查出其对应的硬件地址，在将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发送此硬件地址。<u>如果没，则广播ARP请求报文，正常情况下只有ARP的目的IP地址和自己相同的某个主机才会回应该ARP请求（同时把从ARP请求分组中的源IP和MAC地址加入或更新自己的ARP缓存），其他主机要是开启了ARP学习功能（如果本地没有该IP-MAC项，就新增），否则只要本地没有记录过该IP-MAC项（有的话就更新）则直接丢弃收到的ARP请求报文。收到ARP回应的原请求者，再把响应的IP和MAC加入到本地IP-MAC缓存中。</u>

（windows的cmd通过`arp -a`查看arp缓存。可以看到IP广播`255.255.255.255`IP地址对应帧广播的`ff-ff-ff-ff-ff-ff`MAC地址）

#### 4.4.3 ARP高速缓存的作用

​	为了减少网络上的通信量，主机A再发送其ARP请求分组时，就将自己的IP地址到硬件地址的映射写入到ARP请求分组。

​	当主机B收到A的ARP请求分组时，就将主机A的这一地址映射写入主机B自己的ARP高速缓存中。这对主机B以后向A发送数据报就更方便了。

#### 4.4.4 ARP应当注意的问题

> [代理ARP--百度百科]([https://baike.baidu.com/item/%E4%BB%A3%E7%90%86ARP/9765556?fr=aladdin](https://baike.baidu.com/item/代理ARP/9765556?fr=aladdin))
>
> ARP报文是主机发送出来的，在该主机只知道对方的IP地址且想知道对方的MAC地址时，它以**广播**的方式将**ARP请求**发送到自己所在网段的各个节点。当有主机响应时，**回发的报文是单播发送**。
>
> 代理ARP是当主机知道一个IP地址且它想知道该IP地址对应的MAC地址时，主机广播发送ARP请求，路由器收到ARP Request时，若发现查询的目的IP地址在不同[子网](https://baike.baidu.com/item/子网)，<u>路由器会扮演代理的ARP的角色，代为回答，告诉查询者它所要做的MAC地址 （用的是之间接口的MAC地址）</u>。
>
> **代理ARP只响应那些在自己的路由表里能找到的网段，而不是响应主机所有的arp请求**。（比如ARP的目标在别的网段但又不在Router的路由表中，路由器就不响应该ARP了。）
>
> ​	当主机**未配置默认路由**时，ping非本网段地址，会向网络发送此非本网段地址的ARP请求，并且开启了代理ARP的设备接口有该非本网段路由时，会将自己的MAC进行ARP答复，实现ARP代理功能。**本网段内的访问仅仅是简单的广播寻址，不涉及代理ARP，当主机配置默认路由时，该ARP请求直接请求的就是网关的ARP，也不涉及代理ARP**，所以所谓的代理ARP相当于网关是有道理的。在**配置了网关的设备上是不会出现代理ARP的问题。**
>
> [对于ARP ,若不在同一个网段里，arp请求是如何进行的？有的说给网关就行了，有的要路由器做代理arp怎样的？](https://zhidao.baidu.com/question/214144643.html)
> 首先，**ARP请求只会请求自己本网段的，不是本网段的所有报文都会发送到默认网关**。
> （或者其他地址，要看路由表上怎么写的）
> 所谓ARP就是获取IP地址对应的mac地址（IP是网络层的，mac是链路层的）
> 实际上载不同网段里，你的PC机不会发送不同网段的ARP请求，而是将这个报文直接发给网关，由网关（网关很可能就是一台路由器）来处理。
> 网关会判断，如果这个地址是它直连的，那么他会发送ARP请求（但是这些操作，PC机已经不知道了，它也没必要知道。），如果不是，网关会将报文扔给它自己的网关（其实是要先查路由表的哦~~）
>
> [gratuitous ARP（免费ARP、无故ARP）]([https://baike.baidu.com/item/gratuitous%20ARP/5635432?fromtitle=%E5%85%8D%E8%B4%B9ARP&fromid=23700671&fr=aladdin](https://baike.baidu.com/item/gratuitous ARP/5635432?fromtitle=免费ARP&fromid=23700671&fr=aladdin))
>
> Gratuitous ARP也称为免费ARP，[无故ARP](https://baike.baidu.com/item/无故ARP/8030661)。Gratuitous ARP不同于一般的ARP请求，它并非期待得到ip对应的[mac地址](https://baike.baidu.com/item/mac地址/1254181)，而是当主机启动的时候，将发送一个Gratuitous arp请求，即**请求自己的[ip地址](https://baike.baidu.com/item/ip地址/150859)的mac地址**。
>
> [路由器怎么知道其他路由器和主机的MAC](https://zhidao.baidu.com/question/122322006.html)

![](https://bkimg.cdn.bcebos.com/pic/71cf3bc79f3df8dc8aa9de00ce11728b4610288e?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5)

​	ARP是解决**同一个局域网**上的主机或路由器的IP地址和硬件地址的映射问题，如果索要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。（**代理ARP**）

​	从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。

​	只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由进行通信，ARP协议就会自动地将将IP地址解析为链路层所需要的硬件地址。

#### 4.4.5 使用ARP的四种典型情况

1. **发送方是主机，要把数据报发送到本网络上的另一个主机。这时用ARP找到主机的硬件地址。**
2. **发送方是主机，要把IP数据报发送到另一个网络上的一个主机。这时用ARP找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。**
3. **发送方是路由器，要把IP数据报转发到本网络上的一个主机。这时用ARP找到目的主机的硬件地址。**
4. **发送方是路由器，要把IP数据报转发到另一个网络上的一个主机。这时用ARP找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。**

#### 4.4.6 逆地址解析RARP

> [反向地址转换协议--百度百科]([https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE/2991811?fromtitle=RARP&fromid=610685](https://baike.baidu.com/item/反向地址转换协议/2991811?fromtitle=RARP&fromid=610685))
>
> 反向地址转换协议（RARP）允许局域网的**物理机器从[网关](https://baike.baidu.com/item/网关/98992)服务器的 ARP 表或者缓存上请求其 IP 地址**。[网络管理员](https://baike.baidu.com/item/网络管理员/595848)在局域网[网关](https://baike.baidu.com/item/网关/98992)[路由器](https://baike.baidu.com/item/路由器/108294)里创建一个表以映射[物理地址](https://baike.baidu.com/item/物理地址/2129)（MAC）和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向[路由器](https://baike.baidu.com/item/路由器/108294)上的 RARP 服务器请求相应的 IP 地址。假设在[路由表](https://baike.baidu.com/item/路由表/2707408)中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。
>
> RARP以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是**广播**信息，**RARP规定只有RARP服务器能产生应答**。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。

​	*使只知道自己硬件地址的主机能够知道其IP地址。*

​	虽然RARP在概念上很简单，但是一个RARP服务器的设计与系统相关而且比较复杂。相反，提供一个ARP服务器很简单，通常是TCP/IP在[内核](https://baike.baidu.com/item/内核)中实现的一部分。由于内核知道IP地址和硬件地址，因此当它收到一个询问IP地址的ARP请求时，只需用相应的硬件地址来提供应答就可以了。

​	作为用户进程的RARP服务器的复杂性在于：服务器一般要为多个主机（网络上所有的[无盘系统](https://baike.baidu.com/item/无盘系统)）提供硬件地址到IP地址的映射。该映射包含在一个磁盘文件中（在Unix系统中一般位于/etc/ethers目录中）。**由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供，而不是作为内核的[TCP/IP](https://baike.baidu.com/item/TCP%2FIP)实现的一部分**。

​	更为复杂的是，RARP请求是作为一个特殊类型的[以太网](https://baike.baidu.com/item/以太网)[数据帧](https://baike.baidu.com/item/数据帧)来传送的（[帧类型](https://baike.baidu.com/item/帧类型)字段值为0x8035）。这说明RARP服务器必须能够发送和接收这种类型的以太网数据帧。<u>由于发送和接收这些[数据帧](https://baike.baidu.com/item/数据帧)与系统有关，因此RARP服务器的实现是与系统捆绑在一起的</u>。

​	每个网络有多个RARP服务器实现的一个复杂因素是RARP请求是在硬件层上进行广播的。这意味着它们不经过路由器进行转发。<u>为了让无盘系统在RARP服务器关机的状态下也能引导，通常在一个网络上（例如一根电缆）要提供多个RARP服务器。</u>当服务器的数目增加时（以提供[冗余备份](https://baike.baidu.com/item/冗余备份)），[网络流量](https://baike.baidu.com/item/网络流量)也随之增加，因为每个服务器对每个RARP请求都要发送RARP应答。发送RARP请求的无盘系统一般采用最先收到的RARP应答。另外，还有一种可能发生的情况是每个RARP服务器同时应答，这样会增加[以太网](https://baike.baidu.com/item/以太网)发生冲突的概率。

 ### 4.5 IP数据报

> [IP数据报--百度百科]([https://baike.baidu.com/item/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/1581132?fr=aladdin](https://baike.baidu.com/item/IP数据报/1581132?fr=aladdin))
>
> lP数据报采用数据报分组传输的方式，**提供的服务是无连接方式**。

#### 4.5.1 IP数据报-报文格式

**一个IP数据报由首部和数据两部分组成**。

+ 首部前一部分是固定长度，共20字节，是所有IP数据报必须有的。
+ 在首部的固定部分的后面是一些可选字段，其长度是可变的。

![img](https://bkimg.cdn.bcebos.com/pic/c8177f3e6709c93d464442fd903df8dcd1005401?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2UxMTY=,xp_5,yp_5)

**固定部分**：

1. 版本：占4位，指IP协议的版本。**通信双方使用的IP协议版本必须一致**。广泛使用的IP协议版本号为4（即[IPv4](https://baike.baidu.com/item/IPv4)）。关于[IPv6](https://baike.baidu.com/item/IPv6)，还处于草案阶段。

2. 首部长度：占4位，可表示的最大十进制数值是15。请注意，这个**字段所表示数的单位是32位字长**（1个32位字长是4字节），因此，当IP的首部长度为1111时（即十进制的15），首部长度就达到60字节。**当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。**因此数据部分永远在4字节的整数倍开始，这样在实现IP协议时较为方便。首部长度限制为60字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是20字节（即首部长度为0101），这时不使用任何选项。

3. 区分服务：占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但**实际上一直没有被使用过**。1998年IETF把这个字段改名为区分服务DS(Differentiated Services)。**只有在使用区分服务时，这个字段才起作用**。（数值越低，优先级越高。需要路由器也设置区分服务才有用。路由器收到区分服务250和区分服务100的两个数据报时，则优先处理、转发区分服务为100的数据报。一般情况下都不使用这个字段QoS服务质量）

   > [qos--百度百科](https://baike.baidu.com/item/qos/404053?fr=aladdin)
   >
   > [QoS的基本原理](https://blog.csdn.net/c1194758555/article/details/78839184)

4. 总长度：总长度指首部和数据之和的长度，单位为字节。总长度字段为16位，因此数据报的最大长度为2^16-1=65535字节。

在IP层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元MTU(Maximum Transfer Unit)。当一个数据报封装成链路层的帧时，此**数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的MTU值**。

5. 标识(identification)：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”**并不是序号**，<u>因为IP是无连接服务，数据报不存在按序接收的问题</u>。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。

6. 标志(flag)：占3位，但只有前2位有意义。

   ●　**标志字段中的最低位记为MF(More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。**

   **●　标志字段中间的一位记为DF(Don’t Fragment)，意思是“不能分片”。只有当DF=0时才允许分片。**

7. 片偏移：占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。**片偏移以8个字节为偏移单位**。这就是说，**除了最后一个分片，每个分片的长度一定是8字节（64位）的整数倍**。

8. 生存时间：占8位，生存时间字段常用的的英文缩写是**TTL**(Time To Live)，表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在[因特网](https://baike.baidu.com/item/因特网)中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为TTL的单位。每经过一个[路由器](https://baike.baidu.com/item/路由器)时，就把TTL减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于1秒，就把TTL值减1。当TTL值为0时，就丢弃这个数据报。后来把TTL字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把TTL值减1.若TTL值减少到零，就丢弃这个数据报，不再转发。因此，TTL的单位不再是秒，而是**跳数**。TTL的意义是指明数据报在网络中至多可经过多少个路由器。**显然，数据报在网络上经过的路由器的最大数值是255.若把TTL的初始值设为1，就表示这个数据报只能在本局域网中传送。**

   *（可以用`ping`指令看看数据报传输时的TTL。`pathping`查看沿途经过的路由+分析丢包率）*

9. 协议：占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程。

10. 首部检验和：占16位。这个字段**只检验数据报的首部，但不包括数据部分**。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。

    > [IP数据报---首部校验和的计算方法](https://blog.csdn.net/qq_40816078/article/details/85525438)

11. 源地址：占32位。

12. 目的地址：占32位。

**可选字段（长度可变）**：

​	IP首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目。某些选项项目只需要1个字节，它只包括1个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全0的填充字段补齐成为4字节的整数倍。

​	增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的IP版本IPv6就将IP数据报的首部长度做成固定的。这些任选项定义如下：

（1）安全和处理限制（用于军事领域）

（2）记录路径（让每个路由器都记下它的[IP地址](https://baike.baidu.com/item/IP地址)）

（3）时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）

（4）宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）

（5）严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）

<u>这些选项很少被使用，并非所有主机和路由器都支持这些选项</u>。

> [ip分片后在哪个地方重组？](https://www.zhihu.com/question/49384965)
>
> 中间转发的路由不重组分片，并且根据MTU要求还可能会继续分片。
>
> [某路由器收到了一个IP数据报，在对其首部进行校验后发现该数据报存在错误，路由器最有可能采取的动作是？](https://zhidao.baidu.com/question/124467374.html)
>
> 本题考查点是路器对出错分组的处理。从IP数据报格式可知，其首部有一个“头部校验和”字段。该字段用于检测IP数据报首都数据的完整性。**当路由器收到了一个IP数据报，先对其首部进行校验，若发现存在错误，则抛弃该IP数据报，并向源主机发送ICMP(因特网控制报文协议)差错报告报文。**

#### 4.5.2 IP数据报传输

> [0.0.0.0](https://baike.baidu.com/item/0.0.0.0/7900621?fr=aladdin)
>
> [缺省路由--百度百科]([https://baike.baidu.com/item/%E7%BC%BA%E7%9C%81%E8%B7%AF%E7%94%B1](https://baike.baidu.com/item/缺省路由))
>
> 在通信网络中，缺省路由（Default Route）([默认路由](https://baike.baidu.com/item/默认路由/8990860))是[路由表](https://baike.baidu.com/item/路由表/2707408)中一种特殊的**静态路由**，当网络中[报文](https://baike.baidu.com/item/报文/3164352)的路由无法匹配到当前路由表中的路由记录时，缺省路由用来指示路由器或网络主机将该报文发往指定的位置  。缺省路由在路由表中目的地址为0.0.0.0、[子网掩码](https://baike.baidu.com/item/子网掩码/100207)为0.0.0.0，显示为Gateway of last resort is (IP Address) to network 0.0.0.0  。换言之，**如果数据报文的目的地址无法与路由表中的路由记录相匹配，则路由器或网络主机中将使用缺省路由转发该报文**。
>
> **缺省路由的优先级比静态路由的优先级低**，当客户端主机访问网络时，通常先查看报文的目的地址，如果目的地址在路由表的地址池中，即有静态路由匹配，则按照该路由规则转发相应的报文，否则该报文将按照缺省路由的规则被转发。该过程在网络中不断被重复，直至报文被传递到目的地。网络设备的缺省路由通常也被称为默认网关，具有如数据包过滤、[防火墙](https://baike.baidu.com/item/防火墙/52767)或[代理服务器](https://baike.baidu.com/item/代理服务器/97996)等功能

**原则：有来有回**

+ **沿途的路由器必须知道到目的网络下一跳给哪个接口**

+ **沿途的路由器必须知道到源网络下一跳给哪个接口**

(windows使用`route print`查看路由表,`arp -a`查看mac高速缓存)

1. 没有配置默认路由（网关、缺省路由）的主机无法访问其他网段。
2. 如果一台主机有多个网卡，每个网卡都配置了`默认路由`，**这几个默认路由的权重相同，会负载均衡**。（所以**为了正常上网，只能有一个网卡配置默认路由**！！！）

*（一般局域网ping网关响应在10ms以内属于正常；ping外部网络IP如果经常是数百ms且偶尔丢包，则可能是网络阻塞。）*

```none
# 下面举例，某PC主机有两个网卡，分别配置一个默认路由，一个连接因特网，一个连接同一局域网环境的其他网段。
局域网其他网段----(eth0 配置了默认路由0)PC(eth1 配置了默认路由1)---- 因特网
# 此时 ping 因特网上某一服务器，会发现一次能通、一次不能通、一次能通、一次不能通，有规律地交替出现能通、不能通的情况。因为主机认为两个网关的路由配置权重相同，认为等价，所以轮流使用默认路由0、默认路由1访问外部网络。(50%丢包率)

# 如果PC只有一个网卡，且只有1默认路由，如果ping外部网络，偶尔出现一次丢包，而且每次成功的数据报响应都在几百ms，那么大概率是网络阻塞问题。
```

#### 4.5.3 路由器分组转发

> [路由器分组转发的过程](https://blog.csdn.net/qq_38855717/article/details/80901853)
>
> [TTL(生存时间值)--百度百科](https://baike.baidu.com/item/TTL/130248?fr=aladdin)
>
> TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4报头的一个8 bit字段。
>
> 注意：<u>TTL与DNS TTL有区别。二者都是生存时间，前者指ICMP包的转发次数（跳数），后者指域名解析信息在DNS中的存在时间。</u>
>
> [IP数据报传输与处理过程](https://blog.csdn.net/thisispan/article/details/7587998)
>
> ***\*对接收到的数据报，不管它是分片后形成的IP\**数据报还是未分片的IP数据报，路由器都一视同仁，进行相同的路由处理和转发。**

​	*IP数据报的首部长没有可以用来指明“下一跳路由器的IP地址”。当路由器收到待转发的数据报，不是将下一跳路由器的IP地址填入IP数据报，而是送交下层的网络接口软件。**网络接口软件使用ARP负责将下一跳路由器的IP地址换换成硬件地址，并将此硬件地址放在链路层的MAC帧首部，然后根据这个硬件地址找到下一跳路由器**。*

1. 从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。

2. 若网络N与此路由器直接相连，则把数据报**直接交付**目标主机D；否则是**间接交付**，执行3.
3. 若路由表中有<u>目的地址为D的特定主机路由</u>，则把数据报传给路由表中指明的下一跳路由器；否则执行4.
4. 如路由表中有到达网络N的路由器，则把数据报传给路由表指明的下一跳路由器；否则，执行5.
5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6.
6. 报告转发分组出错。*（ICMP）*

#### 4.5.4 路由聚合（route aggregation)

> [路由聚合--百度百科]([https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/5322155?fr=aladdin](https://baike.baidu.com/item/路由聚合/5322155?fr=aladdin))
>
> 路由聚合（也叫汇总）是让路由选择协议能够用一个地址通告众多网络，旨在缩小路由器中路由选择表的规模，以节省内存，并缩短IP对路由选择表进行分析以找出前往远程网络的路径所需的时间。
>
> [无类别域间路由(CIDR)--百度百科]([https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/15758573?fromtitle=CIDR&fromid=3695195&fr=aladdin](https://baike.baidu.com/item/无类别域间路由/15758573?fromtitle=CIDR&fromid=3695195&fr=aladdin))
>
> 无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。
>
> CIDR主要是一个按位的、基于前缀的，用于解释IP地址的标准。 它通过把多个地址块组合到一个路由表表项而使得路由更加方便。这些地址块叫做CIDR地址块。当用二进制表示这些地址时，它们有着在开头部分的一系列相同的位。

一个CIDR地址块可以表示很多地址，这种地址得到聚合常称为**路由聚合**，它使得路由表中的一个项目可以表示很多个（例如上千个原来传统分类地址的路由）。

<u>路由聚合也成为构成超网（suppernetting）</u>。0100 0100

CIDR虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。**对于`/20`地址快，它的掩码是20个连续的1。斜线记法的数字就是掩码中1的个数。**

#### 4.5.5 最长前缀匹配

> [最长前缀匹配--百度百科]([https://baike.baidu.com/item/%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D/5488072?fr=aladdin](https://baike.baidu.com/item/最长前缀匹配/5488072?fr=aladdin))
>
> 因为路由表中的每个表项都指定了一个网络，所以一个目的地址可能与多个表项匹配。最明确的一个表项——即[子网掩码](https://baike.baidu.com/item/子网掩码)最长的一个——就叫做最长前缀匹配。之所以这样称呼它，是因为这个表项也是路由表中，与目的地址的高位匹配得最多的表项。
>
> **路由表中常常包含一个[默认路由](https://baike.baidu.com/item/默认路由)。这个路由在所有表项都不匹配的时候有着最短的前缀匹配。**

在使用CIDR时，路由表中的每个项目由“网络前缀”和”下一跳地址“组成。在查找路由表时可能会得到不止一个匹配结果。

应当从匹配结果中选择居于最长网络前缀的路由：**最长前缀匹配**（longest-prefix matching）。

网络前缀越长，其地址快越小，因而路由就越具体（more specific）。

**最长前缀匹配又称为最长匹配或最佳匹配**。

#### 4.5.6 二叉搜索树与路由表查找

​	当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。

​	为了进行更加有效的查找，通常是将无分类地址的路由表存放在一个层次的数据结构中，然后自顶向下地按层次进行查找。这里最常用的就是二叉线索树（binary trie）。（IP地址32位，查找深度最多32）

​	IP地址中从左到右的比特值决定了从根节点逐层向下延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。

​	为了提高二叉线索的查找速度，广泛使用了各种压缩技术。

```none
# 二叉线索树与路由表查找举例
|-------------32位的IP地址-------------|唯一前缀|
  01000110 00000000 00000000 00000000   0100
  01010110 00000000 00000000 00000000   0101
  01100001 00000000 00000000 00000000   011
  10110000 00000010 00000000 00000000   10110
  10111011 00001010 00000000 00000000   10111
```

#### 4.5.7 网络负载均衡

> [网络负载均衡--百度百科]([https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/8441739?fr=aladdin](https://baike.baidu.com/item/网络负载均衡/8441739?fr=aladdin))
>
> (1)DNS负载均衡。在DNS中为多个地址配置同一个名字，查询这个名字的客户机将得到其中一个地址，从而使得不同的客户访问不同的服务器，达到负载均衡的目的。  
>
> (2)代理服务器。代理服务器将请求均匀转发给多台服务器，从而达到负载均衡的目的。 
>
> (3)负载均衡器。负载均衡器采用各种分配算法把网络请求分散到一个服务器集群中的可用服务器上去，有些负载均衡器集成在交换设备中，置于服务器与Internet链接之间，有些则以两块网络适配器将负载均衡功能集成到PC中，一块连接到 Internet上，一块连接到后端服务器群的内部网络上。当Web服务器为图像服务、安全套接层(SSL)会话或数据库事务而进行优化时，负载均衡器可以发挥特别功效。 

### 4.6 ICMP

#### 4.6.1 ICMP简介

​	为了提高IP数据报交付成功的机会，在网际层使用了忘记控制报文协议ICMP（Internet Control Message Protocol）。

​	**ICMP允许主机或路由器报告差错情况或提供有关异常情况的报告**。

​	ICMP不是高层协议，而是IP层的协议。

​	**ICMP报文作为IP层数据报的数据，加上数据报的首部，组曾IP数组报发送出去**。

#### 4.6.2 ICMP报文格式

> [ICMP--百度百科](https://baike.baidu.com/item/ICMP)
>
> ICMP（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/报文/3164352)协议。它是[TCP/IP协议簇](https://baike.baidu.com/item/TCP%2FIP协议簇)的一个子协议，用于在IP[主机](https://baike.baidu.com/item/主机/455151)、[路由](https://baike.baidu.com/item/路由)器之间传递控制消息。控制消息是指[网络通](https://baike.baidu.com/item/网络通)不通、[主机](https://baike.baidu.com/item/主机/455151)是否可达、[路由](https://baike.baidu.com/item/路由/363497)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 
>
> ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，**ICMP实际上是IP的一个组成部分**，必须由每个IP模块实现。
>
> 从技术角度来说，**ICMP就是一个“错误侦测与回报机制”**，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性。**当路由器在处理一个数据包的过程中发生了意外，可以通过ICMP向数据包的源端报告有关事件**。

![img](https://bkimg.cdn.bcebos.com/pic/d52a2834349b033bb56a90761bce36d3d439bdb8?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5)

#### 4.6.2 ICMP报文的类型

​	ICMP报文的种类有两种，即**ICMP差错报文**和**ICMP询问报文**。

​	ICMP报文的前4个字节是统一的格式，共有三个字段，即”**类型**“、代码和校验和。接着的4个字节的内容与ICMP的类型有关。

​	**差错报告报文**有五种（细分的话不止，详情可百度）：终点不可达、源点抑制（Source quench）（已弃用）、时间超过、参数问题、改变路由（重定向）（Redirect）。

​	**访问报文**有两种（同样不止，详细百度）：回送请求和回答报文，时间戳请求（弃用）和回答报文。

举例：

​	A--->B发送ICMP访问报文时，若B发现检验和出现差错，丢弃该数据报，并会送ICMP差错报文。

+ A--->B ,IP数据报：【ip首部】【ICMP前8字节】【ICMP数据部分--无用】
+ B收到后，检查ip首部的校验和，发现出错，于是丢弃【ICMP数据部分】，在剩余的【ip首部】【ICMP前8字节】前面再添加新的【ICMP前8字节】和【IP首部】，原本的【ip首部】【ICMP前8字节】作为新的ICMP数据部分，整体封装成一个IP数据报回送。
+ B--->A，【IP首部】【ICMP前8字节】【ICMP数据部分（原本A--->B的ip首部、ICMP前8字节）】

#### 4.6.3 ICMP应用举例

​	PING用来测试两个主机的连通性。

​	PING使用了ICMP回送请求与回送回答报文。

​	**PING是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP**。

​	其他相关指令：`pathing`（跟踪路由，分析丢包率）、`tracert`（跟踪路由）。

*（以太网Ping一般<=10ms。）*

*（使用tracert指令，中间出现请求超时，是因为有些经过的路由禁用了PING。）*

*使用ping能够判断网络通还是不同，比如请求超时，你就不能判断什么位置出现的网络故障造成的请求超时。使用pathping命令能跟踪数据报的路径，能够查出故障点，并且能够计算路由器转发丢包率和链路丢包率以及延迟，据此能够判断出网络拥塞情况。*

#### 4.6.4 ICMP优秀文章推荐

> [完全理解icmp协议](https://www.cnblogs.com/iiiiher/p/8513748.html) <== 下面摘取文章内容，建议阅读原文。

##### 完全理解icmp协议

###### 1. ICMP历史背景

​	在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP协议，交换各种各样的控制信息而被制造出来的。

​	制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议。也是，ICMP 是为了分担IP 一部分功能而被制定出来的。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306123828767-1055933232.png)

###### 2. ICMP的用途

​	在RFC，将ICMP 大致分成两种功能：差错通知和信息查询。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306123848996-664828184.png)

###### 3.ICMP作为IP的上层协议在工作

​	ICMP 的内容是放在IP 数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP 是IP 的上层协议。但是，正如RFC 所记载的，ICMP 是分担了IP 的一部分功能。所以，被认为是与IP 同层的协议。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306123940403-1730998630.png)

###### 4.ICMP实现之MTU探索

​	所谓路径MTU 探索，是探索与通信对方之间不用分片IP 数据包，就能交流的MTU 大小的功能。MTU大小是指计算机一次能够送出去的数据的最大长度，基本上由网路的种类来决定。例如，以太网的话通常是1500 字节，使用PPPoE 的ADSL 通常是1492 字节。为了实现这个路径MTU 探索，ICMP 被使用着。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124008880-235565291.png)

###### 5. ICMP实现之改变路由

​	改变路由是指路由器向送信方计算机指示路径改变这个功能。计算机根据自己的路由信息(路由表)来决定传送目标。不知道发给谁好的时候，就将数据包发给设为默认网关的路由器。被指定为默认网关的路由器接收到数据包，发现将数据包发给局域网内的其它路由器会比较快的时候，将这一信息通过ICMP 通知发送方。这时使用的是，类型是5，代码是1 的ICMP 改变路由报文。在选项数据部分里写着应该发送给的路由器IP 地址。Windows 收到这个报文后，重写自己的路由表，与对方的通信将在一段时间里经由被指定的路由器来实行。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124031302-2071500334.png)

###### 6. ICMP实现之源点抑制

​	数据包集中到达某一路由器后，数据包因为来不及被处理，有可能被丢弃的情况。这时候，向送信方发送的是ICMP 源点抑制报文，用来使送行方减慢发送速度。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124046051-967369342.png)

###### 7. ICMP实现之ping命令

​	ping 命令用来在IP 层次上调查与指定机器是否连通，调查数据包往复需要多少时间。为了实现这个功能，ping 命令使用了两个ICMP 报文。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124106517-1608215708.png)

###### 8. ICMP实现之traceroute命令

​	为了调查到通信对方的路径现在是怎么样了，使用的是traceroute 命令。它与ping 并列，是代表网络命令。这个traceroute 也是ICMP 的典型实现之一。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124141264-1747233430.png)

###### 9. ICMP实现之端口扫描

​	端口扫描大致分为“UDP 的端口扫描”和“TCP 的端口扫描”两种。这里面，与ICMP 相关的是UDP一边。使用TCP 的通信，通信之前必定要先遵循三向握手的程序。**因此，只要边错开端口号边尝试TCP连接就能调查端口的开闭**。不特别需要ICMP。与此相对，UDP 没有这样的连接程序。因此，调查端口是否打开需要想点办法。这样，被使用的是ICMP。**根据ICMP 规格，UDP 数据包到达不存在的端口时，服务器需要返回ICMP 的“终点不可达”之一的“端口不可达”报文。**

​	![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124203238-282815051.png)

###### 10. ICMP安全问题

​	那么实际上，ICMP 被怎样恶意使用的呢？想考虑安全相关问题，不知道这个就开不了头。看两个典型的恶意使用例子吧。

​	作为恶意使用ICMP 的最有代表性的例子，也就是所谓的 “ping 洪水”的攻击。它利用ping 的原理，向目标服务器发送大量的ICMP 回送请求。这是黑客向特定的机器连续发送大量的ICMP 回送请求报文。目标机器回答到达的ICMP 回送请求已经用尽全力了，原来的通信处理就变得很不稳定了。进一步，目标机器连接的网络也可能由于大量的ICMP 数据包而陷入不可使用的状态。

​	与ping 洪水相似，以更加恶劣的使用方法而闻名的是称为“smurf”的攻击手法。smurf 同样，黑客恶意的使用ICMP 回送请求报文。这一点同ping 洪水是相同的。不过在smurf，对ICMP 回送请求实施了一些加工。源IP 地址被伪装成攻击对象服务器的地址，目标地址也不是攻击对象服务器的地址，而是成为中转台的网络的广播地址。

仅从安全的方面来说，ICMP 是有百害而无一利的。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124330647-1424138830.png)

​	ICMP 作为支持IP的协议是需要的，所以被制作了。即使没有，也不是说IP 通信本身就完全不行了，实际上会出现几个难办的情况。
​	它的典型例子就是称为**“黑洞路由器”**的问题。所谓黑洞路由器，就是通信路径上的IP 数据包不留痕迹的消失了的现象。原因是，实现篇里说明的路径MTU 探索功能不起作用了。

![img](https://images2018.cnblogs.com/blog/806469/201803/806469-20180306124350950-2071209345.png)

​	假设通信路径上有因为MTU 大小不同而需要分片的路由器。而且，计算机和路由器之间，为了安全上的原因，设置了阻止ICMP 报文通过的防火墙。这种情况下，计算机实行路径MTU 探索将会怎么样呢？

1. 不能调整数据包长度
   	如果是传送路径上不需要分片大小的IP 数据包，它将会毫无问题地到达对方。另一方面，数据包的长度是需要分片的时候，发送就会有问题。
      	正如实现篇看到的，这样的数据包到达连接在不同大小MTU 的网络的路由器后，路由器将用ICMP 终点不可达报文来通知发送方。本来的处理是，送信方接收到该ICMP 报文，根据路径MTU 探索处理调整MTU 大小后继续通信。但是，这次的例子，ICMP 报文被路经中的防火墙隔断了。路径MTU 探索功能不起作用，MTU 的大小也就不能调整了。

2. 不知道原理就不可能理解
   	最近从局域网的计算机通过ADSL 服务访问万维网时，经常看到这个黑洞路由器现象。ADSL 线路的MTU 大小，宽带路由器的设定，Windows 的路径MTU 探索功之间互相关联引起了这个现象。糟糕的是，即使有黑洞路由器，也不是完全不能通信这一点。不管怎么样说，被吸进去的只是长度是需要分片的IP 数据包。也就是，考虑一下WEB 访问，连接WEB 服务器时是没有问题的，以文字为主体的页面也大都能被显示，但是含有比较大图像的页面不能被显示。黑洞路由器就由这种复杂奇怪的现象表现出来了。如果不知道路径MTU 探索和黑洞路由器的原理的话，碰到这种现象，可能连猜想原因都很困难了。

3. 即使阻止了客户端也没问题
   	如最初所见，在现实的万维网上，如果事先使所有的ICMP 功能有效的话，就会给了黑客各种各样的机会，安全上就会有问题了。
   另一方面，如果一个一个阻止了的话，不仅非常不方便，而且还会发生黑洞路由器等问题。那么，如何充分运用ICMP 才行呢？客户端，服务器，还有路由器，从各个方面来看一下。
   	首先从客户端开始。最近的宽带路由器和个人防火墙，通过设置来阻止ICMP 的很多。但是，初期设置是千差万别的。阻止全部ICMP 的也有，反过来的也有。其中，只允许ping 命令等一部分ICMP 报文通过的也有。
   	原来，对于安全的考虑方法是根据环境的不同而变化巨大的，并不是一定要这样才行的。但是，最近的倾向是，使连在万维网上的个人计算机不应答没有必要的ICMP 报文。例如Windows XP 的情况下，使用操作系统自带的个人防火墙的话，默认是将外部来的所有ICMP 报文隔断。

​	**那么路由器怎么样呢？万维网中的路由器，不小心阻断了ICMP 的话，会发生黑洞路由器等问题**。还有，大量的数据包涌过来的时候，如果不发送ICMP 源点抑制报文，处理速度就会跟不上。路由器的话，这样的情况以外，再加上考虑周围网络环境的基础上，再来判断是否阻断不需要的或者可能造成攻击的ICMP数据包比较好吧。
​	服务器就比较难判断了。例如，不让它回应ping 命令的话，连不上服务器的时候，就缺少了调查的有效手段。但是，有受到ping 洪水攻击的可能性也是事实。这些只能由管理者来判断了。

## 3.ICMP作为IP的上层协议在工作

### 4.7 内部网关协议RIP（Router Information Protocol）

#### 4.7.1 RIP概述

> [路由信息协议RIP--百度百科]([https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE/2707187?fromtitle=RIP&fromid=571852](https://baike.baidu.com/item/路由信息协议/2707187?fromtitle=RIP&fromid=571852))
>
> 路由信息协议RIP（Routing Information Protocol）是基于[距离矢量](https://baike.baidu.com/item/距离矢量)算法的[路由协议](https://baike.baidu.com/item/路由协议/202634)，利用跳数来作为计量标准。
>
> 在带宽、配置和管理方面要求较低，**主要适合于规模较小的网络中**。

RIP是一种分布式的基于**距离向量**的<u>路由选择协议</u>。

+ 最早
+ 周期性广播30秒*（广播告知邻居路由器到自己跳一次，邻居路由器告知下一个路由器，到自己1，到上一个路由器2...如果遇到重复的到X路由器，选择跳数最小的作为以后转发的路径，其余条数要求大的暂保留备用。）*
+ 跳数16*（第16跳不可达，也就是路由器最多跳转15次）*

```none
Net1 ---- Router1 ---- Net2 ---- Router2 ---- Net3
		  N1 1 直接				N1 2 R1
		  N2 1 直接				N2 1 直接
		  N3 2 R2				 N3 1 直接
```

RIP三要点：

1. 仅和**相邻路由器**交换信息。
2. 交换的信息是当前本路由器所知道的**全部信息**，即自己的路由表。

3. 按**固定的时间间隔**交换路由信息。

#### 4.7.2 RIP协议的优缺点

+ RIP存在的一个问题是**当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器**。*（如果某处故障，在其他路由器发起RIP请求前，以为没有故障，还是会继续往故障的地方发送数据，直到中间所有路由包括自己都重设路由表。**好消息传得快，坏消息传得慢**。）*
+ RIP协议最大的**优点就是简单，开销较小**。
+ RIP限制了网络的规模，它能使用的最大距离为15（16表示不可达）。
+ **路由器之间交换的路由器信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加**。

### 4.8 内部网关协议OSPF（Open Shortest Path First）

> [组播扩展OSPF--百度百科]([https://baike.baidu.com/item/%E7%BB%84%E6%92%AD%E6%89%A9%E5%B1%95OSPF?fromtitle=ospf&fromid=1166620](https://baike.baidu.com/item/组播扩展OSPF?fromtitle=ospf&fromid=1166620))
>
> OSPF(Open Shortest Path First[开放式最短路径优先](https://baike.baidu.com/item/开放式最短路径优先/8966505)）是一个[内部网关协议](https://baike.baidu.com/item/内部网关协议/167192)(Interior Gateway Protocol，简称IGP），用于在单一[自治系统](https://baike.baidu.com/item/自治系统)（autonomous system,AS）内决策[路由](https://baike.baidu.com/item/路由)。是对[链路状态路由协议](https://baike.baidu.com/item/链路状态路由协议/1219386)的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。著名的迪克斯加算法被用来计算[最短路径树](https://baike.baidu.com/item/最短路径树)。OSPF支持负载均衡和基于服务类型的选路，也支持多种路由形式，如特定主机路由和子网路由等。
>
> [自治系统--百度百科]([https://baike.baidu.com/item/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F](https://baike.baidu.com/item/自治系统))
>
> 自治系统：autonomous system。在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种[路由协议](https://baike.baidu.com/item/路由协议/202634)的小型单位。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的[网络管理员](https://baike.baidu.com/item/网络管理员/595848)来控制的网络群体，它是一个单独的可管理的[网络单元](https://baike.baidu.com/item/网络单元/9928606)（例如一所大学，一个企业或者一个公司个体）。一个自治系统有时也被称为是一个[路由选择](https://baike.baidu.com/item/路由选择)域（routing domain）。一个自治系统将会分配一个全局的唯一的16位号码，有时我们把这个号码叫做自治系统号（ASN）。

#### 4.8.1 OSPF概述

1. **向本自治系统**中所有路由器发送信息，这里使用的方法是洪泛法。
2. 发送的信息就是与本路由器**相邻**的所有路由器的链路状态，但这只是路由器所知道的**部分信息**（RIP则交换全部）。
3. **只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。**

几个要点：

+ 动态路由协议
+ 开放式
+ **度量值为带宽**
+ 支持多区域*（和网络地址规划有关，**各个区域的链路状态组播数据LSA互不影响**）*
+ 触发式更新
+ 三张表
  + 邻居表
  + 链路状态表
  + 计算路由表*（不会产生环路）*

​	OSPF路由协议是一种典型的链路状态（Link-state）的路由协议，一般用于同一个路由域内。在这里，[路由域](https://baike.baidu.com/item/路由域)是指一个[自治系统](https://baike.baidu.com/item/自治系统)（Autonomous System），即AS，它是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF[路由器](https://baike.baidu.com/item/路由器)都维护一个相同的描述这个AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。 

​	**作为一种链路状态的[路由协议](https://baike.baidu.com/item/路由协议)，OSPF将链路状态组播数据LSA（Link State Advertisement）传送给在某一区域内的所有路由器，这一点与距离[矢量路由协议](https://baike.baidu.com/item/矢量路由协议)不同。运行距离矢量路由协议的路由器是将部分或全部的[路由表](https://baike.baidu.com/item/路由表)传递给与其相邻的路由器。** 

​	在信息交换的安全性上，OSPF规定了路由器之间的任何信息交换在必要时都可以经过认证或鉴别（Authentication），以保证只有可信的路由器之间才能传播选路信息。OSPF支持多种鉴别机制，并且允许各个区域间采用不同的鉴别机制。OSPF对链路状态算法在广播式网络（如以太网）中的应用进行了优化，以尽可能地利用硬件广播能力来传递链路状态报文。通常链路状态算法的拓扑图中一个结点代表一个路由器。**若K个路由器都连接到以太网上，在广播链路状态时，关于这K个路由器的报文将达到K的平方个。为此，OSPF在拓扑结构图允许一个结点代表一个广播网络。每个广播网络上所有路由器发送链路状态报文，报告该网络中的路由器的链路状态。**

> [内部网关协议--百度百科]([https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE/167192](https://baike.baidu.com/item/内部网关协议/167192))
>
> [IGP](https://baike.baidu.com/item/IGP)（内部[网关](https://baike.baidu.com/item/网关/98992)[协议](https://baike.baidu.com/item/协议/670528)）是在一个自治[网络](https://baike.baidu.com/item/网络/143243)内[网关](https://baike.baidu.com/item/网关)（[主机](https://baike.baidu.com/item/主机/455151)和[路由器](https://baike.baidu.com/item/路由器/108294)）间交换[路由](https://baike.baidu.com/item/路由/363497)信息的[协议](https://baike.baidu.com/item/协议)。[路由](https://baike.baidu.com/item/路由/363497)信息能用于[网间协议](https://baike.baidu.com/item/网间协议/10502135)（[IP](https://baike.baidu.com/item/IP)）或者其它[网络协议](https://baike.baidu.com/item/网络协议/328636)来说明路由传送是如何进行的。IGP[协议](https://baike.baidu.com/item/协议/670528)包括RIP、OSPF、IS-IS、IGRP、EIGRP。
>
> 内部网关协议可以划分为两类：**距离矢量路由协议**和**链路状态路由协议**。

#### 4.8.2 OSPF区域

> [OSPF中第一类外部路由和第二类外部路由的区别？](https://zhidao.baidu.com/question/589241945592120885.html)
>
> [ABR(区域边界路由器)--百度百科](https://baike.baidu.com/item/ABR/9827860?fr=aladdin)
>
> ABR是位于一个或多个OSPF区域边界上，将这些区域连接到主干网络的[路由器](https://baike.baidu.com/item/路由器/108294)。
>
> ABR（area border router）
>
> ABR被认为同时是OSPF主干和相连区域的成员。因此，它们**同时维护着描述主干拓扑和其他区域拓扑的路由选择表**。
>
> **该类路由器可以同时属于两个以上的区域，但其中一个必须是骨干区域。ABR用来连接骨干区域和非骨干区域，它与骨干区域之间既可以是物理连接，也可以是逻辑上的连接。**

​	OSPF 中划分区域的目的就是在于控制链路状态信息[LSA](https://baike.baidu.com/item/LSA/8860267) 泛洪的范围、减小链路状态数据库[LSDB](https://baike.baidu.com/item/LSDB/567391)的大小、改善网络的可扩展性、达到快速地收敛。

​	当网络中包含多个区域时，OSPF 协议有特殊的规定，即其中**必须有一个 Area 0，通常也叫做骨干区域（Backbone Area）**，当设计 OSPF 网络时，一个很好的方法就是从骨干区域开始，然后再扩展到其他区域。**骨干区域在所有其他区域的中心，即所有区域都必须与骨干区域物理或逻辑上相连**，这种设计思想的原因是 OSPF 协议要把所有区域的路由信息引入骨干区，然后再依次将路由信息从骨干区域分发到其它区域中。

​	**由于划分出来的区域都必须和骨干区域连接，所以只能再分出二级区域，不存在第三级**。

#### 4.8.3 OSPF特点

+ OSPF不用UDP而是**直接用IP数据报传输**。
+ OSPF对不同的链路可根据IP分组的不同服务类型而设置不同的代价。因此，OSPF对不同类型的业务可计算出不同的路由。
+ **如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载平衡**。
+ 所有在OSPF路由之间交换的分组都具有鉴别的功能。
+ **支持可变长度的子网划分和无类别编址CIDR**。

+ 每一个链路状态都带上一个32位的序号，序号越大状态越新。

#### 4.8.4 OSPF的基本操作

```none
===============     路由器1 --------------------- 路由器2
 确认可达性	 					问候-->
                             <--问候
================               
	达到							数据库表述-->
	数据库						<--数据库表述
	的同步							数据库表述-->
							<--数据库表述
=================
  新情况下的					链路状态请求--->
  同步					  <----链路状态更新
							链路状态确认--->
=================
```

#### 4.8.5 回顾OSPF和RIP

1. OSPF

   [OSPF](https://baike.baidu.com/item/OSPF)开放最短路径优先(Open Shortest Path First)，是一个内部[网关](https://baike.baidu.com/item/网关)[协议](https://baike.baidu.com/item/协议)(Interior Gateway Protocol,简称IGP)，用于在单一[自治系统](https://baike.baidu.com/item/自治系统)(autonomous system,AS)内决策[路由](https://baike.baidu.com/item/路由)。与RIP相对，OSPF是[链路状态路由协议](https://baike.baidu.com/item/链路状态路由协议)，而RIP是[距离向量路由协议](https://baike.baidu.com/item/距离向量路由协议)。链路是[路由器](https://baike.baidu.com/item/路由器)接口的另一种说法，因此OSPF也称为接口状态[路由协议](https://baike.baidu.com/item/路由协议)。OSPF通过[路由器](https://baike.baidu.com/item/路由器)之间通告[网络](https://baike.baidu.com/item/网络)接口的状态来建立链路状态数据库，生成[最短路径](https://baike.baidu.com/item/最短路径)树，每个OSPF[路由器](https://baike.baidu.com/item/路由器)使用这些最短路径构造路由。最主要的特点是使用分布式的链路状态[协议](https://baike.baidu.com/item/协议)，而不是像RIP那样的[距离向量协议](https://baike.baidu.com/item/距离向量协议)。三个要点：（1）向本[自治系统](https://baike.baidu.com/item/自治系统)中所有路由器发送信息。（2）发送的信息就是与本[路由器](https://baike.baidu.com/item/路由器)相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。（3）只有在链路状态发生变化时，[路由器](https://baike.baidu.com/item/路由器)才向所有路由器用[洪泛](https://baike.baidu.com/item/洪泛)法发送此信息。

2. RIP

   [RIP](https://baike.baidu.com/item/RIP)（Routing Information Protocol） ,[路由信息协议](https://baike.baidu.com/item/路由信息协议)，是内部[网关](https://baike.baidu.com/item/网关)协议中应用最广泛的一种协议，它是一种分布式的，基于[距离向量](https://baike.baidu.com/item/距离向量)的[路由选择协议](https://baike.baidu.com/item/路由选择协议)，其特点是协议简单。适用于相对较小的[自治系统](https://baike.baidu.com/item/自治系统)，它们的直径“跳数”一般小于15。 RIP[协议](https://baike.baidu.com/item/协议)特点是：（1）仅和相邻[路由](https://baike.baidu.com/item/路由)交换信息（2）[路由器](https://baike.baidu.com/item/路由器)交换的信息是当前本[路由器](https://baike.baidu.com/item/路由器)所知道的全部信息，即自己的路由表。也就是说，交换的信息是：“我到本[自治系统](https://baike.baidu.com/item/自治系统)中所有[网络](https://baike.baidu.com/item/网络)的（最短）距离，以及到那个网络应经过的[下一跳](https://baike.baidu.com/item/下一跳)路由器。”（3）按固定时间间隔交换[路由](https://baike.baidu.com/item/路由)信息，例如，每隔30秒。然后[路由器](https://baike.baidu.com/item/路由器)根据收到的路由信息更新[路由表](https://baike.baidu.com/item/路由表)。

### 4.9 外部网关协议BGP

> [边界网关协议BGP--百度百科]([https://baike.baidu.com/item/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE/2987527?fromtitle=bgp&fromid=91408&fr=aladdin](https://baike.baidu.com/item/边界网关协议/2987527?fromtitle=bgp&fromid=91408&fr=aladdin))
>
> 边界网关协议（BGP）是运行于 TCP 上的一种[自治系统](https://baike.baidu.com/item/自治系统/129715)的[路由协议](https://baike.baidu.com/item/路由协议/202634)。 **BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关[路由域](https://baike.baidu.com/item/路由域/1665630)间的多路连接的协议**。 BGP 构建在 EGP 的经验之上。 BGP 系统的主要功能是和其他的 BGP 系统交换网络可达信息。网络可达信息包括列出的[自治系统](https://baike.baidu.com/item/自治系统/129715)（AS）的信息。这些信息有效地构造了 AS 互联的拓朴图并由此清除了[路由环路](https://baike.baidu.com/item/路由环路/8975272)，同时在 AS 级别上可实施策略决策。
>
> 由于可能与不同的AS相连，在一个AS内部可能存在多个运行BGP的边界路由器。同一个自治系统(AS)中的两个或多个对等实体之间运行的BGP 被称为 IBGP（Internal/Interior BGP）。归属不同的AS的对等实体之间运行的BGP称为EBGP （External/Exterior BGP）。在AS边界上与其他AS交换信息的路由器被称作边界路由器(border/edge router)。**在互联网操作系统（Cisco IOS）中，IBGP通告的路由的距离为200，优先级比EBGP和任何内部网关协议（IGP）通告的路由都低。其他的路由器实现中，优先级顺序也是EBGP高于IGP，而IGP又高于IBGP。**

#### 4.9.1 BGP概述

BGP是不同自治系统的路由器之间交换路由信息的协议，BGP较新版本是BGP-4。

边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。

**每一个自治系统AS的管理员至少要选择一个路由器作为该自治系统的“BGP发言人”**。

*（自治系统的动态路由协议一般是RIP（跳数）或者OSPF（带宽）。）*

​	BGP属于外部网关路由协议，可以**实现自治系统间无环路的域间路由**。BGP是**沟通Internet广域网的主用路由协议**，例如不同省份、不同国家之间的路由大多要依靠BGP协议。BGP可分为IBGP（Internal BGP）和EBGP（External BGP）。BGP的邻居关系（或称通信对端/对等实体）是通过**人工配置**实现的，对等实体之间通过TCP（端口179)会话交互数据。BGP路由器会周期地发送19字节的保持存活keep-alive消息来维护连接（默认周期为30秒）。==**在路由协议中，只有BGP使用TCP作为传输层协议**==。

#### 4.9.2 BGP协议的特点

+ BGP协议交换路由信息数量不是很多
+ BGP发言人数目不多，路由选择相对简单
+ BGP协议支持CIDR
+ **BGP建立时，交换整个路由表但之后只交换变化部分**。

​	BGP属于外部或域间路由协议。BGP的主要目标是为处于不同AS中的路由器之间进行路由信息通信提供保障。**BGP既不是纯粹的矢量距离协议（eg：RIP），也不是纯粹的链路状态协议（eg：OSPF），通常被称为通路向量路由协议。**这是因为BGP在发布到一个目的网络的可达性的同时，包含了在IP分组到达目的网络过程中所必须经过的AS的列表。通路向量信息时十分有用的，因为只要简单地查找一下BGP路由更新的AS编号就能有效地避免环路的出现。BGP对网络拓扑结构没有限制，其特点包括：

（1）实现自治系统间通信，传播网络的可达信息。BGP 是一个外部网关协议，允许一个AS与另一个AS进行通信。BGP允许一个AS向其他AS通告其内部的网络的可达性信息，或者是通过该AS可达的其他网络的路由信息。同时，AS也能够从另一个AS中了解这些信息。与距离向量选路协议类似，BGP为每个目的网络提供的是下一跳（next-hop）结点的信息。

（2）多个BGP路由器之间的协调。如果在一个自治系统内部有多个路由器分别使用BGP与其他自治系统中对等路由器进行通信，BGP可以协调者一系列路由器，使这些路由器保持路由信息的一致性。

（3）<u>BGP支持基于策略的选路（policy-base routing）。一般的距离向量选路协议确切通告本地选路中的路由。而BGP则可以实现由本地管理员选择的策略。BGP路由器可以为域内和域间的网络可达性配置不同的策略</u>。

（4）可靠的传输。BGP路由信息的传输采用了可靠的TCP协议。

（5）路径信息。在BGP通告目的网络的可达性信息时，处理指定目的网络的下一跳信息之外，通告中还包括了通路向量（path vector），即去往该目的网络时需要经过的AS的列表，使接受者能够了解去往目的网络的通路信息。

（6）增量更新。BGP不需要再所有路由更新报文中传送完整的路由数据库信息，只需要在启动时交换一次完整信息。后续的路由更新报文只通告网络的变化信息。这种网络变化的信息称为增量（delta）。

（7）BGP支持无类型编制（CIDR）及VLSM方式。通告的所有网络都以网络前缀加子网掩码的方式表示。

（8）**路由聚集**。BGP允许发送方把路由信息聚集在一起，用一个条目来表示多个相关的目的网络，以节约网络带宽。

（9）**BGP还允许接收方对报文进行鉴别和认证，以验证发送方的身份**。

### 4.10 广域网

#### 4.10.1 VPN

> [虚拟专用网络VPN--百度百科]([https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/8747869?fromtitle=VPN&fromid=382304&fr=aladdin](https://baike.baidu.com/item/虚拟专用网络/8747869?fromtitle=VPN&fromid=382304&fr=aladdin))
>
> 虚拟专用网络(VPN)的功能是：在[公用网络](https://baike.baidu.com/item/公用网络/12752077)上建立[专用网络](https://baike.baidu.com/item/专用网络/795899)，进行[加密](https://baike.baidu.com/item/加密/752748)通讯。在[企业网络](https://baike.baidu.com/item/企业网络/2119389)中有广泛应用。[VPN](https://baike.baidu.com/item/VPN)网关通过对[数据包](https://baike.baidu.com/item/数据包/489739)的加密和数据包目标地址的转换实现[远程访问](https://baike.baidu.com/item/远程访问/3326708)。VPN可通过[服务器](https://baike.baidu.com/item/服务器/100571)、硬件、软件等多种方式实现。
>
> [远程访问服务器RAS--百度百科]([https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/1549611?fr=aladdin](https://baike.baidu.com/item/远程访问服务器/1549611?fr=aladdin))
>
> 远程访问服务器(Remote Access Service,RAS)，就是把在互联网中的计算机和在局域网中的远程访问服务器（RAS）相连接，从而在RAS和RAC（远程访问客户机，就是在互联网中的某计算机）建立一个虚拟专用线路来直接接入到RAS，连接上RAS后，就可以访问处于RAS的局域网从而获取在局域网中的资源。
>
> 远程访问服务允许客户机通过拨号连接或虚拟专用连接登录网络。远程客户机一旦得到RAS服务器的确认，就可以访问网络服务，就好像客户机直接连接在局域网上一样。
>
> 比如在外地工作的公司人员需要公司的重要文件，为防泄密不希望用邮件或其他方式传输，这时候工作人员（RAC）就可以连接上RAS，通过RAS和RAC之间的虚拟专用网络来访问处于RAS的局域网（公司局域网）下载文件。
>
> **要建立一个RAS，操作系统必须为服务器版本，且具有双网卡，用以链接局域网和互联网**.
>
> [vpn的实现原理_百度经验](https://baijiahao.baidu.com/s?id=1553125345857132&wfr=spider&for=pc)
>
> [使用VPN会改变IP地址吗](https://zhidao.baidu.com/question/1888304534150464268.html)
>
> 不会。VPN连接成功后不会改变本地网卡的IP地址，而会增加一个VPN的[虚拟网卡](http://www.3yan.cn/topic/xuniwangka)，VPN虚拟网卡的IP地址与目标VPN网络属于同一个网段。VPN连接后在[电脑](http://www.3yan.cn/topic/diannao)路由表中生成一条默认路由（我试了下，确实本地多了ipconfig条以太网适配器 以太网3 10.90.197.116，抓包则源地址皆为该VPN网关，而目的地址则是VPN另一头远程服务器的某些服务器IP地址），出口为虚拟网卡，其**优先级最高，电脑中的所有上网流量会优先从虚拟网卡发送**。
>
> [vpn服务器IP分配问题 是跟内网同一个网段还是不同一网段？](https://zhidao.baidu.com/question/396997446.html)
>
> 一般不同网段。（我觉得是避免ARP以为是本地局域网就只在本地查找IP对应的MAC了。）

+ 虚拟专用网络（Virtual Private Network，VPN）可以通过特殊的加密的通信协议在连接在Internet上的位于不同地方的两个或多个企业内部网之间简历一条专有的通信线路，其核心就是在利用公共网络建立虚拟私有网。
+ 远程用户可以通过Internet建立到企业内部网络的VPN连接，这样该用户就可以像是在内网一样访问企业内部网络的任意计算机。

下面举个实际连接VPN时，查看`ifconfig /all`的配置 

```none
以太网适配器 以太网3：
	连接特定的DNS后缀：
	描述：Array Networks VPN Adapter
	物理地址： 某 48位
	DHCP已启用: 否
	自动配置已启用：是
	IPv4地址：10.90.197.116(首选)    #可见连接VPN时虚拟出来的虚拟网卡，其配置优先级最高
	子网掩码：255.255.0.0
	默认网关：
	DNS服务器：127.0.0.1
	TCPIP上的NetBIOS：已启用
```

此时若访问需要该VPN才能访问的网站，抓包，发现源地址即VPN虚拟网关`10.90.197.116`,获得的响应其目的地址同样是VPN的`10.90.197.116`。（一般每次不一样，比如我断开VPN后，第二次重开VPN就变成`10.90.201.6`）

实际工作流程大致如下：

```none
# 就拿我本地VPN虚拟网关为10.90.197.116 255.255.0.0作为样例
# 我想要访问VPN代理后才能访问的因特网上某一个局域网

(1) 我使用VPN网关发送数据10.90.197.116，预访问对面局域网的10.90.223.100(这个随便写的)
【IP源地址10.90.197.116】【IP目的地址10.90.223.100】{数据部分}
(2) VPN再IP数据报前再添加对面远程RAS所在网段的某一地址作为源地址;比如对面RAS的公网IP为23.23.2.2,那么VPN给本地访问RAS的源地址设置为23.23.2.20(都是瞎编的)
【IP源地址23.23.2.20】【IP目的地址23.23.2.2】{【IP源地址10.90.197.116】【IP目的地址10.90.223.100】{数据部分}}

(3) 通过和远程目的局域网的RAS(远程访问服务器)建立的连接(PPTP or L2TP)发送数据到对面RAS{一般本地VPN会和对面RAS配合，进行一些身份认证、加密解密等操作}
(4) 对面RAS接收到数据后，把原本VPN添加的外层IP数据报头去掉，再继续把数据报传输到内部局域网
【IP源地址10.90.197.116】【IP目的地址10.90.223.100】{数据部分}

(5) 对面局域网10.90.223.100接受到数据报后，回应时，再把我们本地的VPN网关10.90.197.116作为目的地址，同样发送给RAS
【IP源地址10.90.223.100】【IP目的地址10.90.197.116】{数据部分}
(6) RAS收到数据报后，根据根据IP目的地址为10.90.197.116，查表，包装IP数据报，再发送回我们这里的VPN网关
【IP源地址23.23.2.2】【IP目的地址23.23.2.20】{【IP源地址10.90.223.100】【IP目的地址10.90.197.116】{数据部分}}

(7) VPN收到来自RAS的数据报，再舍弃最外层IP数据报的IP首部字段
【IP源地址10.90.223.100】【IP目的地址10.90.197.116】{数据部分}
```

如果是windows7使用系统自带的VPN服务，配置VPN时，有个`在远程网络上使用默认网关`的选项。

在`远程网络上使用默认网关`，即所有VPN代理的流量，不管访问的是VPN制定的对面内部局域网，还是访问我们本来就能正常访问的正常因特网，我们访问流程都变成`本地VPN--> 对面远程RAS --> 对面局域网or我们本来自己就能访问的因特网`。很明显，大多数情况下，访问正常的因特网，我们没必要再特地经过VPN代理，这样网速还更慢，这时候我们去掉勾选的`远程网络上使用默认网关`，那么访问对面局域网时，还是`本地VPN--> 对面远程RAS --> 对面局域网`，访问因特网时，则直接`本地原本连接外网的网关-->我们自己能访问的因特网`。

*（上面这些这个`远程网络上使用默认网关`经常也被VPN叫作`全局模式`，不开启则是`PAC`模式。亲测`远程网络上使用默认网关`的选项弃用时，访问正常因特网还是用的本地默认网关；而访问VPN和对面RAS协商的指定网段时，才会走VPN。）*

VPN还有一些奇葩的使用情况：

比如ABC三个网络环境不同（理解为三个互不相干的局域网。）

此时，A和C因为某些原因，需要互相访问，但是两种都没有设置`远程访问服务器RAS`，所以不能通过VPN互联，但是B有`远程访问服务器RAS`，其归C管理。于是C通过VPN连接B，并且新增VPN用户账号，通过电话、邮件等方式把该账号告知A，那么A和C就能通过都通过VPN连接到网络C中，互相访问对方。（连接VPN就类似把自己电脑搬到对面RAS管理的网段内。这里约等于，两个人都变成B网络内的主机了，所以能互相访问）。

> [为什么SSH比vpn快很多？](https://www.v2ex.com/t/34408)
>
> [ipsec vpn数据包的封装和传输过程](https://www.geek-share.com/detail/2487247744.html)

虚拟专用网VPN

​	**本地地址**——仅在机构内部使用的IP地址，可以由本机构自行分配，而不需要向因特网的管理机构申请。

​	**全球地址**——全球唯一的IP地址，必须向因特网的管理机构申请。

RFC1918指明的专用地址（private address）：

+ `10.0.0.0`~`10.255.255.255`
+ `172.16.0.0`~`172.31.255.255`
+ `192.168.0.0`~`192.168.255.255`

**通过隧道技术实现虚拟专用网，这在现实的连锁店管理等场景经常使用**。

#### 4.10.2 点对点隧道协议(PPTP)

> [点对点隧道协议--百度百科]([https://baike.baidu.com/item/%E7%82%B9%E5%AF%B9%E7%82%B9%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE/8090794?fromtitle=PPTP&fromid=610663&fr=aladdin](https://baike.baidu.com/item/点对点隧道协议/8090794?fromtitle=PPTP&fromid=610663&fr=aladdin))
>
> 点对点隧道[协议](https://baike.baidu.com/item/协议/670528)（PPTP，Point-to-Point Tunneling Protocol）是一种协议（一套通信规则），它允许企业通过私人“隧道”在公共网络上扩展自己的企业网络。
>
> [通用路由封装GRE--百度百科]([https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E8%B7%AF%E7%94%B1%E5%B0%81%E8%A3%85](https://baike.baidu.com/item/通用路由封装))
>
> GRE（Generic Routing Encapsulation，通用路由封装）协议是对某些网络层协议（如IP 和IPX）的数据[报文](https://baike.baidu.com/item/报文)进行封装，使这些被封装的数据报文能够在另一个网络层协议（如IP）中传输。**GRE采用了Tunnel（隧道）技术，是VPN（Virtual Private Network）的第三层隧道协议。**
>
> Tunnel 是一个虚拟的点对点的连接，提供了一条通路使封装的数据报文能够在这个通路上传输，并且在**一个Tunnel 的两端分别对数据报进行封装及解封装**。一个X协议的报文要想穿越IP网络在Tunnel中传输，必须要经过**加封装**与**解封装**两个过程。
>
> [抓包分析GRE Tunnel的Keepalive机制](https://forum.huawei.com/enterprise/zh/thread-255889.html)
>
> [L2TP--百度百科](https://baike.baidu.com/item/L2TP/609253?fr=aladdin)
>
> L2TP（第二层隧道协议，Layer Two Tunneling Protocol）是一种工业标准的Internet隧道协议，功能大致和[PPTP协议](https://baike.baidu.com/item/PPTP协议)类似，比如同样可以对[网络数据](https://baike.baidu.com/item/网络数据)流进行加密。不过也有不同之处，比如PPTP要求网络为[IP网络](https://baike.baidu.com/item/IP网络)，L2TP要求面向数据包的点对点连接；**PPTP使用单一隧道，L2TP使用多隧道；L2TP提供包头压缩、隧道验证，而PPTP不支持。**
>
> [ipsec--百度百科](https://baike.baidu.com/item/IPSec/2472311)
>
> （英语：Internet Protocol Security，缩写为IPsec），是一个协议包，通过对[IP协议](https://baike.baidu.com/item/IP协议)的[分组](https://baike.baidu.com/item/分组)进行[加密](https://baike.baidu.com/item/加密)和[认证](https://baike.baidu.com/item/认证)来保护IP协议的[网络传输协议](https://baike.baidu.com/item/网络传输协议)族（一些相互关联的协议的集合）。

​	**点对点隧道协议**（英语：Point to Point Tunneling Protocol，缩写为PPTP）是实现[虚拟专用网](https://baike.baidu.com/item/虚拟专用网)（VPN）的方式之一。PPTP使用[传输控制协议](https://baike.baidu.com/item/传输控制协议)（TCP）创建控制通道来发送控制命令，以及利用[通用路由封装](https://baike.baidu.com/item/通用路由封装)（GRE）通道来封装[点对点协议](https://baike.baidu.com/item/点对点协议)（PPP）数据包以发送数据。**这个协议最早由[微软](https://baike.baidu.com/item/微软)等厂商主导开发，但因为它的加密方式容易被破解，微软已经不再建议使用这个协议**。

​	PPTP的协议规范本身并未描述[加密](https://baike.baidu.com/item/加密)或[身份验证](https://baike.baidu.com/item/身份验证)的部分，它依靠[点对点协议](https://baike.baidu.com/item/点对点协议)（PPP）来实现这些安全性功能。因为PPTP协议内置在[微软](https://baike.baidu.com/item/微软)视窗系统家族的各个产品中，在微软[点对点协议](https://baike.baidu.com/item/点对点协议)（PPP）协议堆栈中，提供了各种标准的身份验证与加密机制来支持PPTP。 在微软视窗系统中，它可以搭配[PAP](https://baike.baidu.com/item/PAP)、[CHAP](https://baike.baidu.com/item/CHAP)、[MS-CHAP](https://baike.baidu.com/item/MS-CHAP)v1/v2或EAP-TLS来进行身份验证。通常也可以搭配微软点对点加密（MPPE）或[IPSec](https://baike.baidu.com/item/IPSec)的加密机制来提高安全性。

> [网络隧道Tunnel技术](https://blog.csdn.net/wangjianno2/article/details/75208036)
>
> 通过隧道技术组网，一般需要走互联网公网，公网的网络质量不可控，所以tunnel的通信质量取决于运营商公网的质量哦。和隧道技术组网相对的是专线组网，即租用运营商的物理专线，来连通异地的网络。专线的弱点就是成本代价很高哦。

### 4.11 网络地址转换NAT

>[nat （网络地址转换方法）--百度百科](https://baike.baidu.com/item/nat/320024?fr=aladdin)
>
>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（**并不需要加密**）时，可使用NAT方法。
>
>这种方法**需要在专用网连接到因特网的路由器上安装NAT软件**。装有NAT软件的路由器叫做NAT路由器，**它至少有一个有效的外部全球IP地址**。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
>
>另外，<u>这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭</u>。在[RFC](https://baike.baidu.com/item/RFC/10718878) 2663中有对NAT的说明。

#### 4.11.1 NAT概述

**功能**：

​	NAT不仅能解决IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。

​	1.**宽带分享**：这是 NAT 主机的最大功能。

​	2.安全防护：NAT 之内的 PC 联机到 Internet 上面时，他所显示的 IP 是 NAT 主机的公共 IP，所以 Client 端的 PC 当然就具有一定程度的安全了，外界在进行 portscan（端口扫描） 的时候，就侦测不到源Client 端的 PC 。

**实现方式**：

​	NAT的实现方式有三种，即**静态转换Static Nat**、**动态转换Dynamic Nat**和**端口多路复用OverLoad**。

​	1. [**静态**](https://baike.baidu.com/item/静态)**转换**是指将内部网络的私有IP地址转换为公有IP地址，**IP地址对是一对一**的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于[静态](https://baike.baidu.com/item/静态)转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。

​	2. **动态转换**是指将内部网络的私有IP地址转换为公用IP地址时，**IP地址是不确定的，是随机的**，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。<u>当[ISP](https://baike.baidu.com/item/ISP/10152)提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式</u>。

​	3. **端口多路复用（Port address Translation,PAT)**是指改变外出数据包的[源端口](https://baike.baidu.com/item/源端口)并进行端口转换，即端口[地址转换](https://baike.baidu.com/item/地址转换)（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有[主机](https://baike.baidu.com/item/主机)均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有[主机](https://baike.baidu.com/item/主机)，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。

​	**ALG（Application Level Gateway）**，即应用程序级网关技术：**传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换**。例如：对于FTP协议的PORT/PASV命令、DNS协议的 "A" 和 "PTR" queries命令和部分ICMP消息类型等都需要相应的ALG来支持。

​	<u>如果协议数据报文中不包含地址信息，则很容易利用传统的NAT技术来完成透明的地址转换功能</u>，通常我们使用的如下应用就可以直接利用传统的NAT技术：**HTTP、TELNET**、FINGER、NTP、NFS、ARCHIE、RLOGIN、RSH、RCP等。

​	*虽然NAT可以借助于某些[代理服务器](https://baike.baidu.com/item/代理服务器)来实现，但考虑到运算成本和网络性能，很多时候都是在[路由器](https://baike.baidu.com/item/路由器)上来实现的。*

*cmd使用指令·`netstat -n`查看主机与外部建立的会话*

#### 4.11.2 NAPT(PAT)概述

​	NAPT（Network Address Port Translation），即网络地址端口[转换](https://baike.baidu.com/item/转换)，可将多个内部[地址映射](https://baike.baidu.com/item/地址映射)为一个合法公网地址，但以不同的协议[端口号](https://baike.baidu.com/item/端口号)与不同的内部地址相对应，也就是**<内部地址+内部端口>与<外部地址+外部端口>之间的转换**。NAPT普遍用于[接入设备](https://baike.baidu.com/item/接入设备)中，它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT也被称为“多对一”的NAT，或者叫PAT（Port Address Translations，端口[地址转换](https://baike.baidu.com/item/地址转换)）、地址超载（address overloading）。

​	NAPT与[动态地址](https://baike.baidu.com/item/动态地址)NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP[端口号](https://baike.baidu.com/item/端口号)。<u>NAPT算得上是一种较流行的NAT变体，通过转换TCP或UDP协议[端口号](https://baike.baidu.com/item/端口号)以及地址来提供并发性。除了一对源和目的IP地址以外，这个表还包括一对源和目的协议[端口号](https://baike.baidu.com/item/端口号)，以及NAT盒使用的一个协议端口号</u>。

​	NAPT的主要优势在于，能够使用一个全球有效IP地址获得通用性。**主要缺点在于其通信仅限于TCP或UDP**。<u>当所有通信都采用TCP或UDP，NAPT允许一台内部计算机访问多台外部计算机，并允许多台内部[主机](https://baike.baidu.com/item/主机)访问同一台外部计算机**相互之间不会发生冲突**</u>。

#### 4.11.3 NAT转换方法

> [Network address translation -- wiki](https://en.wikipedia.org/wiki/Network_address_translation)

**Full cone NAT**

即著名的一对一（one-to-one）NAT

![File:Full Cone NAT.svg](https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Full_Cone_NAT.svg/709px-Full_Cone_NAT.svg.png)

一旦一个内部地址（iAddr:port1）映射到外部地址（eAddr:port2），所有发自iAddr:port1的包都经由eAddr:port2向外发送。任意外部主机都能通过给eAddr:port2发包到达iAddr:port1

**Address-Restricted cone NAT**

限制地址，即只接收曾经发送到对端的IP地址来的数据包。

![File:Restricted Cone NAT.svg](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Restricted_Cone_NAT.svg/709px-Restricted_Cone_NAT.svg.png)

一旦一个内部地址（iAddr:port1）映射到外部地址（eAddr:port2），所有发自iAddr:port1的包都经由eAddr:port2向外发送。任意外部主机（hostAddr:any）都能通过给eAddr:port2发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:any. "any"也就是说端口不受限制

**Port-Restricted cone NAT**

![File:Port Restricted Cone NAT.svg](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/Port_Restricted_Cone_NAT.svg/709px-Port_Restricted_Cone_NAT.svg.png)

类似受限制锥形NAT（Restricted cone NAT），但是还有端口限制。

一旦一个内部地址（iAddr:port1）映射到外部地址（eAddr:port2），所有发自iAddr:port1的包都经由eAddr:port2向外发送。一个外部主机（hostAddr:port3）能够发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:port3.

**Symmetric NAT（对称NAT）**

![File:Symmetric NAT.svg](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Symmetric_NAT.svg/709px-Symmetric_NAT.svg.png)

**每一个来自相同内部IP与port的请求到一个特定目的地的IP地址和端口，映射到一个独特的外部来源的IP地址和端口**。

**同一个内部主机发出一个信息包到不同的目的端，不同的映射使用**

外部主机收到了一封包从一个内部主机可以送一封包回来

> [NAT的四种类型](https://blog.csdn.net/mycloudpeak/article/details/53550405)
>
> **现在一般家用路由，都是锥形NAT**。
>
> [Linux NAT 类型详解](https://blog.csdn.net/sdc20102010/article/details/80112580)
>
> **对称型nat** : 就是内网同一ip和端口发往**不同**外网的ipx + port x 时 在route 端（nat）都会**映射成ipnat + 不同的端口**。
>
> **锥形型nat** : 就是内网同一ip和端口发往**不同**外网的ipx + port x 时 在route 端（nat）都会**映射成相同的ip + 相同的端口**。
>
> [家用的路由器是对称型的nat还是非对称型的nat？](https://www.zhihu.com/question/312439541/answer/911848519)
>
> 家用一般非对称NAT（锥形）。而大型公司网络中经常采用的对称型NAT（又称为双向NAT）

**NAT表在路由器上保持的时间大概30~50s左右，至少我本地测试的时候，如果创建多个UDP client与外部通信，且外部通信能成功区分各个UDP client响应回来的话，其实差不多要保持40s左右的心跳包刷新NAT表才行。**

#### 4.11.4 NAT穿透方法

​	目前常用的针对UDP的NAT 穿透（NAT Traversal）方法主要有：**STUN**、**TURN**、**ICE**、**uPnP**等。其中ICE方式由于其结合了STUN和TURN的特点，所以使用最为广泛。针对TCP的NAT[穿透技术](https://baike.baidu.com/item/穿透技术)目前仍为难点。实用的技术仍然不多。

> [串行端口--百度百科]([https://baike.baidu.com/item/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3](https://baike.baidu.com/item/串行端口))
>
> [stun(网络协议)--百度百科](https://baike.baidu.com/item/stun/3131387?fr=aladdin)
>
> **STUN**（**Session Traversal Utilities for NAT**，NAT会话穿越应用程序）是一种[网络协议](https://baike.baidu.com/item/网络协议)，它允许位于[NAT](https://baike.baidu.com/item/NAT)（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建**UDP通信**。该协议由RFC 3489定义。目前RFC 3489协议已被RFC 5389协议所取代，新的协议中，将STUN定义为一个协助穿越NAT的工具，并不独立提供穿越的解决方案。它还有升级版本RFC 7350，目前正在完善中。
>
> [turn(网络协议)--百度百科](https://baike.baidu.com/item/turn/7011011#viewPageContent)
>
> **TURN协议允许NAT或者[防火墙](https://baike.baidu.com/item/防火墙)后面的对象可以通过TCP或者UDP接收到数据。这在使用了对称式的NAT（或者防火墙）的网络中尤其具有实用价值**。
>
> <u>TURN方式解决NAT问题的思路与STUN相似</u>，是基于私网接入用户通过某种机制预先得到其私有地址对应在公网的地址（STUN方式得到的地址为出口NAT上的地址，**TURN方式得到地址为TURNServer上的地址**），然后在报文负载中所描述的地址信息直接填写该公网地址的方式，实际应用原理也是一样的。
>
> TURN的全称为Traversal Using Relay NAT，即通过Relay方式穿越NAT，TURN应用模型通过分配TURNServer的地址和端口作为[客户端](https://baike.baidu.com/item/客户端)对外的接受地址和端口，即**私网用户发出的报文都要经过TURNServer进行Relay转发**，**这种方式应用模型除了具有STUN方式的优点外，还解决了STUN应用无法穿透对称NAT（SymmetricNAT）以及类似的Firewall设备的缺陷**，即**无论企业网/驻地网出口为哪种类型的NAT/FW，都可以实现NAT的穿透**，同时TURN支持基于TCP的应用，如H323协议。此外TURNServer控制分配地址和端口，能分配[RTP/RTCP](https://baike.baidu.com/item/RTP%2FRTCP)地址对（RTCP端口号为RTP端口号加1）作为本端客户的接受地址，避免了STUN应用模型下出口NAT对RTP/RTCP地址端口号的任意分配，使得客户端无法收到对端发过来的RTCP报文（对端发RTCP报文时，目的端口号缺省按RTP端口号加1发送）
>
> **TURN的局限性在于所有报文都必须经过TURNServer转发，增大了包的延迟和丢包的可能性**。
>
> [ICE(互动式连接建立)--百度百科](https://baike.baidu.com/item/ICE/6473508#viewPageContent)
>
> 互动式连接建立（Interactive Connectivity Establishment ——**ICE**）由IETF的MMUSIC工作组开发出来的，**它所提供的是一种框架，使各种NAT穿透技术可以实现统一**。该技术可以让基于SIP的VoIP客户端成功地穿透远程用户与网络之间可能存在的各类**防火墙**。
>
> [UPNP--百度百科](https://baike.baidu.com/item/UPNP/525567?fr=aladdin)
>
> **通用即插即用**（英语：Universal Plug and Play，简称**UPnP**）是由“通用即插即用论坛”（UPnP™ Forum）推广的一套[网络协议](https://baike.baidu.com/item/网络协议/328636)。该协议的目标是使家庭网络（数据共享、通信和娱乐）和公司网络中的各种设备能够相互无缝连接，并简化相关网络的实现。UPnP通过定义和发布基于开放、因特网通讯网协议标准的UPnP设备控制协议来实现这一目标。
>
> UPnP这个概念是从[即插即用](https://baike.baidu.com/item/即插即用)（Plug-and-play）派生而来的，即插即用是一种热拔插技术。
>
> **UPnP体系允许PC间的点对点连接、网际互连和无线设备。它是一种基于[TCP/IP](https://baike.baidu.com/item/TCP%2FIP)、[UDP](https://baike.baidu.com/item/UDP)和[HTTP](https://baike.baidu.com/item/HTTP)的分布式、开放体系**。
>
> [在路由器中开启UPNP有什么具体作用，有什么坏处](https://zhidao.baidu.com/question/563482186.html) <= 建议阅读
>
> [P2P技术详解(三)：P2P技术之STUN、TURN、ICE详解](https://www.cnblogs.com/mlgjb/p/8243690.html)

> [SIP(会话发起协议)--百度百科](https://baike.baidu.com/item/SIP/33921?fr=aladdin)
>
> SIP（Session Initiation Protocol，会话初始协议）是由IETF（Internet Engineering Task Force，因特网工程任务组）制定的多媒体通信协议。
>
> 它是**一个基于文本的应用层控制协议**，用于创建、修改和释放一个或多个参与者的会话。SIP 是一种源于互联网的IP 语音会话控制协议，具有灵活、易于实现、便于扩展等特点。
>
> [VoIP--百度百科](https://baike.baidu.com/item/voip/110300?fr=aladdin)
>
> **基于IP的语音传输**（英语：Voice over Internet Protocol，缩写为**VoIP**）是一种语音通话技术，经由[网际协议](https://baike.baidu.com/item/网际协议)（IP）来达成语音通话与[多媒体](https://baike.baidu.com/item/多媒体)会议，也就是经由[互联网](https://baike.baidu.com/item/互联网)来进行通信。其他非正式的名称有IP电话（IP telephony）、互联网电话（Internet telephony）、宽带电话（broadband telephony）以及宽带电话服务（broadband phone service）。
>
> VoIP可用于包括VoIP电话、[智能手机](https://baike.baidu.com/item/智能手机)、个人计算机在内的诸多互联网接入设备，通过[蜂窝网络](https://baike.baidu.com/item/蜂窝网络)、[Wi-Fi](https://baike.baidu.com/item/Wi-Fi)进行通话及发送[短信](https://baike.baidu.com/item/短信)。
>
> VoIP主要有以下三种方式：
>
> - 网络电话：完全基于Internet传输实现的语音通话方式，一般是PC和PC之间进行通话。
> - 与公众电话网互联的IP电话：通过宽带或专用的IP网络，实现语音传输。终端可以是PC或者专用的IP话机。
> - 传统电信运营商的VoIP业务：通过电信运营商的骨干IP网络传输语音。提供的业务仍然是传统的电话业务，使用传统的话机终端。通过使用IP电话卡，或者在拨打的电话号码之前加上IP拨号前缀，这就使用了电信运营商提供的VoIP业务。
>
> VoIP相对比较便宜。这是因为VoIP电话不过是互联网上的一种应用。从本质上说，VoIP电话与[电子邮件](https://baike.baidu.com/item/电子邮件)，即时讯息或者网页没有什么不同，它们均能在经过了互联网连接的机器间进行传输。这些机器可以是电脑，或者无线设备，比如手机或者掌上设备等等。
>
> 为什么VoIP服务有些要收钱，有些却免费？ **VoIP服务不仅能够沟通VoIP用户，而且也可以和[电话用户](https://baike.baidu.com/item/电话用户)通话**，比如使用传统固话网络以及无线手机网络的用户。对这部分通话，VoIP服务商必须要给固话网络运营商以及无线通讯运营商支付通话费用。这部分的收费就会转到VoIP用户头上。网上的VoIP用户之间的通话可以是免费的。
>
> 使用VoIP，需要具备哪些条件？ 首先需要连接互联网，这可以是最基本的[拨号上网](https://baike.baidu.com/item/拨号上网)，也可以是更理想的宽带服务。网络连接速度越快，VoIP的通话质量就越好。例如，高速[宽带连接](https://baike.baidu.com/item/宽带连接)能够令你一面打电话，一面上网冲浪。其次需要VoIP软件。用户可以选择一种VoIP软件安装至台式电脑或笔记本电脑上。这样电脑就可以进行网上通话了。如果用户想要将自己的家庭电话转化为VoIP拨号系统，则需要适配器的帮助。VoIP软件可以单独预装在一种名为“模拟电话适配器”（analog telephone adapter）的硬件设备中，模拟电话适配器主要安装于家庭电话与宽带[调制解调器](https://baike.baidu.com/item/调制解调器)之间。
>
> 随着移动互联网的发展，VoIP技术也有了新的发展趋势：
>
> - 出现了VoIP技术和无线网络的融合。无线网络主要包括3G（The 3rd Generation Mobile Communications，第三代移动通信）、LTE（Long Term Evolution，长期演进）和WLAN（Wireless Local Area Network，无线局域网）。其中，基于WLAN的VoIP发展尤为迅猛。在无线VoIP中，信号的最后接入是采用WLAN，其他部分仍然采用有线网络进行传输。
> - 出现了VoIP和P2P（Peer-to-Peer，端到端）的融合。**P2P技术综合利用分散的网络资源，使得语音呼叫的接通率、语音质量甚至超过了传统的电话网络。**
>
> VoOP特点
>
> 1、无需电脑。不会像电脑一样，因为中病毒，或者操作系统故障，导致不能正确使用。
>
> 2、适合保障长时间在线。内网互打，**关键是要保持在线**。*（NAPT要保持NAT映射关系，需要隔一段时间刷新一次nat表，比如通过发送心跳包维持）*
>
> 3、**加密通讯**。*（V0IP的安全是通过网络电话加密，即通过语音数据加密方式实现的，现用的**加密方式分别为TLS和IPSec**）*
>
> 4、**音质清晰**。语音处理采用国际先进的语音处理芯片，有效解决回音消除，数据包丢失、网络抖动产生的问题。**比软件电话的音质普遍要高**。*(网络正常情况下,通话音质与传统电话无明显差距)*
>
> 5、 成本价格低廉，可以随意改号，显示号码。*(必须经运营商允许,用户自己不可以随意改号)*
>
> 6、可监控，可录音，支持三方通、密语、来电转接等功能。
>
> [开启UPnP有什么用?](https://zhidao.baidu.com/question/105793159.html)
>
> UPnP为NAT（[网络地址转换](https://baike.baidu.com/item/网络地址转换)）穿透带来了一个解决方案：[互联网网关设备协议](https://baike.baidu.com/item/互联网网关设备协议)（IGD）。**[NAT穿透](https://baike.baidu.com/item/NAT穿透)允许UPnP数据包在没有用户交互的情况下，无障碍的通过[路由器](https://baike.baidu.com/item/路由器)或者[防火墙](https://baike.baidu.com/item/防火墙)（假如那个[路由器](https://baike.baidu.com/item/路由器)或者[防火墙](https://baike.baidu.com/item/防火墙)支持NAT）。**
>
> 开启UPnP对缓冲区（Buffer）的使用没有进行检查和限制。外部的攻击者，可以通过这里取得整个系统的控制特权！由于UPnP功能必须使用计算机的端口来进行工作，取得控制权的攻击者，还有可能利用这些端口，达到攻击者的目的。
>
> [upnp和NAT有什么区别啊？](https://zhidao.baidu.com/question/1174204344725084379.html)
>
> **upnp是nat的自动版，不需要手动设置就能映射上网，但需要软件支持upnp功能。**
>
> **nat是端口映射，根据自己的具体情况，需要手动设置的。**

### 4.11.5 NAT优质网文推荐

#### 1. NAT转换是怎么工作的？

> [NAT转换是怎么工作的？](https://www.zhihu.com/question/31332694) => 以下内容摘自于此

NAT转换设备一般支持三种NAT转换模式：

1. 静态NAT  
2. 动态NAT

3. PNAT(端口网络地址转换)

前两种都是内网地址与外网地址一一映射，题主指的是第三种PNAT转换，转换过程先实验证明,然后做结论
实验拓扑：

![img](https://pic4.zhimg.com/50/d4a3893af951e7a16a5feb908cb03e86_hd.jpg?source=1940ef5c)R1，R2分别代表题主所指的用户设备C1,用户设备C2(两台同网段的内网设备)，网关是R3同时R3也是NAT设备，R4是服务器S。  (R5是交换机忘改名)

R3的PNAT配置如下：
  1.先设置R3的f1/0是对内接口，f0/0是对外接口 

```shell
R3(config)#interface f0/0
R3(config-if)#ip nat inside
R3(config-if)#exit
R3(config)#interface f1/0
R3(config-if)#ip nat outside
```

  2.配置pnat转换池并在f1/0做接口复用

```shell
R3(config)#ip access-list extended PAT-LIST
R3(config-ext-nacl)#permit ip 10.0.0.0   0.0.0.255 any
R3(config-ext-nacl)#exit
R3(config)#ip nat inside source list PAT-LIST interface f1/0 overload
```

配置完毕后，R1,R2分别 ping 和 telnet  R4 

然后在R3用show ip nat translations查看转化过程

![img](https://pic3.zhimg.com/80/be7f2f5c01e7be31c95b4290c93d3cdc_1440w.jpg?source=1940ef5c)

字段解释：

+ Pro：通信协议

+ inside global: 内网设备转换后的公网地址(209.165.201.5)

+ inside local:内网设备ip地址(R1:10.1.1.100   R2:10.1.1.101)

+ outside global: 要访问的目的地(R4)

说明：由于R1,R2分别 ping 和 telnet  R4，所以表中分别出现两个icmp项目和tcp项

​	以第一行为例(其他类似)：

​	第一行是R1(10.1.1.100 ) ping R4(209.165.201.131)时产生的条目，inside global是209.165.201.5，inside local是10.1.1.100，outside global是209.165.201.131. 关键部分在于这些ip后面都带一个5，代表R3（PANT设备）的5号端口记录着这一次ping的内网设备和外网设备的映射，来回的数据包都会加上5这个端口标识(此处为推断)来找到R1， 而R2(10.1.1.101 ) ping R4(209.165.201.131)的标记端口是2，来回的数据包都会加上2这个端口标识来找到R2. **所以PNAT是通过在复用接口上的不同端口来“知道这个响应是给用户C1而不是C2的”。**

#### 2. NAPT和NAT的工作原理及其区别

> [NAPT和NAT的工作原理及其区别](https://www.cnblogs.com/xh73/archive/2013/02/01/2889506.html) => 以下内容整理至该文章

1. NAT概念

   ​	[网络地址转换](http://baike.baidu.com/view/875777.htm)(NAT,Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。

     NAT（Network Address Translation，网络地址转换）是将IP 数据包头中的IP 地址转换为另一个IP 地址的过程。**在实际应用中，NAT 主要用于实现私有网络访问公共网络的功能**。<u>这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用IP [地址空间](http://baike.baidu.com/view/1507129.htm)的枯竭</u>。

2. NAPT概念

   ​	网络地址端口转换NAPT（Network Address Port Translation）是人们比较熟悉的一种转换方式。NAPT普遍应用于[接入设备](http://baike.baidu.com/view/3401765.htm)中，它可以将中小型的网络隐藏在一个合法的IP地址后面。**NAPT与[动态地址](http://baike.baidu.com/view/1449967.htm)NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP[端口号](http://baike.baidu.com/view/642103.htm)**。

     NAPT是一种较流行的NAT的变体通过转换TCP或UDP协议[端口号](http://baike.baidu.com/view/642103.htm)以及地址来提供并发性。除了一对源和目的IP地址以外，这个表还包括一对源和目的协议[端口号](http://baike.baidu.com/view/642103.htm)，以及NAT盒使用的一个协议端口号。

     **NAPT的主要优势在于，能够使用一个全球有效IP地址获得通用性。主要缺点在于其通信仅限于TCP或UDP**。只要所有通信都采用TCP或UDP，NAPT就允许一台内部计算机访问多台外部计算机，并允许多台内部[主机](http://baike.baidu.com/view/23880.htm)访问同一台外部计算机，相互之间不会发生冲突。

3. NAT和NAPT的工作样例

   ​	NAT的基本工作原理是，当私有网主机和公共网主机通信的IP包经过NAT网关时，将IP包中的源IP或目的IP在私有IP和NAT的公共IP之间进行转换。NAT网关有2个网络端口，其中公共网络端口的IP地址是统一分配的公共IP，为202.204.65.2；私有网络端口的IP地址是保留地址，为192.168.1.1。私有网中的主机 192.168.1.2向公共网中的主机166.111.80.200发送了1个IP包（Des=166.111.80.200,Src=192.168.1.2）。当IP包经过NAT网关时，NAT会将IP包的源IP转换为NAT的公共 IP并转发到公共网，此时IP包（Des=166.111.80.200，Src=202.204.65.2）中已经不含任何私有网IP的信息。由于IP 包的源IP已经被转换成NAT的公共IP，响应的IP包（Des=202.204.65.2,Src=166.111.80.200）将被发送到NAT。 这时，NAT会将IP包的目的IP转换成私有网中主机的IP，然后将IP包（Des=192.168.1.2，Src=166.111.80.200）转 发到私有网。对于通信双方而言，这种地址的转换过程是完全透明的。

   ---

   ​	**由于NAT实现是私有IP和NAT的公共IP之间的转换，那么，私有网中同时与公共网进行通信的主机数量就受到NAT的公共IP地址数量的限制**。为了克服这种限制，NAT被进一步扩展到在进行IP地址转换的同时进行Port的转换，这就是网络地址端口转换NAPT（Network Address Port Translation）技术。

   ​	**NAPT与NAT的区别在于，NAPT不仅转换IP包中的IP地址，还对IP包中TCP和UDP的Port进行转换。这使得多台私有网主机利用1个NAT公共IP就可以同时和公共网进行通信。（NAPT多了对TCP和UDP的端口号的转换）**

   ​	*私有网主机192.168.1.2要访问公共网中的 Http服务器166.111.80.200。首先，要建立TCP连接，假设分配的TCP Port是1010，发送了1个IP包（Des=166.111.80.200:80,Src=192.168.1.2:1010）,当IP包经过NAT 网关时，NAT会将IP包的源IP转换为NAT的公共IP，同时将源Port转换为NAT动态分配的1个Port。然后，转发到公共网，此时IP包 （Des=166.111.80.200：80，Src=202.204.65.2:2010）已经不含任何私有网IP和Port的信息。由于IP包的源 IP和Port已经被转换成NAT的公共IP和Port，响应的IP包 （Des=202.204.65.2:,Src=2010166.111.80.200:80）将被发送到NAT。这时NAT会将IP包的目的IP转换成 私有网主机的IP，同时将目的Port转换为私有网主机的Port，然后将IP包 （Des=192.168.1.2:1010，Src=166.111.80.200:80）转发到私网。对于通信双方而言，这种IP地址和Port的转 换是完全透明的。*

### 4.11.6 NAT技术应用

#### 1. ngrok内网穿透

> [ngrok原理浅析](http://itindex.net/detail/53439-ngrok-%E5%8E%9F%E7%90%86)
>
> + Control Connection：类似FTP的控制连接<small>（FTP共建立两连接，另一个是数据连接）</small>，用于内网客户端和提供映射的公网服务端之间的控制类信息交流（HTTPS）
> + Public Connection：外部主机向内网客户端发起连接请求（实际通过预设的公网服务端中转，即外部主机并非直接和内网客户端进行P2P交流）
> + Proxy Connection：公网服务端接收到外部主机的Public Connection连接请求时，向内网服务器通过Control Connection发起代理请求。（这样公网服务端就能中转外部主机与内网客户端之间的数据传输）
>
> [Ngrok： 超简单的内网穿透，了解一下 ？](https://blog.csdn.net/sunnyzyq/article/details/102833096)
>
> [ngrok内网穿透](https://wkfg.github.io/)
>
> [内网穿透神器 Ngrok 的使用](https://learnku.com/articles/36003)
>
> [Mac 安装使用 Ngrok](https://learnku.com/articles/36129)

#### 2. SSH解决NAT问题

> [用啥Ngrok，用SSH解决大局域网反向端口转发问题](http://itindex.net/detail/57307-ngrok-ssh-%E5%B1%80%E5%9F%9F%E7%BD%91)

#### 3. frp内网穿透

> [自建frps+frpc实现内网穿透](https://www.tomzhu.site/2020/06/411/)	<=	以下内容出至该文章。文章原文还包括搭建教程。

**frp的原理**

![img](https://www.tomzhu.site/wp-content/uploads/2020/06/image-6.png)

​	在常规的情况下，服务器需要拥有公网IP。IP就如同门牌号，有了门牌号，别人才能找到你。客户端即便是处在NAT环境下，也能通过公网IP访问到服务器提供的服务。NAT环境内的客户端发起的连接建立之后，NAT网关便会对外打开一个端口来接收服务器返回的数据，并把接收到的数据转发给客户端。但是这个通讯，必须由NAT环境内的机器来发起。而提供服务的一方总是被动地等待传入连接的，因此NAT环境下的机器是无法对NAT环境外的机器提供服务的（这里暂时不考虑端口映射、DMZ、UDP穿透等因素）。

![img](https://www.tomzhu.site/wp-content/uploads/2020/06/image-7.png)

​	如果用了frp，那么处在NAT环境下的服务器也能对NAT环境外的机器提供服务了。这需要一台有公网IP的机器来做frp服务器。没有公网IP的应用服务器首先要告诉frp服务器：“我有一个服务运行在A端口，我想借你的B端口来对外开放这个服务。”frp服务器答应了。于是应用服务器便和frp服务器建立起了一个长连接，这使得frp服务器可以随时发送数据给应用服务器（NAT环境下，连接的建立只能是单向的；但连接建立后的通讯仍然可以是双向的）。frp服务器还同时开始监听B端口上的传入连接。当有客户端想要访问应用服务器A端口上的服务时，它需要访问frp服务器的B端口。frp服务器接到这个请求后，就通过刚才建立的那个长连接把请求转发给应用服务器，应用服务器处理完这个请求，把响应发送给了frp服务器，frp服务器再次转发给客户端。整个流程就完成了。这就是frp的基本原理。

### 4.12 虚拟机VMware的网络连接

> [vmware的网络设置里面vmnet0到vmnet8都是什么啊？](https://zhidao.baidu.com/question/78291739.html)
>
> [VMware虚拟机三种联网方式（图文详细解说）](https://blog.csdn.net/qq_36838191/article/details/88634351)
>
> [VMware的网络模式](https://blog.csdn.net/weixin_42207496/article/details/103947534)
>
> **桥接模式bridge，对应的是PC机的物理网卡；**
> **宿主模式host-only，对应的是虚拟的net1网卡；**
> **NAT模式，对应的是虚拟的net8网卡；**
>
> [vmware设置桥接时复制物理网络连接状态是什么意思？](https://blog.csdn.net/daxiang12092205/article/details/52115861)
>
> 意思就是说，VM上使用的是虚拟的网卡，也就是说VM虚拟机上的网卡不是真实存在的，而桥接还有其他的网路链接方式，都是必须存在网卡的。复制物理网卡连接状态，就是说把你指定的、本机的、真是网卡的状态信息复制给虚拟机的虚拟网卡，比如说你的本机真是网卡链接到了家用路由器的LAN口上，获得到了DHCP分配的地址，那么你的虚拟网卡就好像和真是网卡接入了同一台交换机中，也可以获得DHCP分配到的地址。
>
> [vmware虚拟机三种网络模式的区别](https://blog.csdn.net/chichi123137/article/details/82670257)
>
> 虚拟系统处于虚拟的NAT网络中，虚拟机虚拟出了一个NAT服务器，使其虚拟网卡能够连接到Internet。在这种连接模式下Guest使用VMnet8虚拟交换机，在主机的网络共享中心中可以看到VMware NetworkAdapter VMnet8虚拟网卡，这块虚拟网卡连接在**VMnet8虚拟交换机上与虚拟系统的虚拟网卡进行通信，即它的功能是让主机能够和VMnet8网段通信，但不是为VMnet8网段提供路由功能，去掉这个虚拟网卡Guest仍然可以上网，但是主机无法再访问VMnet8网段，即主机和虚拟机无法再进行通信。**
>
> 在NAT模式下，虚拟机虽然处于内部局域网，但是它是可以访问外网的，因为这时候宿主计算机相当于一台开启了DHCP功能的路由器，宿主机真实的物理网卡（即NAT device）连接着Network，此时虚拟机相当于局域网中的一台真实主机，所以虚拟机可以通过宿主计算机的DHCP来动态获得网络参数，相当于一台计算机通过路由器连接了外部互联网。宿主机可以访问虚拟机，但是局域网内其他主机是无法访问虚拟机的，因为NAT的网络在vmware提供的一个虚拟网络里。
>
> **NAT模式与主机模式十分相似，主要不同之处即在于主机模式中宿主机不再具备NAT功能，即不再相当于虚拟机访问Internet的路由器。**
>
> [Vmware虚拟机三种网络模式详解](https://www.cnblogs.com/jpfss/p/8616517.html) <<<<-----  推荐文章

**一个VMnet相当于一个vlan（二层，交换机设置，冲突域），所以不同VMnet的虚拟机之间无法ping通，即时设置相同网段（三层，路由器设置，广播域）**。*（相同vmnet的虚拟机可以ping通彼此）*

1. bridge桥接桥式

   ![桥接模式](http://img.blog.csdn.net/20160408183817187)

   ​	亲测，虚拟机设置桥接模式后，VM虚拟机菜单栏的"编辑"-->"虚拟网络编辑器"桥接模式，修改"桥接到"选项，改成我们实体机连接的网卡，就可以上网了（使用的网关、DNS、DHCP和我们自己实体主机相同，同一网段不同主机号）。

   > [vmware 桥接模式下与虚拟机互ping不通问题-终极解决办法](https://blog.csdn.net/helloexp/article/details/84787019)

2. host-only仅主机模式

   ![Host-Only模式](http://img.blog.csdn.net/20160408185234834)

   ​	要想连接因特网，必须配置当前实体主机的网络与VM1虚拟网卡共享，然后重新配置虚拟机的网段到windows要求的LAN适配器网段`192.168.137.0`，对应的DHCP服务也要修改。*（如果原本DHCP配置的IP没过期，会发现虚拟机IP还是原本的，所以不在`192.168.137.0`网段，无法上网。可以手动修改一下虚拟机里的网络适配器，使用静态配置（再切回来动态，就发现DHCP给重新分配了）。）*

   > [虚拟机如何通过“仅主机”模式上网0](https://blog.csdn.net/ITlanyue/article/details/105178015)

3. NAT

   ![NAT模式](http://img.blog.csdn.net/20160408184441387)

   ​	能上因特网。真实主机能通过虚拟出来的VM8网卡和NAT的主机联系（不同网段）

>[docker的四种网络模式](https://www.jianshu.com/p/270125484301)
>
>**host模式**：和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。
>
>**container模式**：指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。
>
>**none模式**：在这种模式下，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。
>
>**bridge**模式：bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。
>
>[SNAT(源地址转换)--百度百科]([https://baike.baidu.com/item/%E6%BA%90%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2](https://baike.baidu.com/item/源地址转换))
>
>源地址转换即内网地址向外访问时，发起访问的内网ip地址转换为指定的ip地址（可指定具体的服务以及相应的端口或端口范围），这可以使内网中使用保留ip地址的[主机](https://baike.baidu.com/item/主机)访问外部网络，**即内网的多部主机可以通过一个有效的公网ip地址访问外部网络。**
>
>A公司拥有多个[公网IP](https://baike.baidu.com/item/公网IP)（60.191.82.105-107），A公司希望内部用户（IP为192.168.1.50）使用某个特定的IP（60.191.82.107）访问互联网，则需在出口路由设备上需要配置源地址转换。
>
>[DNAT(目的地址转换)--百度百科](https://baike.baidu.com/item/DNAT/4975864?fr=aladdin)
>
>DNAT 的全称为Destination Network Address Translation目的地址转换，常用于防火墙中。
>
>[什么是NAT,常见分为那几种，DNAT与SNAT有什么不同，应用事例有那些？](https://zhidao.baidu.com/question/335463920.html)
>
>[防火墙基础知识之DNAT详解](http://www.eryajf.net/1095.html)

### 4.13 IGMP组管理协议

> [Internet组管理协议--百度百科]([https://baike.baidu.com/item/Internet%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/2991685?fromtitle=IGMP&fromid=610474&fr=aladdin](https://baike.baidu.com/item/Internet组管理协议/2991685?fromtitle=IGMP&fromid=610474&fr=aladdin))
>
> Internet 组管理协议称为IGMP协议（Internet Group Management Protocol），是因特网协议家族中的一个**组播协议**。该协议运行在**主机和组播路由器**之间。IGMP协议共有三个版本，即IGMPv1、v2 和v3。
>
> [现在直播、录播等平台是通过“组播”的方式下发流量的吗？](https://www.zhihu.com/question/65869123/answer/235763384)
>
> **现实中，组播一般只在专用网络中使用。要么企业之间通过VPN隧道技术在自己规划的网络内组播，要么大型ISP搭建组播网络自己用。** *我们普通老百姓没法主动在组播网络里爱传啥传啥。*
>
> **CDN内容分发网络通过单播形式+缓存，实现类似组播的效果，节省上游（服务器）网络带宽的消耗**。

#### 4.13.1 IGMP概述

​	IGMP是[TCP/IP](https://baike.baidu.com/item/TCP%2FIP)中重要标准之一，**所有IP组播系统（包括主机和路由器）都需要支持IGMP协议**。*（**组播=多播**）*

​	组播协议包括**组成员管理协议**和**组播路由协议**。组成员管理协议用于管理组播组成员的加入和离开，组播路由协议负责在路由器之间交互信息来建立组播树。**IGMP属于前者，是组播路由器用来维护组播组成员信息的协议，运行于主机和和组播路由器之间**。IGMP 信息[封装](https://baike.baidu.com/item/封装)在IP[报文](https://baike.baidu.com/item/报文)中，其IP的协议号为2。

​	若一个主机想要接收发送到一个特定组的组播数据包，它需要监听发往那个特定组的所有数据包。**为解决Internet上组播数据包的路径选择，主机需通过通知其子网上的组播路由器来加入或离开一个组，组播中采用IGMP来完成这一任务**。这样，组播路由器就可以知道网络上组播组的成员，并由此决定是否向它们的网络转发组播数据包。**当一个组播路由器收到一个组播分组时，它检查数据包的组播目的地址，仅当接口上有那个组的成员时才向其转发**。

​	IGMP提供了在转发组播数据包到目的地的最后阶段所需的信息，实现如下双向的功能：

1. **主机通过IGMP通知路由器希望接收或离开某个特定组播组的信息。**
2. **路由器通过IGMP周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的收集与维护**。

IGMP共有三个版本，即IGMP v1、v2 和 v3。

> [计算机网络的三种通讯模式（单播，广播，组播）小结](https://blog.csdn.net/u010164190/article/details/79444057)
>
> **广播禁止允许在Internet宽带网上传输。**
>
> **组播和单播协议一样允许在Internet宽带网上传输。**

#### 4.13.2 IGMP v1

> [组播--百度百科]([https://baike.baidu.com/item/%E7%BB%84%E6%92%AD](https://baike.baidu.com/item/组播))
>
> 组播技术的初衷是在IP网络中，以"尽力而为"的形式发送信息到某个目标组，这个目标组称为组播组，这样在有源主机向多点目标主机发送信息需求时，源主机只发送一份数据，数据的目的地址是组播组地址，这样，凡是属于该组的成员，都可以接收到一份原主机发送的数据的拷贝，此**组播方式下，只有真正信息需要的成员会收到信息，其他主机不会收到**。
>
> 因此**组播方式解决了单播情况下数据的重复拷贝及带宽的重复占用，也解决了广播方式下带宽资源的浪费**。
>
> <small>[组播](https://baike.baidu.com/item/组播)安全性是一个重要的问题。标准的、实用的[通信安全](https://baike.baidu.com/item/通信安全)解决方案一般采用的是[对称加密](https://baike.baidu.com/item/对称加密)。但是将其应用于IP[组播](https://baike.baidu.com/item/组播)流量可能会使任何一个接收方都拥有冒充发送方的能力。这显然是令人无法接受的。IETF的MSEC[工作组](https://baike.baidu.com/item/工作组)正在开发用以解决这一问题的[安全协议](https://baike.baidu.com/item/安全协议)，这些协议大多都是在[IPsec](https://baike.baidu.com/item/IPsec)[协议集](https://baike.baidu.com/item/协议集)的体系[框架](https://baike.baidu.com/item/框架)内开发的。</small>
>
> <small>IPsec不能被用于[组播](https://baike.baidu.com/item/组播)方案，这是因为IPsec安全关联是被绑定到两个而非多个[主机](https://baike.baidu.com/item/主机)的。IETF提出了一个新的协议——TESLA，就[组播](https://baike.baidu.com/item/组播)安全性而言，这个协议是灵活且令人信服的。</small>
>
> [组播](https://baike.baidu.com/item/组播)的规范是在1989年出版的，但是它的使用受到了限制。**Internet上的[路由器](https://baike.baidu.com/item/路由器)并不是都具有[组播](https://baike.baidu.com/item/组播)的能力**。在这样一种情况下，研究者们为了在现有情况下开发和测试[组播](https://baike.baidu.com/item/组播)协议的应用，建立了[组播](https://baike.baidu.com/item/组播)骨干网（Multicast Backbone，Mbone）。Mbone支持[组播](https://baike.baidu.com/item/组播)分组的[路由选择](https://baike.baidu.com/item/路由选择)而不打扰其它的[因特网](https://baike.baidu.com/item/因特网)[业务流](https://baike.baidu.com/item/业务流)。

​	**IGMPv1 定义了主机只可以加入组播组，但没有定义离开成员组的信息，路由器基于成员组的超时机制发现离线的组成员。** 

​	IGMPv1 主要基于查询和响应机制来完成对[组播](https://baike.baidu.com/item/组播)组成员的管理。当一个[网段](https://baike.baidu.com/item/网段)内有多台[组播](https://baike.baidu.com/item/组播)[路由器](https://baike.baidu.com/item/路由器)时，由于它们都能从[主机](https://baike.baidu.com/item/主机)那里收到IGMP 成员关系报告[报文](https://baike.baidu.com/item/报文)（Membership Report Message），因此只需要其中一台路由器发送IGMP查询[报文](https://baike.baidu.com/item/报文)（Query Message）就足够了。这就需要有一个查询器（Querier）的选举机制来确定由哪台[路由器](https://baike.baidu.com/item/路由器)作为IGMP 查询器。对于IGMPv1 来说，由[组播](https://baike.baidu.com/item/组播)[路由协议](https://baike.baidu.com/item/路由协议)（如PIM）选举出唯一的[组播](https://baike.baidu.com/item/组播)信息转发者DR（Designated Router，[指定路由器](https://baike.baidu.com/item/指定路由器)）作为IGMP 查询器。

​	IGMPv1 没有专门定义离开[组播](https://baike.baidu.com/item/组播)组的报文。当运行IGMPv1 的[主机](https://baike.baidu.com/item/主机)离开某组播组时，将不会向其要离开的组播组发送报告[报文](https://baike.baidu.com/item/报文)。当[网段](https://baike.baidu.com/item/网段)中不再存在该[组播](https://baike.baidu.com/item/组播)组的成员后，IGMP[路由器](https://baike.baidu.com/item/路由器)将收不到任何发往该组播组的报告[报文](https://baike.baidu.com/item/报文)，于是IGMP 路由器在一段时间之后便删除该组播组所对应的组播转发项。

> [指定路由器--百度百科]([https://baike.baidu.com/item/%E6%8C%87%E5%AE%9A%E8%B7%AF%E7%94%B1%E5%99%A8](https://baike.baidu.com/item/指定路由器))
>
> 指定[路由器](https://baike.baidu.com/item/路由器/108294)（Designated Router）是一个运行开放最短路径优先(OSPF)的路由器，其为一个多路接入[网络](https://baike.baidu.com/item/网络)产生LSAs，在运行OSPF时有其它特殊的功能。每个多路接入 OSPF[网络](https://baike.baidu.com/item/网络)最少有两个附加[路由器](https://baike.baidu.com/item/路由器)，有一个路由器是被OSPF Hello协议推选的。这个指定[路由器](https://baike.baidu.com/item/路由器)能够使多接入[网络](https://baike.baidu.com/item/网络)需要的邻接的数量减少，进而减少[路由协议](https://baike.baidu.com/item/路由协议)通信的数量和拓扑数据库的大小。

#### 4.13.3 IGMP v2

​	**IGMPv2 是在版本1上基础上增加了主机离开成员组的信息**，允许迅速向路由协议报告组成员离开情况，这对高带宽组播组或易变型组播组成员而言是非常重要的。另外，若一个子网内有多个组播路由器，那么多个路由器同时发送IGMP 查询报文不仅浪费资源,还会引起  网络的堵塞。为解决这个问题，IGMPv2。不同使用路由选举机制, 能在一个子网内查询多个路由器。

igmp版本2对版本1所做的改进主要有：

1. **共享网段上[组播](https://baike.baidu.com/item/组播)[路由器](https://baike.baidu.com/item/路由器)的选举机制**

   ​	共享[网段](https://baike.baidu.com/item/网段)表示一个网段上有多个[组播](https://baike.baidu.com/item/组播)[路由器](https://baike.baidu.com/item/路由器)的情况。在这种情况下，由于此[网段](https://baike.baidu.com/item/网段)上运行igmp的[路由器](https://baike.baidu.com/item/路由器)都能从[主机](https://baike.baidu.com/item/主机)那里收到成员资格报告消息，因此，只需要一个[路由器](https://baike.baidu.com/item/路由器)发送成员资格查询消息，这就需要一个[路由器](https://baike.baidu.com/item/路由器)选举机制来确定一个路由器作为查询器。其选举过程如下：

   ​	(1) 所有IGMPv2[路由器](https://baike.baidu.com/item/路由器)在初始时都认为自己是查询器，并向本地网段内的所有[主机](https://baike.baidu.com/item/主机)和路由器发送IGMP 普遍组查询（General Query）[报文](https://baike.baidu.com/item/报文)（目的地址为:224.0.0.1）；

   ​	(2) 本地网段中的其它IGMPv2[路由器](https://baike.baidu.com/item/路由器)在收到该[报文](https://baike.baidu.com/item/报文)后，将报文的源IP 地址与自己的接口地址作比较。通过比较，**IP 地址最小的[路由器](https://baike.baidu.com/item/路由器)将成为查询器，其它路由器成为非查询器（Non-Querier）**；

   ​	(3) 所有非查询器上都会启动一个定时器（即其它查询器存在时间定时器OtherQuerier Present Timer）。在该定时器超时前，如果收到了来自查询器的IGMP查询[报文](https://baike.baidu.com/item/报文)，则重置该定时器；否则，就认为原查询器失效，并发起新的查询器选举过程。

​	**在igmp版本1中，查询器的选择由[组播](https://baike.baidu.com/item/组播)[路由协议](https://baike.baidu.com/item/路由协议)决定；igmp版本2对此做了改进，规定[同一网段](https://baike.baidu.com/item/同一网段)上有多个组播[路由器](https://baike.baidu.com/item/路由器)时，具有最小ip地址的组播路由器被选举出来充当查询器。**

2. **igmp版本2增加了离开组机制**

   ​	在igmp版本1中，[主机](https://baike.baidu.com/item/主机)悄然离开[组播](https://baike.baidu.com/item/组播)组，不会给任何组播[路由器](https://baike.baidu.com/item/路由器)发出任何通知。造成[组播](https://baike.baidu.com/item/组播)路由器只能依靠组播组响应超时来确定组播成员的离开。而在版本2中，当一个[主机](https://baike.baidu.com/item/主机)决定离开时，如果它是对一条成员资格查询消息作出响应的主机，那么它就会发送一条离开组的消息。

   在IGMPv2 中，当一个主机离开某[组播](https://baike.baidu.com/item/组播)组时：

   ​	(1) 该[主机](https://baike.baidu.com/item/主机)向本地网段内的所有[组播](https://baike.baidu.com/item/组播)路由器（目的地址为224.0.0.2）发送离开组（Leave Group）[报文](https://baike.baidu.com/item/报文)；

   ​	(2) 当查询器收到该[报文](https://baike.baidu.com/item/报文)后，向该[主机](https://baike.baidu.com/item/主机)所声明要离开的那个[组播](https://baike.baidu.com/item/组播)组发送特定组查询（Group-Specific Query）报文（目的地址字段和组地址字段均填充为所要查询的组播组地址）；

   ​	(3) 如果该网段内还有该[组播](https://baike.baidu.com/item/组播)组的其它成员，则这些成员在收到特定组查询[报文](https://baike.baidu.com/item/报文)后，会在该报文中所设定的最大响应时间（Max Response Time）内发送成员关系报告报文；

​		(4) 如果在最大响应时间内收到了该[组播](https://baike.baidu.com/item/组播)组其它成员发送的成员关系报告[报文](https://baike.baidu.com/item/报文)，查询器就会继续维护该组播组的成员关系；否则，查询器将认为该[网段](https://baike.baidu.com/item/网段)内已无该组播组的成员，于是不再维护这个组播组的成员关系。

3. **igmp版本2增加了对特定组的查询**

   **在igmp版本1中，[组播](https://baike.baidu.com/item/组播)路由器的一次查询，是针对该[网段](https://baike.baidu.com/item/网段)下的所有组播组。这种查询称为普遍组查询。**

   在igmp版本2中，在普遍组查询之外增加了特定组的查询，这种查询[报文](https://baike.baidu.com/item/报文)的目的ip地址为该[组播](https://baike.baidu.com/item/组播)组的ip地址，报文中的组地址域部分也为该组播组的ip地址。这样就避免了属于其它[组播](https://baike.baidu.com/item/组播)组成员的主机发送响应[报文](https://baike.baidu.com/item/报文)。

4.igmp版本2增加了最大响应时间字段

​	igmp版本2增加最大响应时间字段，以动态地调整[主机](https://baike.baidu.com/item/主机)对组查询[报文](https://baike.baidu.com/item/报文)的响应时间。

#### 4.13.4 IGMP v3

IGMPv3 在兼容和继承IGMPv1 和IGMPv2 的基础上，进一步增强了[主机](https://baike.baidu.com/item/主机)的控制能力，并增强了查询和报告[报文](https://baike.baidu.com/item/报文)的功能。 

**1）[主机](https://baike.baidu.com/item/主机)控制能力的增强**

IGMPv3 增加了针对[组播](https://baike.baidu.com/item/组播)源的过滤模式（INCLUDE/EXCLUDE），使[主机](https://baike.baidu.com/item/主机)在加入某组播组G 的同时，能够明确要求接收或拒绝来自某特定组播源S 的组播信息。当[主机](https://baike.baidu.com/item/主机)加入[组播](https://baike.baidu.com/item/组播)组时：

若要求只接收来自指定[组播](https://baike.baidu.com/item/组播)源如S1、S2、……的组播信息，则其报告[报文](https://baike.baidu.com/item/报文)中可以标记为INCLUDE Sources（S1，S2，……）；

若拒绝接收来自指定[组播](https://baike.baidu.com/item/组播)源如S1、S2、……的组播信息，则其报告[报文](https://baike.baidu.com/item/报文)中可以标记为EXCLUDE Sources（S1，S2，……）。

**2）查询和报告[报文](https://baike.baidu.com/item/报文)功能的增强**

(1) 携带源地址的查询[报文](https://baike.baidu.com/item/报文)

IGMPv3 不仅支持IGMPv1 的普遍组查询和IGMPv2 的特定组查询，而且还增加了对特定源组查询的支持：

z 普遍组查询[报文](https://baike.baidu.com/item/报文)中，既不携带组地址，也不携带源地址；

z 特定组查询[报文](https://baike.baidu.com/item/报文)中，携带组地址，但不携带源地址；

z 特定源组查询[报文](https://baike.baidu.com/item/报文)中，既携带组地址，还携带一个或多个源地址。

(2) 包含多组记录的报告[报文](https://baike.baidu.com/item/报文)

IGMPv3 报告[报文](https://baike.baidu.com/item/报文)的目的地址为224.0.0.22，可以携带一个或多个组记录。在每个组记录中，包含有[组播](https://baike.baidu.com/item/组播)组地址和组播源地址列表。组记录可以分为多种类型，如下：

IS_IN：表示[组播](https://baike.baidu.com/item/组播)组与组播源列表之间的过滤模式为INCLUDE，即只接收从指定组播源列表发往该组播组的组播数据。

IS_EX：表示[组播](https://baike.baidu.com/item/组播)组与组播源列表之间的过滤模式为EXCLUDE，即只接收从指定组播源列表之外的组播源发往该组播组的组播数据。

z TO_IN：表示[组播](https://baike.baidu.com/item/组播)组与组播源列表之间的过滤模式由EXCLUDE 转变为INCLUDE。

TO_EX：表示[组播](https://baike.baidu.com/item/组播)组与组播源列表之间的过滤模式由INCLUDE 转变为EXCLUDE。

ALLOW：表示在现有状态的基础上，还希望从某些[组播](https://baike.baidu.com/item/组播)源接收组播数据。如果当前的对应关系为INCLUDE，则向现有[组播](https://baike.baidu.com/item/组播)源列表中添加这些组播源；如果当前的对应关系为EXCLUDE，则从现有[组播](https://baike.baidu.com/item/组播)源列表中删除这些组播源。

BLOCK：表示在现有状态的基础上，不再希望从某些[组播](https://baike.baidu.com/item/组播)源接收组播数据。如果当前的对应关系为INCLUDE，则从现有组播源列表中删除这些组播源；如果当前的对应关系为EXCLUDE，则向现有组播源列表中添加这些组播源。

实现步骤如下：

​	1、当主机某个进程加入一个组播组时，主机发送一个IGMP 报告。若一个主机多个进程同时加入同一组，则发送一个IGMP 报告。
　2、进程离开一个多播组时，主机不发送IGMP 报告，即便是组中最后一个进程离开多播组。当主机确定已不再有组成员后，在随后收到的IGMP 查询中就不应答报文。
　3、多播路由器定时发送IGMP 查询是否还有其他主机包含有属于多播组的进程。多播路由器必须向每个接口发送IGMP 查询。
　4、主机通过发送IGMP 报告来响应一个IGMP 查询，对每个至少还包含一个进程的组均要发回IGMP 报告。
　**使用上述查询和报告报文，多播路由器对每个接口保持一张映射表，表中记录了接口上包含的一个或多个主机多播组。当路由器收到要转发的多播数据报时，只需将该数据报转发到该接口上。**

## 5. 传输层

### 5.0 预备知识与回顾

#### 5.0.1 传输层与应用层关联 

​	*传输层为相互通信的应用进程（应用层）提供了逻辑通信。从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。*



应用层 http https ftp DNS SMTP(发邮件) PoP3(收邮件) RDP(远程桌面协议)

传输层 TCP UDP

网络层IP(RIP OSPF BGP) (路由选择相关的，统称IP协议) ICMP IGMP ARP



传输层两个协议的应用场景

+ TCP：分段 编号 流量控制 建立会话 `netstat -n`(查看建立的会话)
+ UDP 一个数据报就能完成数据通信 不建立会话 多播



传输层和应用层之间的关系

http = TCP+80

https = TCP+443

ftp=TCP+21

SMTP=TCP+25

POP3=TCP+110

RDP=TCP+3389(windows可以通过`mstsc`使用RDP服务远程桌面连接)

共享文件夹=TCP+445

SQL Server=TCP+1433

DNS = UDP+53 or TCP+53(少部分情况)

（**IP定位主机，端口Port定位服务**。eg：4个服务监听4个端口，主机根据收到的包的目的端口判别访问哪个服务。）

查看自己计算机侦听的端口：`netstat -ano`

> [mDNS--百度百科](https://baike.baidu.com/item/mdns/7544078?fr=aladdin)
>
> mdns 即多播dns（Multicast DNS），mDNS主要实现了在没有传统DNS服务器的情况下使局域网内的主机实现相互发现和通信，使用的端口为5353，遵从dns协议，使用现有的DNS信息结构、名语法和资源记录类型。并且没有指定新的操作代码或响应代码。在局域网中，设备和设备之前相互通信需要知道对方的ip地址的，大多数情况，设备的ip不是静态ip地址，而是通过dhcp协议动态分配的ip 地址，如何设备发现呢，就是要mdns大显身手，例如：现在物联网设备和app之间的通信，要么app通过广播，要么通过组播，发一些特定信息，感兴趣设备应答，实现局域网设备的发现，当然mdns 比这强大。
>
> **当mDNS客户端需要解析主机名时，它会发送一个IP多播查询消息，要求具有该名称的主机标识自己。然后该目标机器多播包含其IP地址的消息。然后，该子网中的所有计算机都可以使用该信息来更新其mDNS高速缓存。任何主机都可以通过发送[生存时间](https://baike.baidu.com/item/生存时间)（TTL）等于零的响应数据包来放弃其对名称的声明。**
>
> 默认情况下，mDNS仅限并且专门解析以.local顶级域（TLD）结尾的主机名。如果该域包括未实现mDNS但可以通过传统单播DNS服务器找到的主机，则会导致问题。解决此类冲突需要违反零配置目标的网络配置更改。

#### 5.0.2 运输层协议和网络层协议的主要区别

+ IP协议的作用范围：提供**主机**之间的逻辑通信

+ TCP和UDP协议的作用范围：提供**进程**之间的逻辑通信

运输层为应用进程之间提供**端到端**的逻辑通信（但网络层是为**主机**之间提供逻辑通信）。

运输层还要对收到的**报文**进行**差错检验**。*（网络层，当路由器收到了一个IP数据报，先对其首部进行校验，若发现存在错误，则抛弃该IP数据报，并向源主机发送ICMP(因特网控制报文协议)差错报告报文。每个分组（报文）都有首部校验和字段。）*

运输层提供面向**连接**和**无连接**的服务。

#### 5.0.3 TCP和UDP概述

TCP/IP的运输层有两个不同的协议：

1. 用户数据报协议UDP（User Datagram Protocol）
2. 传输控制协议TCP（Transmission Control Protocol）

两个对等运输实体在通信时传送的数据单位叫作"运输协议数据单元"TPDU（Transport Protocol Data Unit）。

+ TCP传送的协议数据单元**TCP报文段（segment）**
+ UDP传送的协议数据单元是**UDP报文**或**用户数据报**。

UDP传输数据前**不需要建立连接**。对方的运输层在收到UDP报文后，不需要输出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式。

TCP提供**面向连接**的服务。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销*（指建立连接3次握手和释放连接4次挥手）*。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。

> [网络服务接入点(NSAP)--百度百科]([https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5%E7%82%B9/5924946?fromtitle=nsap&fromid=2808002&fr=aladdin](https://baike.baidu.com/item/网络服务接入点/5924946?fromtitle=nsap&fromid=2808002&fr=aladdin))

#### 5.0.4 端口与服务的关系

> [计算机端口--百度百科]([https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AB%AF%E5%8F%A3/8986083](https://baike.baidu.com/item/计算机端口/8986083))

TCP的端口，端口用一个16位端口号进行标志，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。*（**IP标识主机，port标识服务**）*

三类端口：

+ 熟知端口，数值一般为0~1024
+ 登记端口号，数值为1024~49151
+ 客户端口号，数值为49152~65535

#### 5.0.5 防火墙简述

> [防火墙（网络术语）](百度百科)
>
> 包过滤技术作为防火墙技术中最核心的技术之一，自身具有比较明显的缺点：不具备身份验证机制和用户角色配置功能。因此，一些产品开发商就将AAA认证系统集成到防火墙中，确保防火墙具备支持基于用户角色的安全策略功能。多级过滤技术就是在防火墙中设置多层过滤规则。**在网络层，利用分组过滤技术拦截所有假冒的IP源地址和源路由分组；根据过滤规则，传输层拦截所有禁止出/入的协议和数据包**；在应用层，利用FTP、SMTP等网关对各种Internet的服务进行监测和控制。

通过防火墙设置，可以限定出/入端口+协议限制。

例如：开启windows防火墙后，我们可以ping外部，但是外部不能ping我们；如果防火墙对外只开放80端口，那其他人就访问不了我们的其他服务。

（windows防火墙不拦截出流量，只拦截入流量。）

​	**灰鸽子病毒利用windows防火墙不限制出流量**这点，在被攻击者误触灰鸽子安装程序后，灰鸽子程序自动在后台隐藏进程运行。灰鸽子程序按照之前攻击者设定的IP地址，主动向外部发出请求。而攻击者打开自己的灰鸽子控制面板，就能看到被攻击者向自己报告IP地址，我们就能直接在面板上对被攻击者的电脑进行操作（远程桌面控制、文件控制等）。

*一些奇特的防攻击技巧：服务器B设置只允许服务器A远程访问，然后我们远程访问A，再通过A远程访问B；这样黑客想要远程黑入服务器B，还需要先黑入服务器A。*

> [木马病毒--百度百科]([https://baike.baidu.com/item/%E6%9C%A8%E9%A9%AC%E7%97%85%E6%AF%92/333298?fromtitle=%E6%9C%A8%E9%A9%AC%E7%A8%8B%E5%BA%8F&fromid=3739961](https://baike.baidu.com/item/木马病毒/333298?fromtitle=木马程序&fromid=3739961))
>
> 木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。**木马病毒其实是计算机黑客用于远程控制计算机的程序，将控制程序寄生于被控制的计算机系统中，里应外合，对被感染木马病毒的计算机实施操作**。一般的木马病毒程序主要是寻找计算机后门，伺机窃取被控计算机中的密码和重要文件等。可以对被控计算机实施监控、资料修改等非法操作。木马病毒具有很强的隐蔽性，可以根据黑客意图突然发起攻击。
>
> [DLL木马--百度百科]([https://baike.baidu.com/item/DLL%E6%9C%A8%E9%A9%AC](https://baike.baidu.com/item/DLL木马))
>
> [灰鸽子病毒--百度百科]([https://baike.baidu.com/item/%E7%81%B0%E9%B8%BD%E5%AD%90%E7%97%85%E6%AF%92/430753?fr=aladdin](https://baike.baidu.com/item/灰鸽子病毒/430753?fr=aladdin))
>
> [IPsec--百度百科](https://baike.baidu.com/item/ipsec/2472311?fr=aladdin)

### 5.1 UDP

#### 5.1.0 UDP报文格式

> [UDP--百度百科](https://baike.baidu.com/item/UDP)
>
> 虽然UDP是一个不可靠的协议，但它是分发信息的一个理想协议。例如，在屏幕上报告股票市场、显示航空信息等等。UDP也用在[路由信息协议](https://baike.baidu.com/item/路由信息协议)RIP（Routing Information Protocol）中修改路由表。在这些应用场合下，如果有一个消息丢失，在几秒之后另一个新的消息就会替换它。**UDP广泛用在多媒体应用中**。

![img](https://bkimg.cdn.bcebos.com/pic/78310a55b319ebc4c57a3f358c26cffc1e17161f?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

```none
UDP首部(共8字节)
  [源端口2字节][目的端口2字节][长度2字节][检验和2字节]
```

长度是指包括报头和数据部分在内的总字节数。

**虽然UDP提供有错误检测，但检测到错误时，UDP不做错误校正，只是简单地把损坏的消息段扔掉，或者给应用程序提供警告信息。** *（一般就是单纯的丢掉。除非你开发的应用程序有作什么特殊的检测。）*

> [IP,UDP,TCP校验和有什么区别](https://zhidao.baidu.com/question/328086705.html)
>
> UDP计算校验和的方法和计算IP数据报首部校验和的方法相似。 但不同的是：IP数据报的校验和只检验IP数据报的首部，但UDP的校验和是将首部和数据部分一起都检验。 在发送端，首先是将全零放入检验和字段。再将伪首部以及UDP用户数据报看成是由许多16bit的字串接起来。 若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节(即：最后一个基数字节应是16位数的高字节而低字节填0)。 然后按二进制反码计算出这些16bit字的和(两个数进行二进制反码求和的运算的规则是：从低位到高位逐列进行计算。 0和0相加是0，0和1相加是1，1和1相加是0但要产生一个进位1，加到下一列。若最高位相加后产生进位，则最后得到的结果要加1)。 将此和的二进制反码写入校验和字段后，发送此UDP用户数据报。 在接收端，将收到的UDP用户数据报连同伪首部(以及可能的填充全零字节)一起，按二进制反码求这些16bit字的和。 当无差错时其结果应全为1。否则就表明有差错出现， 接收端就应将此UDP用户数据报丢弃(也可以上交给应用层，但附上出现了差错的警告)。
> TCP 的校验和计算方法同UDP一样，同样要加上一个伪头部，区别是伪头部的协议码是0x06，长度是整个TCP报文的长度（包含TCP头部）。
> ICMP的校验和
> ICMP校验和的计算方法一样，只不过只是对ICMP包整个进行校验和，没有伪头部，也不包括IP包头部。
>
> [实时传输协议RTP--百度百科]([https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/9365206?fromtitle=RTP&fromid=8974125&fr=aladdin](https://baike.baidu.com/item/实时传输协议/9365206?fromtitle=RTP&fromid=8974125&fr=aladdin))
>
> 实时传输协议（RTP）为数据提供了具有实时特征的端对端传送服务，如在[组播](https://baike.baidu.com/item/组播)或[单播](https://baike.baidu.com/item/单播)网络服务下的交互式视频音频或模拟数据。应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了[传输层](https://baike.baidu.com/item/传输层)协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。
>
> RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的[序列号](https://baike.baidu.com/item/序列号)允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。
>
> [理解UDP协议的首部校验和校验和](https://www.cnblogs.com/limanjihe/p/10177195.html)
>
> Checksum ，这是发送方根据发送内容计算出来校验和，**接受方需要根据收到的内容重新计算一遍校验和，然后再对比两者**。所以在接收方计算时应该忽略这里 Checksum项

#### 5.1.1 UDP主要特点

+ 无连接：发送数据之前不需要建立连接
+ 尽最大努力交付：不保证可靠交付，同时也不使用拥塞控制*（符合媒体通信的要求）*
+ 面向报文
+ 支持一对一、一对多、多对一的多对多的交互通信。（单播、广播、多播）
+ 首部开销小，仅8字节。

#### 5.1.2 UDP优秀文章推荐

##### 从UDP的”连接性”说起–告知你不为人知的UDP

> [从UDP的”连接性”说起–告知你不为人知的UDP](https://blog.csdn.net/chenlycly/article/details/51582257) <= 该文章篇幅较长，下面摘取内容进行整理

1. UDP发送用户数据报的方法

   + `ssize_t send(int socket, const void *buffer, size_t length, int flags);`
   + `ssize_t sendto(int socket, const void *message, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);`

   后者指定了对端的地址，需要在用户态、内核态切换时存储更多的数据。

   前者需要和`connect`方法配合，内核态内存提前存储对端信息。

2. UDP的"connect"

   进行UDP通信前，调用`int connect(int socket, const struct sockaddr *address, socklen_t address_len)`，内核需要初始化一些临时的数据结构来存储对端的地址信息`Endpoint_S`。**内核不再需要分配/删除这些数据结构，只需要查找即可，从而减少了数据的拷贝。**

   *"connect"一般用在客户端（服务端UDP服务端口不变动的情况下），而服务端需要对大量UDP客户端服务，所以不应该调用"connect"，高流量处理下可能内存溢出。*

   <small>（从某种意义上，这种"connect"记住对端信息的方式，类似建立连接。但是UDP不过是简单地记录对端信息，不像真实建立连接的TCP能够实时了解对端情况来进行流量控制等细致操作。）</small>

3. **UDP的`sendto`释放本地存储的对端信息`Endpoint_S**`

   如果事先调用过`connect`方法，那么接下去调用`recvfrom()`或者`sendto`时，可能收到ECONNREFUSED错误（ICMP）。

   `connect`是在本地新建一个记录对端信息的五元组`Endpoint_S`，该映射使得UDP和ICMP控制通道绑定在一起，**当下层ICMP错误信息返回时，内核协议栈就能够根据`Endpoint_S`查找到本地socket端口，将错误信息转发给上层应用。**

   <u>对于无连接的UDP，每次`sendto`系统调用，内核都会在发送UDP数据报后释放本地存储的对端信息`Endpoint_S`等数据结构，这样下层有错误信息返回时，内核已经无法跟踪到本地的源socket了。（所以一般来说，仅调用`sendto`时很难收到对应源端口的ICMP报文）</u>

   注意，由于UDP和下层协议都是不可靠的协议，所以，不能够指望总能收到来自远端的ICMP包。（只要中间路由节点禁止了ICMP功能，socket api调用就无法捕获这些错误了）

4. UDP的负载均衡问题

   TCP服务器大多采用accept/fork模式，预先创建进程池或为每一个连接创建新进程/线程，充分利用多核CPU资源优势。

   **然而UDP无连接，无序，没有对端的信息，不知道数据包的前置和后续，无法享受到"连接"所拥有的状态信息，所以没法预先分配资源。**

5. 端口复用SO_REUSEADDR、SO_REUSEPORT

   TCP，在bind的时候所有可能产生四元组不唯一的的bind都会被禁止（**IP相同的情况下，TCP套接字处于TIME_WAIT状态下的socket，才可能重复绑定使用**）；

   对于connect，由于通信两端中的本端已经明确了，那么只允许connect从来没connect过的对端（在明确不会破坏四元组唯一性的conncet才允许发送SYN包）；

   对于监听的listen端，四元组的唯一性又connect端保证就ok了。

   + **TCP通过连接保证四元组的唯一性，accept进程（可以是进程组）完成连接请求，分配socket资源来标识连接，将socket连接分配给worker进程（线程组/进程组）进行实际的数据传输。这样多核CPU资源能够同时处理多个连接请求和处理多个连接的数据传输**。

   + UDP无连接，无法预先得到对端信息，按照固定的算法查找目标UDP socket，每次查找到的都是UDP socket列表中固定的socket。<u>即时一个服务器上多个进程创建多个绑定相同IP地址（SO_REUSEADDR），相同端口的UDP socket，会发现只有最后一个创建的socket能够接受到数据。</u>

     （也就是UDP多进程绑定相同端口只能起到容灾作用，不能负载均衡）

   + 理论上，Linux3.9以上内核，在server端使用SO_REUSEPORT，可在UDP socket查找时，将源IP和源端口考虑进来，保证多进程绑定单端口的UDP进程组能够负载均衡。（然而实际限制很多）

6. UDP的socket列表变化问题

   在采用SO_REUSEADDR、SO_REUSEPORT这两个socket选项后，内核会根据UDP数据包的4元组来查找本机上的所有相同目的IP地址，相同目的端口的socket中的一个socket的位置，然后以这个位置上的socket作为接收数据的socket。那么**要确保来至同一个Client Endpoint的UDP数据包总是被同一个socket来处理，就需要保证整个socket链表的socket所处的位置不能改变。**

   <u>然而，如果socket链表中间的某个socket挂了的话，就会造成socket链表重新排序，这样会引发问题。于是基本的解决方案是在整个服务过程中不能关闭UDP socket(当然也可以全部UDP socket都close掉，从新创建一批新的)。要保证这一点，我们需要所有的UDP socket的创建和关闭都由一个master进行来管理，worker进程只是负责处理对于的网络IO任务，为此我们需要socket在创建的时候要带有CLOEXEC标志(SOCK_CLOEXEC)</u>。

   （换言之就是UDP如果要确保多进程多核服务，保证远程客户端总是和本地服务端的同一个socket通信，那么需要另外类似TCP常用的Reactor模式，有专门处理请求的进程/线程来将UDP数据包分配给对应的socket进程。）

7. UDP和Epoll结合——UDP的Accept模型

   *UDP多进程同端口(SO_REUSEADDR、SO_REUSEPORT)的UDP socket，可利用内核的UDP socket查找算法来达到多进程的负载均衡。但是我们无法保证Linux内核的算法是否会在升级后变化、也无法保证负载均衡是否合理，所以更多时候需要我们自己建立accept模型，按需分配UDP socket来处理。*

   高性能的Server编程中，TCP已有成熟的解决方案，<u>因为天然的连接性，所以可以充分利用epoll等高性能event机制，采用多路复用、异步处理的方式，哪个worker进程空闲就处理accept连接请求来处理。</u>

   UDP无连接，无法明确四元组的对应关系，所以服务器接收到client的UDP数据包，难以判断需要交付给服务端的哪个UDP socket去处理，所以难以配合epoll事件通知机制进行开发。

   *（简言之，UDP无连接，前面的对端信息`Endpoint_S`也往往在发送数据后不久就释放了，约等于内核不会存储任何关于"连接"的四元组信息，所以多个相同端口的UDP socket难以抉择谁来处理来自client的UDP数据包。其实如果采用Reactor模型，可以让一个accept进程用于负责接收UDP数据，然后根据本地Redis等数据库存储的信息来判断交付给哪个UDP socket（worker进程）进行服务。这种时候最好使用直接内存进行IPC进程间通讯，避免内存复制带来的时间损失。）*

8. UDP fork模型-UDP accept模型之按需建立UDP处理过程

   如果对UDP建立accept模型，那么其中一种方案就是不同类型的UDP数据包交给不同的worker处理。（比如心跳、某类查询、某类新增等操作的分类）

   这种直接按需分配的方式，容易导致负载均衡不平衡。（比如心跳往往较频繁，但是某些新增操作较少，那么后者socket很长时间都是在闲置。）

   如果不是按需分配，那么每个socket都有能处理所有类型UDP包的能力，多个进程被唤醒时抢占式处理accept分配的任务，可能死锁。

   *（这里讨论主要是为了得出小结论：UDP无连接，所以对应的accept模型其实不好设计。而折中的方案就是结合超时策略设计类似accpet的模型。）*

9. UDP通信数据处理

   + 无连接、无数据/连接通道，导致每次client发送数据包，服务端都必须立即接受数据包。

     （可以理解为同一个channel处理多个client的数据，所以必须及时取数据，人为区分哪些数据包来自哪个client）

   + 无序。client发送1、2、3的数据包，实际到服务端可能是2、1、3，需要人为重排序。

     （这个其实好解决，给UDP数据包新增序号等机制就可以了。但是引入序号后还需要考虑序号数值越界等问题。或者统一将数据交由单线程的Reids处理、消息队列中间件。但是如果实时性要求高的服务，对这类方案就需要更复杂的设计。）

     （TCP有滑动窗口，可保证数据有序被上层应用处理）

   + 丢包。丢包可能是网络问题、接收端缓存区空间不足、路由分片时丢失等情况导致的。由于UDP验证包头的校验值不对时（数据不全or被篡改）采取的动作是丢弃数据包，所以对大UDP数据包的传输需要细致的设计。（避免传输时间浪费了，结果又直接丢弃整个UDP数据包。赔了夫人又折兵）

     （TCP缺少数据，由于连接，会向对端反馈。但是UDP简单粗暴直接丢弃不完整or被篡改的包，不和对端交流）

10. **UDP冗余发送**

    ![img](https://img-blog.csdn.net/20160603230358540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

    在外网通信链路不稳定的情况下，有什么办法可以降低UDP的丢包率呢？一个简单的办法来采用冗余传输的方式。一般采用较多的是延时双发，双发指的是将原本单发的前后连续的两个包合并成一个大包发送，这样发送的数据量是原来的两倍。这种方式提高丢包率的原理比较简单，例如本例的冗余发包方式，在偶数包全丢的情况下，依然能够还原出完整的数据，也就是在这种情况下，50%的丢包率，依然能够达到100%的数据接收。

11. 影响UDP高效的因素

    + 无法智能利用贷款导致资源利用率低

      TCP有流量控制（针对连接质量）和拥塞控制（正对互联网网络质量）。

    + 无法动态调整发包

      同上。

    + 改进UDP成本高（其实改进TCP成本更高，因为很多东西已经约定俗称了）

      google在UDP基础上实现了QUIC协议，享受TCP连接优点（能够标示会话），同时轻量如UDP。QUIC建立连接只需要1～2次数据包交互就可以完成连接（即使是等效于TCP+TLS的情况，依旧如此）。

      当前只有google的服务才支持QUIC协议（因为UDP本质，所以容易被误认为是高频的攻击被ISP误杀，且大多数防火墙等产品对QUIC的支持还不够完善=>或者说遗老公司的设备没有跟上时代。）

12. UDP常见使用场景

    + 实时性要求高
    + 多点通信（TCP维护连接成本太高）

> [一泡尿的时间，快速读懂QUIC协议](https://www.cnblogs.com/imteck4713/p/11777310.html)

### 5.2 TCP

#### 5.2.1 TCP概述

+ 面向连接*（三次握手、四次挥手）*
+ 每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的（一对一）。
+ 可靠交付
+ 全双工通信*（即时是A从B下载文件，B也会时不时自己给A回应，确认下载到哪里了。）*
+ 面向字节流

> [UDP协议在实现时有没有在发送端或者接收端设置缓冲区](https://zhidao.baidu.com/question/682350977560768452.html)
>
> [tcp 和 udp 缓冲区的默认大小及设置【转】](https://www.cnblogs.com/pang1567/p/3562029.html)
>
> [udp socket默认的发送和接收缓存区](https://www.cnblogs.com/chenjian688/p/12512808.html)
>
> UDP直接把整个数据报丢缓冲区，所以是一个整体，要么丢包要么获得完整的包；
>
> 而TCP是把字节数据丢到TCP缓冲区，等发送时才临时加上TCP首部字段，接受方接收到TCP数据报后，舍弃TCP首部，然后按序放入TCP缓存区中。由于放入TCP缓存区时，已经是纯粹的字节数据了，难以区分哪些字节数据原本是"打算当作一个整体"读取的，所以**TCP会有粘包、拆包问题**。（TCP开发，往往需要自己给TCP数据添加一些边界标识和数据长度，方便处理粘包、拆包问题）。
>
> [TCP缓冲区](https://blog.csdn.net/lyq_csdn/article/details/78811373)

**面向字节流**：

​	应用程序把字节流写入TCP缓存区，在空闲时将TCP缓冲区的字节按照顺序取出（取出的字节数不一定），然后加上TCP首部，够成TCP报文段，通过TCP连接发送到接收方的TCP缓冲区。对方在从TCP缓冲区读取字节流数据。

TCP连接的**端点**：

​	TCP把连接作为最基本的抽象。**每一条TCP连接有两个端点（套接字），端口号拼接到IP地址组成套接字，作为TCP的端点**。

```none
套接字socket = (IP地址：port端口号)

TCP连接::={socket1,socket2} = {(IP1:port1),(IP2:port2)}
```

#### 5.2.2 TCP的可靠传输

> [TCP协议如何保证可靠传输](https://www.cnblogs.com/xiaokang01/p/10033267.html)

​	TCP可靠传输的工作原理——**停止等待协议**。

```none
A  B                  A  B    
|\ |                  |\ |
| \|                  |  |
| /|                  |\ | 
|/ |                  | \|
无差错情况。            | /|       
A发送M1-->B。          |/ |          
B确认M1-->A          有差错情况。
					A发送M1-->B
					M1在传输过程丢包
					A超时重传M1(一般在RTT多一点的时间重传，也就是往返时间多一点点)
					B确认M1
```

还有两种情况：B确认M1的回应丢失，A重传M1；A发送M1结果传太久又重发M1，B2收到最新的M1并确认M1，之后又收到M1。

**A—>B，A向B发送数据，B收到重复的数据会丢弃。A只有收到B的确认后，才会认为发送的数据不需要重传。**

使用**确认**和**重传**机制，我们就可以在不可靠的传输网络上实现可靠的通信。

这种可靠的传输协议常称为**自动重传请求ARQ**（Automatic Repeat reQuest）

ARQ表明重传的请求是**自动**进行的*（自动指我RTT又多一点的时间要是没收到回应，就自动再重传给你一份）*。接受方不需要请求发送方重传某个出错的分组。

> [ARQ--百度百科](https://baike.baidu.com/item/ARQ/7402812?fr=aladdin)
>
> 传统[自动重传请求](https://baike.baidu.com/item/自动重传请求)分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。后两种协议是[滑动窗口](https://baike.baidu.com/item/滑动窗口)技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为[连续ARQ协议](https://baike.baidu.com/item/连续ARQ协议)。三者的区别在于对于出错的数据[报文](https://baike.baidu.com/item/报文)的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。除了传统的ARQ，还有混合ARQ（Hybrid-ARQ）。
>
> **优点**：比较简单 。因而被广泛的应用在[分组交换](https://baike.baidu.com/item/分组交换)网络中。
>
> **缺点**：1.**通信信道的利用率不高**，也就是说，信道还远远没有被数据比特填满。2.是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送[数据包](https://baike.baidu.com/item/数据包)来纠正错误的方法也严重的影响了它的传输速度。

$$
信道利用率U=\frac{T_D}{T_D+RRT+T_A}
$$

​	一般RTT变动不大（和物理设备、网络环境有关），T<sub>A</sub>是接受方发送+传播时延，一般极小(一收到就回应确认)，T<sub>D</sub>是发送方发送+传播时延，一般比T<sub>A</sub>大，比RTT小。所以<u>理论上发送方发送时延T<sub>D</sub>增大，信道利用率U就增大</u>。

​	现一般不采用传一次确认一次的**停等式ARQ**，而是采用**流水线传输**方式，发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认（发送一堆，对面之后也确认一堆，回应一堆ACK）。*由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。*

​	发送方**流水线传输**数据，一般搭配**发送窗口**。而接受方也不再一个一个确认，而是采用**累计确认**的方式（比如B收到4个字节后，直接告诉A下次从第5个字节开始发。这样A就知道前4个字节都接收了，发送窗口向右移动，将得到确认的前4字节从缓冲区剔除）。

> [滑动窗口--百度百科]([https://baike.baidu.com/item/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/8351795?fr=aladdin](https://baike.baidu.com/item/滑动窗口/8351795?fr=aladdin))

​	**TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一个报文段**。
$$
新的RTT_s = (1 - α) * (旧的RTT_s) + α * (新的RTT样本)
$$
​	很明显，α越大时，说明RTT_s越依赖新值，如果网络平稳，那么RTT一般变动不大，可让α小一点。（因为稳定的网络，我们认为新的RTT也不会有多大的变动。而波动大的网络，某些时间段拥塞某些时间端又很顺畅的，就需要α调大。）

**超时重传时间**应略大于上面得出的**加权平均往返时间**RTT_s*（比如多次RTT响应分别9，10，11，那么取平均10）*。

​	*[RFC2988](https://tools.ietf.org/html/rfc2988)推荐的α值为1/8。*

#### 5.2.3 TCP报文段的首部格式

> [TCP报文格式详解](https://blog.csdn.net/paincupid/article/details/79726795)
>
> **TCP首部定长部分和IP数据报一样都是20字节。（UDP首部共8字节，没有可选部分）**

![img](https://iknow-pic.cdn.bcebos.com/810a19d8bc3eb135e1c04ec7b61ea8d3fd1f4443?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)

> [tcp 协议小结](https://luoguochun.cn/post/2016-09-23-tcp-fuck/)
>
> [TCP/IP 详解卷一 - TCP CWR、ECE、URG、ACK、PSH、RST、SYN、FIN控制位](https://www.cnblogs.com/bonelee/p/9077266.html)

![tcp协议头](https://luoguochun.cn/img/tcp/tcp-header2.png)

![img](https://farm1.staticflickr.com/792/27194088468_4cb0141fc8_b.jpg)

+ 序号（Sequence number）：TCP数据报按顺序发送，序号每次增加到下次发送的TCP报文段在缓存的偏移量位置（初始值可能是0或其他值）

+ 确认号（Acknowledgment number）：接受方确认数据，并且要求发送方下次给自己数据的序列号。*（比如确认收到序号1长度517的TCP数据报，下次发送方发数据报应该从1+517=518序号的位置发送数据报给我）*

+ 数据偏移/首部长度（Header Length）：4bit，基本单位是4字节（和IP数据报的"**首部长度**"一样），4bit最多表示二进制15，即TCP首部最大长度就60字节（4字节*15=60字节，固定首部20+40字节可选）

+ 保留（Resv）：6bit，无用(以后可能拓展)，全0。

+ 控制位（Flags）：

  1. **CWR**(Congestion Window Reduced) & **ECN**（ECN-Echo, Explicit Congestion Notification）：

     **CWR** 阻塞窗口已减少，意思是告诉对端我已经按照你的要求，进行阻塞窗口减少了，并启动阻塞算法来控制我的发包速度； **ECN** 显式阻塞窗口通知，意思通知发送方，我接收的报文出现了阻塞，请控制发包速度。

     也就是说，**CWR** 和 **ECN** 必须配合使用，**CWR** 是收到 **ECN** 的应答。

     此外，在tcp三次握手时，这两个标志表明tcp端是否支持**ECN**。如果建立连接一方支持，则在发送的`SYN`包，将 **ECN** 标志置为1，如果服务端也支持，则在`ACK`包只设置**ECN**。缘由：tcp建立连接后，报文经过经过路由或网关等网络设备后，在路由器或网关等网络设备出现阻塞时，路由器或网关等设备设置**IP**层的某个标志表明出现阻塞，这样接收可以明确知道报文出现了阻塞。然而，需要知道阻塞进行阻塞控制的是报文发送方而非接收方。所以接收方会在`ACK`报文中设置**ECN**标志，同时发送方在`ACK`中设置**CWR**标志，表明已经收到**ECN**，并进行了减少阻塞窗口操作和启用阻塞算法。

  2. **URG**(Urgent):等于1时，配合紧急指针（假设数值X），标识缓存区偏移量为X的字节需要赶紧被发送。这时候系统会将X位置和排队排在它之前的缓存区数据尽快发送出去。（本来应该慢慢排队的，变成赶紧让排自己前面的数据被发出去。比如有些应用可能要凑1460字节才发送一次数据，那如果某一时刻瞬间往缓存区放入数据1460、100、1460，中间这100字节需要赶紧被发送的，就可以在第1561字节标记URG=1，原本这100应该和接下去1360凑一个包再发送的，就变成这100会直接先发送，后面剩下的1460同样是读取凑曾一个包再发送。）*（据说实际基本没有多少服务真正用到URG。）*

     > [RFC6093提议不要用URG，但是现在也没有正式弃用](https://tools.ietf.org/html/rfc6093)

  3. ACK(Acknowledgment):为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。

  4. **PSH**(Push):由于发送端一般凑够MSS大小的数据内容才发送报文，但是如果某一时刻只剩下最后一部分数据需要发送，剩余部分小于MSS，这时候标记PSH=1，告知操作系统的TCP协议栈程序需要赶紧发送最后这部分的数据报。接受方接受到带有PSH标记的数据报，也会赶紧提交给上层应用（比如赶紧读取完接收缓存区，把这个PSH的报文交给上层）。*（一般用在缓冲区内容不多，但是又需要赶紧发送报文让对面赶紧处理的情况。抓包可以看到HTTPS的TLS建立安全连接的过程中交互的数据报PSH=1）*

  5. RST(Reset)：连接不可达*(通常是想发数据报给另一头，而另一头的套接字已经不用于TCP连接时，对方发来一个带有RST=1的数据包。比如对面因为某些原因提早释放了连接，或者对面压根没有用这个套接字和你建立过连接。可以用于RST攻击)*

     > [TCP中的RST标志(Reset)详解](https://blog.csdn.net/a_tu_/article/details/80389878)
     >
     > A和服务器B之间建立了TCP连接，此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。实际上从上面RST标志位的功能已经可以看出这种攻击如何达到效果了.......（详情看文章）

  6. SYN(Synchronize):建立连接时使用，三次握手的前两次，A->B和B->A的SYN=1,其余情况SYN=0。

  7. FIN(Finish):在四次挥手的第一次和第三次，客户端向服务器和服务器向客户端表明要关闭连接时，FIN=1。

     > [详解 TCP 连接的“ 三次握手 ”与“ 四次挥手 ”](https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc)

+ 窗口（Window Size）：16bit，通知发送方自己的本地接收缓存大小（接收端滑动窗口），最大值就是2^16-1=65535字节。*（在SYN建立连接阶段，协商win和WS，之后会根据带宽和RTT再定下来最终的win和RS计算出实际通信的滑动窗口大小）*。

+ 检验和（TCP Checksum）：对TCP首部和TCP数据的校验和，和UDP校验和计算方式相同，需要配合IP伪首部计算。

  > [TCP检验和](https://www.cnblogs.com/zxiner/p/7203192.html)
  >
  > [TCP头校验和计算算法详解](https://www.cnblogs.com/RodYang/p/3265515.html)

+ 紧急指针（Urgent Pointer）：只有当 *URG* 标志置 *1* 时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。*（ TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。前面提到URG很少用到，所以这个也理所当然的很少用到了）*

+ 可选部分（Options）：*（只列举几个抓包经常需要注意的）*

  + **MSS**(Maximum Segment Size) tcp报文最大传输长读，tcp在三次握手建立阶段，在`SYN`报文交互该值，注意的是，这个数值并非协商出来的，而是由网络设备属性得出。**MSS**一个常见的值是1460(**MTU**1500 - **IP**头部 - **TCP**头部)。
  + **SACK**(Selective Acknowledgements) 选择ACK，用于处理segment不连续的情况，这样可以减少报文重传。比如： A 向B发送4个segment，B收到了1,2,4个segment，网络丢失了3这个segment。B收到1,2segment后，回应`ACK` 3，表示1,2这两个`ACK`已经收到，同时在选项字段里面，包括4这个段，表示4这个segment也收到了。于是A就重传3这个segment，不必重传4这个segment。B收到3这个segment后，直接`ACK` 5，表明3,4都收到了。*（抓包可以知道会具体标识需要重传的左边界和右边界）*
  + **WS**(Window Scale) 在tcp头部，`Window Size(16Bit)`表面接收窗口大小，但是对于现代网络而言，这个值太小了。所以tcp通过选项来增加这个窗口的值。**WS**值的范围0～14，表示`Window Size(16Bit)`数值先向左移动的位数。这样实际上窗口的大小可达31位。在程序网络设计时，有个`SO_RECVBUF`，表示设置接收缓冲的大小，然而需要注意的是，这个值和接收窗口的大小不完全相等，但是这个数值和接收窗口存在一定的关系，在内核配置的范围内，大小比较接近。
  + **TS**(Timestamps) Timestamps在tcp选项中包括两个32位的timestamp: **TSval**(Timestamp value)和**TSecr**(Timestamp Echo Reply)。如果设置了**TS**这个选项，发送方发送时，将当前时间填入**TSval**，接收方回应时，将发送方的**TSval**填入**TSecr**即可(注意发送或接收都有设置**TSval**和**TSecr** )。**TS** 选项的存在有两个重要作用：一是可以更加精确计算RTT(Round-Trip-Time)，只需要在回应报文里面用当前时间减去**TSecr**即可；二是PAWS(Protection Against Wrapped Sequence number, 防止sequence回绕)，什么意思呢？比如说，发送大量的数据：0-10G，假设segment比较大为1G而且sequence比较小为5G，接收端接收1,3,4,5数据段正常接收，收到的发送时间分别1,3,4,5，第2 segment丢失了，由于**SACK**，导致2被重传，在接收6时，sequence由于回绕变成了1，这时收到的发送时间为6，然后又收到迷途的2，seq为2，发送时间为2，这个时间比6小，是不合法的，tcp直接丢弃这个迷途的报文。
  + **UTO**(User Timeout) **UTO**指的是发送`SYN`，收到`ACK`的超时时间，如果在**UTO**内没有收到，则认为对端已挂。 在网络程序设计的时候，为了探测对端是否存活，经常涉及心跳报文，通过tcp的keepalive和**UTO**机制也可以实现，两者的区别是，前者可以通过心跳报文实时知道对端是否存活，二后者只有等待下次调用发送或接收函数才可以断定： 1) `SO_KEEPALIVE`相关选项 设置`SO_KEEPALIVE` 选项，打开keepalive机制。 设置`TCP_KEEPIDLE` 选项，空闲时间间隔启动keepalive机制，默认为2小时。 设置`TCP_KEEPINTVL`选项，keepalive机制启动后，每隔多长时间发送一个keepalive报文。默认为75秒。 设置`TCP_KEEPCNT`选项，设置发送多少个keepalive数据包都没有正常响应，则断定对端已经崩溃。默认为9。 由于tcp有超时重传机制，如果对于`ACK`丢失的情况，keepalive机制将有可能失效。

+ 填充：和IP首部一样，如果TCP首部不能被4字节（16bit）整除，就填充0直到能被4字节整除。

> [TCP中的MSS和窗口怎么理解](https://zhidao.baidu.com/question/537680754.html)
>
> MSS(Max Segment Size) 是TCP数据包每次能够传输的最大数据分段，其中并不包括TCP首部。而且MSS只出现在SYN报文段中。一般来说，MSS的值在不分段的情况会越大越好，比如一个外出接口的MSS值是MTU减去IP和TCP首部长度（一般1460）。
>
> **TCP连接协商对方可以发给自己的单个TCP报文的数据部分的最大大小**。
>
> [wireshark tcp 协议分析](https://luoguochun.cn/post/2014-07-23-wireshark-tcp/)
>
> [TCP Windows and Window Scaling](https://packetlife.net/blog/2010/aug/4/tcp-windows-and-window-scaling/)
>
> **大致就是说wireshark抓包获取的win和WS字段。win是原本协商的本地接收缓冲区大小，而WS是弥补win只能最大2^16字节的缺憾，不考虑时延带宽积时，理想win = win * WS，这个只是理想值，比win大很多，考虑时延带宽积等因素后，会在计算出一个最终的win（理想win >= 最终win >= win）**
>
> 1. Bandwidth Delay Product = (bandwidth * RTT) / 8
> 2. **Optimum Window Size = 2 * BDP**
> 3. Buffer size = BDP / MTU
>
> 假设除了传播时延以外，其他时延忽略不计，然后传播时延超级大；
>
> 如果A和B的上传和下载带宽都是 100Byte/s（这里用Byte，不用传统的bit了，方便举例一点），传播时延假设10s，RTT=传播时延*2=20s。最佳窗口大小应该是2000Byte（**带宽\*RTT = 带宽\*传播时延\*2 = 时延带宽积\*2**）。
>
> 1. 假设A发送窗口（B的接收窗口）是1000Byte：
>
>    A向B发送出了1000Byte的最后一个bit，这时候1000Byte的第一个bit到达B，然后B马上回送前1000字节的确认包（假设第一个bit到后，后续的完整0~1000字节瞬间也到达）。
>
>    由于由于传播时延很大，B发送确认包，再怎么快也得等10s，这10s，A一直在等确认包（浪费时间）
>
> 2. A发送窗口（B的接收窗口）是2000Byte：
>
>    同理A发送1000Byte都到达B后，B马上回发确认（同时把自己的滑动窗口向右移动1000Byte，由于窗口大小1000，还可以继续往后发后1000~2000这1000Byte的数据）。
>
>    A继续发送后1000~2000Byte，当第2000字节第一个bit到B时，正好A接受到B的前1000字节的确认包，移动自己发送窗口1000Byte。B接受完1000~2000这后1000Byte数据，右移接收窗口1000Byte（同时回送后1000Byte的确认包）
>
>    ....
>
> **可以看出来这是最理想的窗口大小（带宽\*RTT），A和B之间能够一直不间断的收发数据**。
>
> [带宽时延积--百度百科]([https://baike.baidu.com/item/%E5%B8%A6%E5%AE%BD%E6%97%B6%E5%BB%B6%E7%A7%AF/15859660#2](https://baike.baidu.com/item/带宽时延积/15859660#2))
>
> [windows的socket缓冲区到底多大的一个小1测试](https://blog.csdn.net/wxq1987525/article/details/6105433)
>
> [TCP 协议中的 Window Size与吞吐量](https://www.cnblogs.com/djiankuo/p/7019768.html)
>
> [Wireshark的window size value和calculated window size](https://blog.csdn.net/weixin_34051201/article/details/91608467)
>
> [TCP接收窗口的调整算法（上）](https://blog.csdn.net/zhangskd/article/details/8588202)

#### 5.2.4 TCP的滑动窗口

> [滑动窗口--百度百科]([https://baike.baidu.com/item/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3](https://baike.baidu.com/item/滑动窗口))
>
> 滑动窗口概念不仅存在于数据链路层，也存在于传输层，两者有不同的协议，但基本原理是相近的。其中一个重要区别是，**一个是针对于帧的传送，另一个是字节数据的传送。**(链路层比如[ARQ--百度百科](https://baike.baidu.com/item/ARQ/7402812?fr=aladdin))
>
> [滑动窗口机制](https://baike.baidu.com/item/滑动窗口机制)为端到端[设备间](https://baike.baidu.com/item/设备间)的数据传输提供了可靠的[流量控制](https://baike.baidu.com/item/流量控制)机制。然而，它只能在源端设备和目的端设备起作用，当网络中间设备（例如[路由器](https://baike.baidu.com/item/路由器)等）发生拥塞时，滑动窗口机制将不起作用。
>
> [差错控制--百度百科]([https://baike.baidu.com/item/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6](https://baike.baidu.com/item/差错控制))
>
> 差错控制（error control）是在数字通信中利用[编码](https://baike.baidu.com/item/编码)方法对传输中产生的差错进行控制，以提高数字消息传输的准确性。

​	**TCP的滑动窗口以字节为单位**。

​	A向B建立连接时协商各自的接收窗口的大小（发送数据给对方的发送窗口大小 <= 对方的接收窗口大小）

​	之后A每次最多可以送出滑动窗口范围内的所有数据，滑动窗口只有左边界相接的连续字节收到确认时，才会向右移动。而B作为接受方，每次接收到数据后，向A反馈确认信息，如果接收到的数据连续的部分与当前滑动窗口左边界相连，则向右移动自己的接收窗口。

​	最原始的**停等协议**，即时A发送端用了滑动窗口技术能够一次发送多个字节，但是每次接受方收到一个字节就回应一次ACK确认消息，那么A发送端就要频繁地改动滑动窗口，效率低。（等待一段时间没接受到B的确认，A也会自动**超时重传**。）

​	改进一：**累计确认**，B收到数据后，不急着直接回应ACK确认信息，稍微有个等待时间，然后收到连续几个字节后，再只回应一个ACK确认信息，标识需求的下一个数据报序号。

​	改进二：**选择重传**，由于B收到信息后，ACK确认信息是于原本序号连续的部分的最大值下一个数值（比如收到序号1，2，6，7，8，那么确认号是3），那么A收到信息后，会把3以及之后的数据再重传一遍（就算B收到6，7，8重复数据会丢弃，但是这毫无疑问浪费带宽、浪费时间）。当B接收到不连续的数据时，先按照改进一会先等一小会，然后回送一个特殊的确认包（使用TCP数据报的可选字段SACK标识收到的不连续的后半部分数据。这里确认信息为ack=3，sack（6~9），ack确认号标识左半部连续部分下一个需要传的序号，而6~9标明收到6~8可以不用重传，而9开始的是没收到的。）

​	sack可能出现”<u>多个范围</u>“，也可能出现”<u>合并多个</u>“的情况：

+ 多个范围：B收到（1~4，6~9，11~12），确认回应（ack=5，sack（6~10，11~13））；

+ 合并多个：B收到（1~4，9~12）回应（ack=5，sack=9~13），下一次B收到（5~7，13~16）则回应（ack=8，sack=9~17）

**简言之，sack作用就是告诉发送方A，自己已经收到后半部分的数据，告知A以后不用重复传后面的数据**。

> [sack--百度百科](https://baike.baidu.com/item/sack/11068287?fr=aladdin)
>
> SACK(Selective ACK)是TCP选项，它使得接收方能告诉发送方哪些报文段丢失，哪些报文段重传了，哪些报文段已经提前收到等信息。根据这些信息TCP就可以只重传哪些真正丢失的报文段。**需要注意的是只有收到失序的分组时才会可能会发送SACK，TCP的ACK还是建立在累积确认的基础上的**。也就是说如果收到的报文段与期望收到的报文段的序号相同就会发送累积的ACK，SACK只是针对失序到达的报文段的。SACK包括了两个TCP选项，一个选项用于标识是否支持SACK，是在TCP连接建立时时发送；另一种选项则包含了具体的SACK信息。
>
> 当我们接收到ack的时候，我们会判断sack段，如果包含sack段的话，我们就要进行处理。
>
> [关于TCP协议的SACK选项功能](https://www.docin.com/p-2032477545.html)
>
> [TCP对SACK的处理以及乱序的处理细节](https://blog.csdn.net/dog250/article/details/51336850)

#### 5.2.5 TCP的流量控制

> [流量控制--百度百科]([https://baike.baidu.com/item/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6](https://baike.baidu.com/item/流量控制))
>
> 流量控制（traffic control）在不同的领域有不同的含义。如航空流量控制，[网络流量控制](https://baike.baidu.com/item/网络流量控制/10529543)等。
>
> 网络流量控制（Network traffic control）是利用[软件](https://baike.baidu.com/item/软件/12053)或[硬件](https://baike.baidu.com/item/硬件/479446)方式来实现对网络数据流量进行控制的一种措施。
>
> [拥塞窗口--百度百科]([https://baike.baidu.com/item/%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3/4399307?fr=aladdin](https://baike.baidu.com/item/拥塞窗口/4399307?fr=aladdin))
>
> 拥塞窗口，是卫星通信在因特网中防止通信拥塞的一种措施，它是在发端采用了一种“拥塞避免”算法和“慢速启动”算法相结合的机制。“拥塞窗口”就是“拥塞避免”的窗口，它是一个装在发送端的可滑动窗口，窗口的大小是不超过接收端确认通知的窗口。“慢速启动”是在连接建立后，每收到一个来自收端的确认，就控制窗口增加一个段值大小，当窗口值达到“慢速启动”的限值后，慢速启动便停止工作，避免了网络发生拥塞。
>
> [如何理性的调整「rwnd」和「cwnd」的大小](https://blog.csdn.net/lishanmin11/article/details/77165077)

​	**TCP使用滑动窗口发送和接收数据。窗口的大小在建立TCP连接时，会进行协商，但是协商以后的数据传输过程，窗口大小也并不是一尘不变的。**

​	比如A向B发送8字节数据，B的接收窗口确实也是8字节大小，正常情况下，B接收后发送确认信息并右移滑动窗口。但是这时候要是缓存耗尽等因素导致滑动窗口没法立即向右滑动，就会出现A发送窗口已经右移并且发了新的一批8字节数据，而B接收窗口rwnd没有右移动窗口，没法装下新来的8字节数据，就丢包了。

​	为了避免B来不及接收数据的情况，B会在确认包里面修改win参数（缩小win值，表示自己的接收窗口rwnd缩小）。而A发送方看到这个确认信息后，也会对应缩小自己的发送窗口，**避免B的接收窗口rwnd容不下数据导致丢包**。在一些特殊情况下，B也会发送win=0的数据包给A，让A暂时不要发送数据给自己。

#### 5.2.6 TCP的避免拥塞

> [拥塞控制](https://blog.csdn.net/qican_7/article/details/100523652)

​	**流量控制**是一对一场景，接受方由于自身的原因没法及时移动接收窗口，所以要求发送方缩小发送窗口，避免自己容不下数据导致丢包。（这里的丢包不是网络原因，单纯是因为自己的接收窗口无法容纳发送端发送的后续数据。）

​	**避免拥塞**（拥塞控制）是针对所有使用TCP通信的用户，防止发送方发送窗口过大导致网络拥塞进而全网瘫痪（这时候不管哪个TCP用户发送数据都丢包，这就不是接受方窗口大小问题了，而是整个网络不畅）。

​	出现资源拥塞的条件：对资源需求的总和>可用资源

​	<small>**拥塞控制**是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</small>

​	<small>**流量控制**往往指在给定的发送端和接收端之间的点对点通信量的控制，它所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</small>

![img](https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4089851386,3740632925&fm=26&gp=0.jpg)

​	理想情况下，我们传输多少的数据，网络吞吐量就是多少。但是实际情况下，如果没有进行拥塞控制，再负载量增多时，甚至会出现吞吐量倒退且无限接近0的情况。为了避免最坏情况（大家谁也别想上网），我们不如预先设置拥塞控制的规则，虽然吞吐量不能向理想情况那样，但是至少不会出现死锁的情况（大家都用不了网）。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzMwODc5LzIwMTcwMi83MzA4NzktMjAxNzAyMTkxNTAzNDU2NjAtMTg0ODQ3NTU1Ny5wbmc?x-oss-process=image/format,png)

下面介绍几个**拥塞控制**的手段：<u>慢启动（慢开始）、拥塞避免、快重传（可和快恢复搭配使用）、快恢复</u>。

1. 慢启动：

   发送方维持**拥塞窗口(cwnd)**（congestion window）。

   发送方控制拥塞窗口的原则是：

   + 只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。
   + 只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

   **慢开始门限ssthresh**的用法如下：

   （**拥塞窗口单位不使用字节而使用报文段。慢开始门限的初始值设置为16个报文段，ssthread=16**）

   1. 当cwnd<sshresh时，使用**慢开始算法**（cwnd初始值1，然后每次*2）。
   2. 当cwnd>ssthresh时，停止使用满开始算法而改用拥塞避免算法（cwnd每次+1）。
   3. 当cwnd=ssthresh时，既可以使用慢开始算法，也可以使用**拥塞避免算法**。

2. 拥塞避免：

   ​	让拥塞窗口cwnd缓缓地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。

   无论在**慢开始阶段**还是在**拥塞避免阶段**，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要**把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）**`ssthresh=出现拥塞时的cwnd/2`。

   然后把**拥塞窗口cwnd重新设置为1，执行慢开始算法**。*（这种做法后面弃用了，改用快恢复）*

   这样做的<u>目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕</u>。

   *<small>"拥塞避免"并非指完全能够避免了拥塞。利用以上的措施想要完全避免网络拥塞是不可能的。(永远也不会有真正不会出现阻塞的算法，除非全球网络统一实时管理。)</small>*

   *<small>"拥塞避免"是说在拥塞避免阶段把拥塞窗口为按线性规律增长，使网络比较不容易出现拥塞。</small>*

3. 快重传

   ​	**快重传算法**首先要求该接受方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。

   （利用前面5.2.4 TCP的滑动窗口提到的sack字段，标识已经收到的后半段数据。由于中间出现缺口，后面接收到的数据报每次确认都会是相同的ack。比如1~3，9~10，11~13，15~19，那么收到9~11、11~13、15~19的数据报，回应的确认号ack都是4，而三次都包含sack字段标识。）

4. 快恢复

   ​	快恢复，当发送端收到连接三个重复的确认*<small>（快重传）</small>*时，就执行"乘法减小"算法，把慢开始门限ssthresh减半，但拥塞窗口cwnd现在不设置为1，而是设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（"加法增大"），使拥塞窗口缓慢地线性增大。

**`发送方的发送窗口的上限`应当为`接收方窗口rwnd`和`拥塞窗口cwnd`这两个变量中较小的一个**，即应按一下公式确定：
$$
发送窗口的上限值=Min[rwnd,cwnd]
$$

​	一般情况下，发送窗口初始值并不是1，如果适当增大`cwnd`初始值，对发送端来说传输效率会更高。Google在这方面做了大量的[研究(翻墙提醒)](https://developers.google.com/speed/protocols/tcpm-IW10)，权衡了效率和稳定性之后，**最终给出的建议是设定cwnd初始值=10MSS**。如果你的Linux版本不太旧的话，那么可以通过如下方法来调整「cwnd」初始值：

```shell
shell> ip route | while read r; do
           ip route change $r initcwnd 10;
       done
```

​	需要提醒的是片面的提升发送端`cwnd`的大小并不一定有效，这是因为前面我们说过网络中实际传输的未经确认的数据大小取决于`rwnd`和`cwnd`中的较小值，所以一旦接收方的`rwnd`比较小的话，会阻碍`cwnd`的发挥。

>
>[TCP的快速重传机制](https://blog.csdn.net/whgtheone/article/details/80983882)
>
>[如何理性的调整「rwnd」和「cwnd」的大小](https://blog.csdn.net/lishanmin11/article/details/77165077)
>
>[tcp 协议小结](https://luoguochun.cn/post/2016-09-23-tcp-fuck/)
>
>[一文解释清楚Google BBR拥塞控制算法原理](https://cloud.tencent.com/developer/article/1482633)
>
>[【洋葱】VPS集体颤抖！最强BBR加速！BBR Plus 魔改BBR 锐速 对比（谷歌云搬瓦工VPS加速测试）](https://www.bilibili.com/video/BV1Ui4y1t7P4?from=search&seid=7767169388912517625)
>
>[来自Google的TCP BBR拥塞控制算法解析](https://blog.csdn.net/dog250/article/details/52830576)
>
>**BBR拥塞控制算法，不从丢包角度考虑上传带宽，而是从本质的上传带宽和RRT配合一些参数来计算上传窗口，使得发送端能够将发送带宽利用得更接近理想的极限值。**
>
>**现在也常用于VPS的加速上（因为使用BBR比其他阻塞算法更能使上传带宽接近实际可用的最高值）。**

#### 5.2.7 TCP的三次握手和四次挥手

> [详解 TCP 连接的“ 三次握手 ”与“ 四次挥手 ”](https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc)
>
> [TCP三次握手、四次挥手及状态转换图](https://www.cnblogs.com/wujing-hubei/p/5699773.html)
>
> [tcp 协议小结](https://luoguochun.cn/post/2016-09-23-tcp-fuck/)

传输连接有三个阶段，即**连接建立**、**数据传送**和**连接释放**。

TCP连接的建立都是采用**客户服务器方式**。

主动发起连接建立的应用进程叫作客户（client）。

被动等待连接建立的应用进程叫作服务器（server）。

![TCP状态机](https://luoguochun.cn/img/tcp/tcp-state.png)

**三次握手**：

​	假设A客户端主动申请和B服务器建立连接：

1. A—>B：序号seq = x，确认号ack = 0，SYN=1，ACK=0（Not Set，因为都还没接收对方数据呢），其他参数
2. B—>A：序号seq = y，确认号ack = x+1，SYN=1，ACK=1，其他参数
3. A—>B：序号seq = y+1，确认号ack = y+1，SYN=0，ACK=1，其他参数



状态变化：(x)表示三次握手的第x次握手步骤

A：CLOSED（假想的默认状态）—>（1）执行后—> SYN_SENT（表示A刚发送了SYN，准备建立连接）—>（2）收到后，（3）执行后—>ESTABLISHED（建立连接了）

B：CLOSED（假想的默认状态）—> LISTEN（某个套接字处于监听状态，等待建立连接） —>（1）收到后，（2）执行后—> SYN_RCVD（表示B收到了SYN建立连接的请求，这个状态特别短）—>（2）收到后，（3）执行后—>ESTABLISHED（建立连接了）

![img](https://pics1.baidu.com/feed/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg?token=c86d4509157378798ebbccbe843486d1&s=9746F8123F5754CA48D574DA0300D0B2)

利用TCP建立连接的三次握手，可以玩很多攻击。

> [【计算机网络原理·实验·第八章】SYN攻击&Land攻击](https://blog.csdn.net/Chahot/article/details/107331792)
>
> SYN攻击：黑客机故意捏造大量IP和受害者IP申请建立连接（第一次握手），然后之后不ACK回应，使受害者有大量未完成的连接一直处于SYN_RCVD状态，最后耗尽受害者系统资源。
>
> Land攻击：类似SYN攻击，但是源地址和目标地址都是受害者IP，让受害者主机不断自己和自己建立空连接（空连接要经过一段时间后才会自动断开），最后耗尽受害者系统资源。



**四次挥手**：

​	随不想往对面发数据了，就可以主动先挥手了。这里假设A客户端先动的手，申请要和B服务器断开连接：

*（其实大多数服务都是 服务器 主动申请和我们客户端断开连接，也就是服务器先动手）*

1. A—>B：序号seq = x，确认号ack = w，FIN=1，其他参数
2. B—>A：序号seq = y，确认号ack = x+1，FIN=0，其他参数
3. B—>A：序号seq = z，确认号ack = x+1（如果步骤2之后直接3，B也正好没有想传的数据时），FIN=1，其他参数
4. A—>B：序号seq = x+1，确认号ack = z+1，FIN=0，其他参数



状态变化：(x)表示四次挥手的第x次挥手步骤

A：ESTABLISHED —>（1）执行后—> FIN_WAIT_1（自己发送了FIN等待对方回应）—>（2）收到后—>FIN_WAIT_2（等待对方也发送FIN给自己）—>（3）收到后，（4）执行后—>TIME_WAIT（2MSL，确保（4）有足够时间和重传机会到达B）—>CLOSED

B：ESTABLISHED —> （1）收到后，（2）执行后 —> CLOSE-WAIT（可能还有数据要发给A，发完后再告知A要断开连接）—> （3）执行后 —> LAST_ACK（自己也发出了FIN，等待A最后发来ACK就断开连接）—> (4)收到后 —>CLOSED

![img](https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073)

*注:MSL(最大分段生存期)指明TCP报文在Internet上最长生存时间,每个具体的TCP实现都必须选择一个确定的MSL值.RFC 1122建议是2分钟,但BSD传统实现采用了30秒.TIME_WAIT 状态最大保持时间是2 \* MSL,也就是1-4分钟.*

> [MSL （计算机网络术语）--百度百科](https://baike.baidu.com/item/MSL/13975171?fr=aladdin)
>
> MSL是网络中的MSL意思是多层交换（Multilayer Switching Protocol ），指的是交换机能通过硬件来交换和路由选择数据包，并可能通过硬件支持4~7层交换。通过硬件进行交换和路由时，即使所有的端口同时发送信息流，吞吐量也可达到或接近线速。
>
> MSL(Maximum Segment Lifetime)报文最长存活时间。

同样利用TCP断开连接，也有相应的攻击可以玩：

> [TCP中的RST标志(Reset)详解](https://blog.csdn.net/a_tu_/article/details/80389878)
>
> A和服务器B之间建立了TCP连接，此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。实际上从上面RST标志位的功能已经可以看出这种攻击如何达到效果了.......（详情看文章）

#### 5.2.8 Linux网络IO之epoll、poll、select

> [Reactor模式详解](https://www.cnblogs.com/winner-0715/p/8733787.html)
>
> [select、poll、epoll之间的区别(搜狗面试)](https://www.cnblogs.com/aspirant/p/9166944.html) < === 很详细
>
> 下面内容是我之前netty学习+上述篇文章的大致读后感总结，这里不展开了。（两篇文章都不错，推荐）

​	TCP需要建立连接，在实际网络编程中，通常采用Reactor模式<small>（Reactor模式吸收了IO多路复用模式的优点）</small>，使用单独的Boss线程组处理连接请求`accept()`，在将建立连接Socket分配给Worker工作线程组，工作线程组注册自己需要处理的事件（需要自己编写相应的处理逻辑），将socket和需监听的事件再告知Boss线程组。之后由Boss线程组监听到某socket的某事件发生时，再通知对应的worker线程组处理事件。

​	![img](https://upload-images.jianshu.io/upload_images/4235178-d570de7505817605.png)

​	Reactor的accpetor使用到了IO多路复用技术，从而可以做到某一个线程就能监听（遍历）多个socket。这个计数是需要操作系统支持的，而Linux用的比较多的是epoll（其还支持poll、select）。 

​	epoll、poll、select都是同步IO，在数据可用时，应用程序需要主动从内核态复制数据到用户态（异步IO则无需用户进程感知该过程）。

​	select是POSIX规定的通用性接口，而epoll是Linux独有的。

​	poll和select大致相同，都是无差别轮询所有socket，当某个socket有事件发生则处理，由于忙自旋轮选所有线程，所以对大量的socket线程处理比较乏力。而epoll基于事件驱动，为socket绑定回调函数，仅处理活跃的socket线程，所以理论上处理大量socket线程的能力要更强（当然前提是每个线程的事件处理短且不造成阻塞）。

*（这里不过是简单地提了一下，建议阅读上面推荐的文章，比较详细）*

### 5.3 QUIC

#### 5.3.1 QUIC概述

> [QUIC--百度百科](https://baike.baidu.com/item/QUIC/17341272?fr=aladdin)
>
> QUIC（Quick UDP Internet Connection）是谷歌制定的一种**基于UDP**的低时延的互联网传输层协议。在2016年11月国际互联网工程任务组(IETF)召开了第一次QUIC工作组会议，受到了业界的广泛关注。这也意味着QUIC开始了它的标准化过程，成为新一代传输层协议。
>
> 通常游戏、流媒体以及VoIP等应用均采用UDP，而网页、邮件、远程登录等大部分的应用均采用TCP。
>
> [技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解]()
>
> [通往QUIC之路](https://www.jianshu.com/p/2fbc26eb348a)
>
> [如何看待 HTTP/3 ？](https://www.zhihu.com/question/302412059?sort=created)

​	*<small>现在还没有看到有国内企业大量投入使用QUIC的迹象，因为本身也有不少企业自己用UDP配合Protobuf等实现了类似QUIC的东西。这里就先大致了解下。</small>*。

+ 由于UDP基于用户态，可扩展性较高，所以QUIC还是有推广的可能性的。*<small>（TCP一般内置系统内核态，也就是TCP连接、流量控制、拥塞控制等过程都是操作系统替我们进行的，我们无感知。再者如果大改TCP，实际的路由器等物理设备也需要大规模升级调整，不大现实。）</small>*
+ QUIC集成了类似TLS的功能，同样有身份校验和数据加密。*<small>（且QUIC就连报文首部也需要身份认证，报文部分则是经过加密）</small>*
+ 同样采用多路复用的情况下，QUIC出现队头阻塞的概率比TCP小不少，且即出现了队头阻塞，QUIC一般受到的影响也更小。*<small>（假如同一个通路有4个TCP stream，传输中第二个有 TCP segment缺失，那么排在其后的数据就算到了服务器接受端，也会阻塞，等到丢失部分和后续部分连续后，后续到达的部分才有机会从缓存被读取到应用程序中。）</small>*
+ QUIC旨在用64位随机数作为ID标识用户，而不是TCP通过IP和port标识。*<small>（虽然我们一般进行UDP开发，也是会做一套ID识别用户的系统。这样好处就是NAT问题相对好处理，只要稳定发送心跳包，这个也是我们UDP开发常做的一个环节。）</small>

## 6. 应用层

### 6.0 应用层指引

+ 域名系统DNS（Domain Name System）
+ 动态主机配置协议DHCP
+ 文件传送协议FTP（File Transfer Protocol）
+ 远程终端协议TELNET
+ 远程桌面RDP
+ 万维网WWW（World Wide Web）
+ 电子邮件（SMTP、POP3、IMAP）

### 6.1 域名系统DNS

#### 6.1.1 DNS域名解析-概述

​	在我们实际访问网站时，并不直接在浏览器输入IP地址+端口port，而是使用域名+端口port*（如果是访问HTTP服务的话，默认80端口还不需要我们手动输入）*。

​	网络层我们知道并不存在域名这种东西，都是靠的IP地址来寻找路由器的，所以域名这种东西，必须在数据下达网络层之前被解析成IP地址。而DNS服务（应用层）就是专门做域名解析的（管理域名和域名、域名和IP之间的关系）。

​	我们访问`www.baidu.com`时，计算机就会先向DNS服务器请求解析`www.baidu.com`这个域名，毕竟要实际和网络上的主机通讯，不管怎么样网络层最终还是得依赖IP地址。等DNS服务器响应DNS解析结果后，我们再根据获得的IP地址访问到实际的web服务器站点。

#### 6.1.2 域名-概述

> [域名--百度百科]([https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062?fr=aladdin](https://baike.baidu.com/item/域名/86062?fr=aladdin))
>
> **域名**（英语：**Domain Name**），又称**网域**，是由一串用点分隔的名字组成的[Internet](https://baike.baidu.com/item/Internet)上某一台[计算机](https://baike.baidu.com/item/计算机/140338)或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。
>
> <small>由于[IP地址](https://baike.baidu.com/item/IP地址/150859)具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（[DNS](https://baike.baidu.com/item/DNS)，Domain Name System）来将域名和[IP地址](https://baike.baidu.com/item/IP地址)相互[映射](https://baike.baidu.com/item/映射/20402621)，使人更方便地访问[互联网](https://baike.baidu.com/item/互联网/199186)，而不用去记住能够被机器直接读取的[IP地址](https://baike.baidu.com/item/IP地址)数串。</small>
>
> [Domain name--wiki](https://en.wikipedia.org/wiki/Domain_name)

根域名：`.`

顶级域名：`com`、`cn`、`net`、`org`、`edu`、`gov` 等

二级域名：`baidu` 等（我们需要注册的就是到这个层级的，因为二级域名就已经是全球唯一的了。）

主机名：`www`、`mail `等

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/DNS_schema.svg/350px-DNS_schema.svg.png)

The domain name is a component of a [uniform resource locator](https://en.wikipedia.org/wiki/Uniform_resource_locator) (URL) used to access [web sites](https://en.wikipedia.org/wiki/Web_site), for example:

- URL: http://www.example.net/index.html
- Top-level domain: net
- Second-level domain: example
- Hostname: www

**A domain name may point to multiple [IP addresses](https://en.wikipedia.org/wiki/IP_addresses) to provide server redundancy for the services offered, a feature that  is used to manage the traffic of large, popular web sites.**

[Web hosting services](https://en.wikipedia.org/wiki/Web_hosting_services), on the other hand, run servers that are typically assigned only one or a few addresses while serving websites for many domains, a technique  referred to as [virtual web hosting](https://en.wikipedia.org/wiki/Virtual_web_hosting). Such IP address overloading requires that each request identifies the domain name being referenced, for instance by using the [HTTP request header field](https://en.wikipedia.org/wiki/HTTP_request_header_field) *Host:*, or [Server Name Indication](https://en.wikipedia.org/wiki/Server_Name_Indication).

> [根域名的知识](https://www.ruanyifeng.com/blog/2018/05/root-domain.html)
>
> [hosts--百度百科]([https://baike.baidu.com/item/hosts/10474546?fromtitle=Hosts%E6%96%87%E4%BB%B6&fromid=8971674&fr=aladdin](https://baike.baidu.com/item/hosts/10474546?fromtitle=Hosts文件&fromid=8971674&fr=aladdin))

#### 6.1.3 DNS域名解析工作流程

> [[第十九章、主機名稱控制者： DNS 伺服器](http://linux.vbird.org/linux_server/0350dns.php)]

​	windows通过cmd输入`nslookup`查看计算机所使用的域名解析服务器DNS，并且可以解析输入的域名。

*<small>（非权威应答，指的是你所使用的DNS服务器没有该域名对应的解析记录，该解析记录是从其他DNS服务器获取的。你的DNS服务器->根域名服务器->com域名服务器->获取域名解析记录并反馈给向自己请求的域名服务器。）</small>*

1. 域名解析测试

   ```shell
   ping www.baidu.com # 可以看到域名对应的IP
   nslookup www.baidu.com # 可以得知域名解析的结果--IP地址
   ```

2. 基本域名解析流程

   > [DNS原理总结及其解析过程详解](https://blog.csdn.net/yipiankongbai/article/details/25031461)
   
   ![img](https://img-blog.csdn.net/20140507124241312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlwaWFua29uZ2JhaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
   
   有两种方式：迭代查询、**递归查询**（现在一般都是这种，减少对网络带宽的占用）。
   
   1. **递归查询**：如果主机本地没有域名解析记录(hosts文件没有记录)，就向该主机配置的DNS服务器（一般就是ISP的DNS服务器）发出查询请求报文(一般是UDP+53端口，少数情况使用TCP+53)，如果ISP的DNS服务器没有所查域名的记录，其代替我们继续向根域名服务器发出查询请求，而根域名服务器再请求顶级域名服务器，顶级域名又继续代理请求二级域名服务器，最后查出域名对应的IP并回溯返回，中间经过的顶级域名服务器、根域名服务器、ISP服务器一般会把该查询结果缓存到本地，避免下次又要递归查询。最后告知我们域名解析结果的是我们的ISP的DNS服务器，因此递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。
   
   2. 迭代查询：当根域名服务器收到本地域名服务器（我们电脑配置的ISP的DNS服务器）发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，ISP的DNS服务器知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。


> [怎么使用Nslookup获取网站服务器信息](https://jingyan.baidu.com/article/fdbd4277aa07e5b89e3f480a.html)
>
> [域名解析a記錄中各符號(@、*、www)表示的..](http://www.worldxml.com/domain/o93004)
>
> [域名解析前面的前缀* @ www 分别代表什么！](https://zhidao.baidu.com/question/359103106.html)
>
> www 是指域名前带www的，以百度为例，就是 www.baidu.com
> @ 是指前面不带任何主机名的，以百度为例，就是 baidu.com
>
> 是指泛解析，是指除已添加的解析记录以外的所有主机都以此为准，以百度为例，就是 12343.baidu.com 但解析的时候并没有针对 12343。

#### 6.1.4 需要自建DNS服务器的场景举例

​	一般需要自建DNS服务器的场景有以下特点（或目的）：**局域网环境（或者说服务器不暴露给外界）**、**节省访问因特网的总上传带宽**。

1. 举例1（局域网环境、不对外暴露服务器）：

   ​	某学校内有多个机房搭建多台服务器，比如有校园邮箱服务器、文件FTP服务器等。这些服务器为防止被外界攻击，一般不对外公布（没有公网IP，也不在和因特网连接的路由器上做NAT、防火墙同样也不做NAT）。这时候在因特网的用户无法直接访问到学校机房的服务器，黑客只有在学校内网环境才能采取攻击。

   ​	学生连接校园网后，通过输入学校自建DNS服务器登记的域名解析条目，就可以访问到学校内的服务器。比如学校的DNS服务器设置某条记录为`jw.xuexiao.edu.cn ---> 10.91.196.112`，那么学生通过浏览器输入网址url `jw.xuexiao.edu.cn`就可以访问到自己学校的教务处主页了。（当然前提是连接了学校的校园网，或者用VPN与学校的远程访问服务器建立虚拟通道进而代理使用校园网范围的IP地址）。

2. 举例2（节省访问因特网的总上传带宽）：

   ​	同样是某学校环境，因为学校的上行带宽有限，虽然DNS请求的占用带宽不多，但是如果学校里成千上万人都时不时在连接校园网的情况下进行DNS请求，那么会占用学校大量的上行带宽（这对学校实验室、FTP服务器等是灾难）。况且许多学生DNS请求的都是相同的网站，如果重复请求，也浪费不少带宽。为避免这种情况，可以设置学校DHCP服务器为学生设置的DNS服务器为校内自建的DNS服务器，那么所有DNS请求统一由学校DNS服务器代理发送，只要下次有学生访问的域名在本地DNS服务器已经有缓存，就没必要重复请求了，直接返回缓存里的记录（这往往可以省下不少带宽，因为学生访问的域名一般八九不离十会命中DNS缓存）。

大型互联网公司、企业往往也会自建DNS服务器来访问内部的服务。

​	**自建的DNS服务器要注意，如果正向DNS解析配置了根`.`解析，那么所有DNS解析全靠该自建DNS服务器，不会再向因特网的根域名服务器进行递归查询**。（如果只是配置`com`顶级域名这一级别的解析，那么找不到本地记录，还是会访问因特网的根域名服务器进行递归查询。）

#### 6.1.5 常见的DNS记录类型

> [云解析DNS功能类FAQ](https://help.aliyun.com/knowledge_detail/39800.html?spm=5176.13910061.sslink.1.512b2b0dAt1W5D)
>
> [windows之DNS7种资源记录和flushdns命令清除DNS缓存以及nslookup解析域名和ipconfig/all命令查看网络配置使用总结](https://blog.csdn.net/u011068702/article/details/58240819)

- A记录 （可实现将域名指向 IP 地址）
- CNAME记录（可实现将域名指向另一个域名）
- MX记录（用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器）
- AAAA记录（可实现将域名指向 IPV6 地址）
- TXT记录（文本记录）
- NS记录（可实现把子域名交给其他 DNS 服务商提供解析服务）
- SRV记录（服务定位器）
- CAA记录（认证机构授权）

#### 6.1.6 DNS正向解析和反向解析

> [DNS的正向解析和反向解析](https://blog.csdn.net/yangkaiorange/article/details/81507023)
>
> [查询单个域名的 DNS 信息](https://www.cnblogs.com/sparkdev/p/7777871.html)
>
> [云解析DNS功能类FAQ](https://help.aliyun.com/knowledge_detail/39800.html?spm=5176.13910061.sslink.1.512b2b0dAt1W5D)
>
> 如果是用的云服务的域名解析服务，那么一般不支持反向解析PTR（这个需要上层网络提供商ISP才有权限，不然网络乱套）

*<small>下文文字部分主要摘自上面引用的[DNS的正向解析和反向解析](https://blog.csdn.net/yangkaiorange/article/details/81507023)，总结挺好的，只改动部分文字。</small>*

​	DNS（Domain Name System,域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，使用户能更方便地访问互联网，而不用记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫域名解析。DNS服务使用端口号：53。

域名解析中的记录类型(常见几种)：
A:直接解析到空间IP地址（主机-->IP）
CNAME:解析到别名（域名-->域名）
MX:电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器，是设置企业邮箱的（域名-->IP）
NS:指DNS,用默认的就行，一般不用修改（一般就是根域名服务器）
TXT:一般指为某个主机名或域名设置的说明，是企业邮箱的辅助设置。

TTL值：Time To Live生存时间：DNS记录在DNS服务器上缓存的时间。

**正向解析&反向解析**：
	DNS服务器里面有两个区域，即“**正向查找区域**”和“**反向查找区域**”，正向查找区域就是通常所说的域名解析，**反向查找区域即是IP反向解析，它得到作用是通过查找IP地址的PTR记录来得到该IP地址指向的域名**。要成功得到域名就必须有该IP地址的PTR记录。PTR记录是邮件交换记录的一种，邮件交换记录中有A记录和PTR记录，A记录解析名字到地址，PTR记录解析地址到名字。

​	反向域名解析系统（Reverse DNS）的功能确保适当的邮件交换记录是生效的。反向域名解析与通常的正向域名解析下相反，提供IP
地址到域名的对应。**IP反向解析主要应用到邮件服务器中来阻拦垃圾邮件。多数垃圾邮件发送者使用动态分配或者没有注册域名的IP地址来发送垃圾邮件，以避免追踪，使用域名反向解析后，就可以大大降低垃圾邮件的数量。**

​	*比如用xxx@name.com这个邮箱给kasum@lwork.com发一封信，lwork邮件服务器接到这封信会查看这封信的信头文件，这封信的信头文件会显示这封信是由哪个IP地址发出来的。然后根据这个IP地址进行反向解析，如果反向解析到这个IP对应的域名是name.com就接收这封邮件，如果反向解析这个IP没有对应到name.com，那么就拒绝这封邮件。*
​	*由于在域名系统中，一个IP地址可以对应多个域名，因此从IP出发去找域名，理论上应该遍历整个域名树，但是这在internet上是不现实的。为了完成逆向域名解析，系统提供一个特别域，该特别域称为逆向解析域in-addr.arpa.这样欲解析的IP地址就会被表达城一种像域名一样的可显示串形式，后缀以逆向解析域域名“in-addr.arpa”结尾。*

> [linux下安装使用dig命令](https://www.cmsky.com/linux-dig/)
>
> [ 19.4.2 反解檔記錄的 RR 資料](http://linux.vbird.org/linux_server/0350dns.php#fig19.1-4)
>
> [查询单个域名的 DNS 信息](https://www.cnblogs.com/sparkdev/p/7777871.html)
>
> [DNS服务反向解析实验](https://www.cnblogs.com/swl0221/p/11821467.html)
>
> [使用dig查询DNS解析过程](https://www.cnblogs.com/lovezbs/p/13702674.html)
>
> [通过一次完整DNS从根域解析至主机的过程学习](https://blog.csdn.net/firehadoop/article/details/83863430)
>
> [为什么输入百度的IP地址不能直接访问](https://blog.csdn.net/weixin_45433623/article/details/106238151)
>
> [HTTPS 深入浅出 - 什么是 SNI？](https://blog.csdn.net/firefile/article/details/80532161)

```shell
# 使用dig，跟踪正向解析
[root@test ~]# dig +trace  www.queueandmessage.top

; <<>> DiG 9.11.4-P2-RedHat-9.11.4-16.P2.el7_8.6 <<>> +trace www.queueandmessage.top
;; global options: +cmd
.			422092	IN	NS	j.root-servers.net.
.			422092	IN	NS	g.root-servers.net.
.			422092	IN	NS	c.root-servers.net.
.			422092	IN	NS	d.root-servers.net.
.			422092	IN	NS	f.root-servers.net.
.			422092	IN	NS	k.root-servers.net.
.			422092	IN	NS	a.root-servers.net.
###### 省略部分内容
;; Received 525 bytes from 100.100.2.136#53(100.100.2.136) in 0 ms

top.			172800	IN	NS	a.zdnscloud.com.
top.			172800	IN	NS	b.zdnscloud.com.
top.			172800	IN	NS	c.zdnscloud.com.
top.			172800	IN	NS	d.zdnscloud.com.
top.			172800	IN	NS	f.zdnscloud.com.
###### 省略部分内容
couldn't get address for 'j.zdnscloud.com': not found
;; Received 680 bytes from 193.0.14.129#53(k.root-servers.net) in 30 ms

queueandmessage.top.	3600	IN	NS	dns22.hichina.com.
queueandmessage.top.	3600	IN	NS	dns21.hichina.com.
###### 省略部分内容
;; Received 348 bytes from 203.99.27.1#53(d.zdnscloud.com) in 36 ms

www.queueandmessage.top. 600	IN	A	106.15.200.177
;; Received 68 bytes from 106.11.141.128#53(dns22.hichina.com) in 27 ms
```

```shell
# 使用dig，反向解析(上面正向解析 www.queueandmessage.top 得到 106.11.141.128)
# 下面得出的结果 100.100.2.136 是 云服务商的DNS服务器
[root@test ~]# dig -x 106.11.141.128

; <<>> DiG 9.11.4-P2-RedHat-9.11.4-16.P2.el7_8.6 <<>> -x 106.11.141.128
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NXDOMAIN, id: 63867
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;128.141.11.106.in-addr.arpa.	IN	PTR

;; AUTHORITY SECTION:
11.106.in-addr.arpa.	300	IN	SOA	rdns1.alidns.com. dnsmgr.alibaba-inc.com. 2015013478 1800 600 1814400 300

;; Query time: 6 msec
;; SERVER: 100.100.2.136#53(100.100.2.136)
;; WHEN: Sat Jul 18 17:25:15 CST 2020
;; MSG SIZE  rcvd: 127


[root@test ~]# dig -x 8.8.8.8 +short
dns.google.

```

### 6.2 DHCP(动态主机配置协议)

#### 6.2.1 DHCP概述

>[DHCP--百度百科](https://baike.baidu.com/item/DHCP)
>
>DHCP（动态主机配置协议）是一个**局域网的网络协议**。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为Windows Server的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。
>
>[CISCO DHCP全攻略详解](https://www.cnblogs.com/qzqdy/p/11463278.html)

#### 6.2.2 客户端获取DHCP配置流程

> [DHCP--百度百科](https://baike.baidu.com/item/DHCP)

​	DHCP协议采用UDP作为传输协议，主机发送请求消息到DHCP服务器的67号端口，DHCP服务器回应应答消息给主机的68号端口。详细的交互过程如下图。 

![](https://bkimg.cdn.bcebos.com/pic/5ab5c9ea15ce36d3d5e5e08939f33a87e850b1a1?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

工作流程如下：

1. DHCP Client以**广播**的方式发出DHCP Discover报文。 

2. 所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。 

   DHCP Offer报文中“Your(ent) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。**DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。** 

3. **DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文**。 

   DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。 （这样别的DHCP Server就知道本来想分配给该DHCP Client没被采用，可以回收继续给别人用。）

4. DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，**并在选项字段中增加IP地址的使用租期信息**。 （IP地址肯定是要有期限的，不然你电脑要是换地方了，那IP不就归你了。）

5. DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期**自动启动续延过程**；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCP Server发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。 

6. DHCP Client在成功获取IP地址后，**随时可以通过发送DHCP Release报文释放自己的IP地址**，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。 

7. 在**使用租期超过50%时刻**处，DHCP Client会以单播形式向DHCP Server发送DHCP Request报文来**续租IP地址**。<u>如果DHCP Client成功收到DHCP Server发送的DHCP ACK报文，则按相应时间延长IP地址租期</u>；如果没有收到DHCP Server发送的DHCP ACK报文，则DHCP Client继续使用这个IP地址。 

8. 在**使用租期超过87.5%时刻**处，DHCP Client会以广播形式向DHCP Server发送DHCP Request报文来**续租IP地址**。<u>如果DHCP Client成功收到DHCP Server发送的DHCP ACK报文，则按相应时间延长IP地址租期</u>；如果没有收到DHCP Server发送的DHCP ACK报文，则DHCP Client继续使用这个IP地址，**直到IP地址使用租期到期时，DHCP Client才会向DHCP Server发送DHCP Release报文来释放这个IP地址，并开始新的IP地址申请过程。** 

9. 需要说明的是：<u>DHCP客户端可以接收到多个DHCP服务器的DHCP OFFER数据包，然后可能接受任何一个DHCP OFFER数据包，但**客户端通常只接受收到的第一个DHCP OFFER数据包**。另外，**DHCP服务器DHCP OFFER中指定的地址不一定为最终分配的地址，通常情况下，DHCP服务器会保留该地址直到客户端发出正式请求**</u>。 

10. 正式请求DHCP服务器分配地址DHCP REQUEST采用广播包，是为了让其它所有发送DHCP OFFER数据包的DHCP服务器也能够接收到该数据包，然后**释放已经OFFER（预分配）给客户端的IP地址**。 

11. **如果发送给DHCP客户端的地址已经被其他DHCP客户端使用，客户端会向服务器发送DHCP DECLINE信息包拒绝接受已经分配的地址信息**。 

12. 在协商过程中，如果DHCP客户端发送的REQUEST消息中的地址信息不正确，如客户端已经迁移到新的子网或者租约已经过期，
13. DHCP服务器会发送DHCP NAK消息给DHCP客户端，让客户端重新发起地址请求过程。

---

注1：**DHCP请求也可以跨网段进行**。需要在跨越网段的路由器接口上进行特殊配置（因为**路由器会直接丢弃广播包**），让路由器接收到DHCP请求后修改IP数据报的源IP地址和目的IP地址，代发DHCP请求单播给DHCP服务器（`ip helper-address DHCP服务器IP地址`），而**DHCP服务器也会根据源IP地址网段范围回应DHCP响应包，之后再由路由器转发给原本发起DHCP请求的主机（根据MAC地址）**。

注2：同一网段下，主机发起DHCP请求时，如果源地址是`0.0.0.0`，即第一次发送DHCP请求时（主机还没有IP地址），DHCP服务器会直接以自己的网段为标准（因为能收到广播请求包，DHCP服务器就认为该主机和自己在同一个网段）从众多`dhcp pool`中选出和自己网段相符的一个，然后从里面挑选IP，响应给请求者。

注3：DHCP服务会尽可能地给同一个主机分配相同的IP。（比如我主机租约192.168.1.109，然后一周不开电脑，重新打开后，DHCP服务趋向于给我再次分配192.168.1.109，除非该IP地址已经被占用）。

注4：发起DHCP-Request的主机接收到DHCP服务器的DHCP-ACK后，会发送免费ARP报文（广播），如果收到ARP回应，主机认为该IP已经被其他用户占用，会再发送DHCP-DECLINE给DHCP服务器 ，让它重新给自己再分配一个IP地址。（如果有人估计针对该过程，故意回应，就可以导致该主机无法正常获得DHCP服务分配的IP地址）。

注5：如果DHCP服务器正常，却获取不到来自DHCP服务器的配置，那么可能是本地的DHCP client服务没有启动（那么就没法和DHCP服务器交互）。

注6：DHCP服务器想给几个网段分配IP地址，就需要配置几个作用域`dhcp pool`，每个对应一个网段。

注7：**DHCP服务器必须设置静态IP地址**，因为它收到广播的DHCP请求包，会根据自己的网段来判断从哪个`dhcp pool`取IP来分配给客户端。（这里广播包源地址`0.0.0.0`，目的地址`255.255.255.255`）。

**第一次请求IP地址，相当于RARP（已知MAC，需要知道对应的IP地址）,抓包也都是显示ARP**

> [ARP、DNS、DHCP攻击方式](https://blog.csdn.net/qq_18754715/article/details/106444998)
>
> [DHCP的IP地址分配与获取过程](http://www.elecfans.com/d/1145565.html)
>
> [如果设置成静态IP，dhcp还会把这个地址分配给别人吗](https://zhidao.baidu.com/question/1639156844166646020.html?qbl=relate_question_4&word=DHCP%BF%CD%BB%A7%B6%CB%D4%F5%C3%B4%D6%AA%B5%C0ip%D2%D1%BE%AD%B1%BB%C6%E4%CB%FB%C8%CB%D5%BC%D3%C3)

### 6.3 FTP文件传输协议

#### 6.3.1 FTP概述

> [FTP(文件传输协议)--百度百科](https://baike.baidu.com/item/ftp/13839)
>
> 文件传输协议（File Transfer Protocol，FTP）是用于在[网络](https://baike.baidu.com/item/网络)上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。
>
> FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。

**Real帐户**

这类用户是指在FTP服务上拥有帐号。当这类用户登录FTP服务器的时候，其默认的主目录就是其帐号命名的目录。但是，其还可以变更到其他目录中去。如系统的主目录等等。

**Guest用户**

在FTP服务器中，我们往往会给不同的部门或者某个特定的用户设置一个帐户。但是，这个账户有个特点，就是其只能够访问自己的主目录。服务器通过这种方式来保障FTP服务上其他文件的安全性。这类帐户，在Vsftpd[软件](https://baike.baidu.com/item/软件)中就叫做Guest用户。拥有这类用户的帐户，只能够访问其主目录下的目录，而不得访问主目录以外的文件。

**Anonymous用户**

这也是我们通常所说的匿名访问。这类用户是指在FTP服务器中没有指定帐户，但是其仍然可以进行匿名访问某些公开的资源。

在组建FTP服务器的时候，我们就需要根据用户的类型，对用户进行归类。默认情况下，Vsftpd服务器会把建立的所有帐户都归属为Real用户。但是，这往往不符合企业安全的需要。因为这类用户不仅可以访问自己的主目录，而且，还可以访问其他用户的目录。这就给其他用户所在的空间带来一定的安全隐患。所以，企业要根据实际情况，修改用户所在的类别。

#### 6.3.2 FTP工作机制

> [FTP两种工作模式介绍](https://blog.csdn.net/qq100440110/article/details/51058444)

![](https://bkimg.cdn.bcebos.com/pic/dc54564e9258d1091af37250df58ccbf6d814dc4?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

​	FTP服务需要至少建立两个TCP连接，其中一个用于客户端与FTP服务器端的控制进程建立**TCP控制连接**（指示要进行的操作，比如复制、删除、修改文件等），另一个用于客户端与服务器端的数据传输进程建立**TCP数据连接**（真正用于传输文件数据的连接）。

​	FTP的工作模式有两种：Standard （PORT方式，**主动**方式），Passive （PASV，**被动**方式）。

1. FTP连接的方式：
   + 控制连接：标准端口为21，用于发送FTP命令信息。
   + 数据连接：标准端口为20，用于上传、下载数据。
   + 数据连接的建立类型：
     + 主动模式：服务端从20端口主动向客户端发起连接。
     + 被动模式：服务端在指定范围内的某个端口被动等待客户端发起连接。
2. FTP传输模式：
   + 文本模式：ASCII模式，以文本序列传输数据。
   + 二进制模式：Binary模式，以二进制序列传输数据。

**FTP采用主动模式还是被动模式，是由FTP客户端设置的**。（当然FTP服务器如果只为FTP服务开放20和21，那客户端其实也没得选）

​	*一般服务端和客户端都设有防火墙，为方便建立FTP数据连接，可以考虑FTP服务采用主动模式，服务器端只为FTP开放固定的20和21端口。*

> [请高手介绍一下ftp的主动连接和被动连接](https://zhidao.baidu.com/question/6063604.html)
> Port模式：ftp server:tcp 21 <------client:dynamicftp server:tcp 20 ------>client:dynamic 
>
> Pasv模式：ftp server:tcp 21 <----client:dynamicftp server:tcp dynamic <----client:dynamic 
>
> PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用PORT命令告诉服务器：“我打开了XXXX端口，你过来连接我”。于是服务器从20端口向客户端的XXXX端口发送连接请求，建立一条数据链路来传送数据。 
>
> PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用PASV命令告诉客户端：“我打开了XXXX端口，你过来连接我”。于是客户端向服务器的XXXX端口发送连接请求，建立一条数据链路来传送数据。 

### 6.4 TELNET远程终端协议

#### 6.4.1 TELNET概述

> [Telnet--百度百科](https://baike.baidu.com/item/Telnet/810597?fr=aladdin)
>
> Telnet协议是[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP协议)族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程[主机](https://baike.baidu.com/item/主机/455151)工作的能力。在[终端](https://baike.baidu.com/item/终端/1903878)使用者的电脑上使用telnet程序，用它连接到[服务器](https://baike.baidu.com/item/服务器/100571)。[终端](https://baike.baidu.com/item/终端/1903878)使用者可以在telnet程序中输入命令，这些命令会在[服务器](https://baike.baidu.com/item/服务器/100571)上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制[服务器](https://baike.baidu.com/item/服务器/100571)。要开始一个telnet会话，必须输入用户名和密码来登录[服务器](https://baike.baidu.com/item/服务器/100571)。Telnet是常用的[远程控制](https://baike.baidu.com/item/远程控制/934368)Web[服务器](https://baike.baidu.com/item/服务器)的方法。

![](https://bkimg.cdn.bcebos.com/pic/a08b87d6277f9e2fc0ef662c1d30e924b899f338?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U3Mg==,g_7,xp_5,yp_5)

Telnet = TCP + 23端口。

#### 6.4.2 使用TELNET

​	Telnet是Internet远程登录服务的标准协议和主要方式，最初由ARPANET开发，现在主要用于Internet会话，它的基本功能是允许用户登录进入远程主机系统。

举例：

1. 使用telnet配置路由器（由于早期路由器的配置界面没有现在这么方便的GUI，只有命令行）
2. 使用telnet测试远程服务器是否有打开某端口。（对应的端口没有打开，则会明确提示连接失败）

​	虽然Telnet较为简单实用也很方便，但是**在格外注重安全的现代网络技术中，Telnet并不被重用**。原因在于Telnet是一个**明文传送**协议，它将用户的所有内容，包括用户名和密码都明文在互联网上传送，具有一定的安全隐患，因此许多服务器都会选择禁用Telnet服务。如果我们要使用Telnet的远程登录，使用前应在远端服务器上检查并设置允许Telnet服务的功能。

​	**现在基本都用ssh代替telnet实现远程登录**。

> [ssh(安全外壳协议)--百度百科](https://baike.baidu.com/item/SSH/10407)
>
> 从客户端来看，SSH提供两种级别的安全验证。
>
> **第一种级别（基于口令的安全验证）**
>
> 只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的[服务器](https://baike.baidu.com/item/服务器)。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。
>
> **第二种级别（基于密匙的安全验证）**
>
> 需要依靠[密匙](https://baike.baidu.com/item/密匙)，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。
>
> 用这种方式，你必须知道自己密匙的[口令](https://baike.baidu.com/item/口令)。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。
>
> 第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒

### 6.5 RDP远程桌面

#### 6.5.1 RDP概述

> [RDP远程桌面协议--百度百科]([https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8D%8F%E8%AE%AE/9978980?fromtitle=RDP&fromid=2986499](https://baike.baidu.com/item/远程桌面协议/9978980?fromtitle=RDP&fromid=2986499))

​	远程桌面协议(RDP)是一个多通道(multi-channel)的协议，让使用者(所在计算机称为用户端或'本地计算机')连上提供微软[终端机](https://baike.baidu.com/item/终端机/7163369)服务的计算机(称为服务端或'远程计算机')。

​	大部分的Windows版本都有用户端所需软件，有些其他操作系统也有这些用户端软件，例如[Linux](https://baike.baidu.com/item/Linux/27050),FreeBSD，MacOSX，服务端计算机方面，则听取送到TCPport3389的数据。

​	[远程桌面](https://baike.baidu.com/item/远程桌面/6757521)是方便windows服务器管理员对服务器进行基于图形界面的远程管理.远程桌面是基于[RDP](https://baike.baidu.com/item/RDP)(RemoteDesktopProtocol远程桌面协议)的。

注：用户至少需要在"远程桌面用户组（Remote Desktop Users）"，才能使用远程桌面连接。

### 6.6 HTTP协议

#### 6.6.1 HTTP概述

> [http--百度百科](https://baike.baidu.com/item/http)
>
> http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。

HTTP = TCP + 80端口

URL的一般形式：`<协议>://<主机>:<端口>/<路径>`

这玩意大家平时开发用得够多了，之前收藏的文章也够多了，就不再细写了。

#### 6.6.2 HTTP常用请求方式

> [http 请求包含哪几个部分（请求行、请求头、请求体）](https://www.cnblogs.com/qiang07/p/9304771.html)
>
> [HTTP请求的常用方法有哪些](https://www.php.cn/website-design-ask-413913.html)
>
> [用户访问网站的完整流程](https://www.cnblogs.com/yihr/p/9720715.html)

1. GET方法

   GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。

   GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。

   注：因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求。

2. POST方法

   POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。

   POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。

3. HEAD方法

   HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。

4. PUT方法

   PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。

   它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。

5. DELETE方法

   DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。

6. CONNECT方法

   CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。

7. OPTIONS方法

   OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。

8. TRACE方法

   TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。

#### 6.6.3 HTTP1.0/1.1/2.0

> [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)	=>	下面内容复制的是"[Leo Zhang](https://www.zhihu.com/people/leozhang2018)"该用户的回答，推荐阅读原文

HTTP 2.0 的出现，相比于 HTTP 1.x ，大幅度的提升了 web 性能。在与 HTTP/1.1 完全语义兼容的基础上，进一步减少了网络延迟。而对于前端开发人员来说，无疑减少了在前端方面的优化工作。本文将对 HTTP 2.0 协议 个基本技术点进行总结，联系相关知识，探索 HTTP 2.0 是如何提高性能的。


**初露锋芒**

[HTTP/2: the Future of the Internet](https://link.zhihu.com/?target=https%3A//http2.akamai.com/demo) 这是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。

![img](https://pic4.zhimg.com/80/a8c500242cca3edb042b194d90763658_1440w.jpg?source=1940ef5c)



此时如果我们打开 Chrome Developer Tools 查看 Network 一栏可以发现，HTTP/2 在网络请求方面与 HTTP /1.1的明显区别。


HTTP/1:

![img](https://pic4.zhimg.com/80/da14f0743605dfd3162b709adbb601b4_1440w.jpg?source=1940ef5c)



HTTP/2:

![img](https://pic2.zhimg.com/80/cf8b9bbee7dc03970829ef722be61492_1440w.jpg?source=1940ef5c)


**多路复用 (Multiplexing)**

**多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。**

众所周知 ，在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。



> Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.

来源：RFC-2616-8.1.4 Practical Considerations
[HTTP/1.1: Connections](https://link.zhihu.com/?target=http%3A//www.w3.org/Protocols/rfc2616/rfc2616-sec8.html%23sec8.1.4)

该图总结了不同浏览器对该限制的数目。

![img](https://pic4.zhimg.com/80/faedeb3dae59455f6520d6a5dbf436e5_1440w.jpg?source=1940ef5c)

来源:
[Roundup on Parallel Connections](https://link.zhihu.com/?target=http%3A//www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/)
这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，[http://twimg.com](https://link.zhihu.com/?target=http%3A//twimg.com/)，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。
而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的**请求-响应**消息。

![img](https://pic2.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_1440w.jpg?source=1940ef5c)

因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上**双向交换**消息。


**二进制分帧**
在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段….. 的情况下, HTTP/2 是如何做到「突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量」的 ?
关键之一就是在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。



![img](https://pic1.zhimg.com/80/906e22193e61cd561325d93aae0f1e07_1440w.jpg?source=1940ef5c)

在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。
	**HTTP/2 通信都在一个连接上完成**，这个连接可以承载**<u>任意数量</u>**的双向数据流。
在过去， HTTP 性能优化的**关键并不在于高带宽**，而是**低延迟**。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。
	HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

总结：

- **单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大**
- **由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快**

![img](https://pic4.zhimg.com/80/ae5418b7da1c6593fd6addad0310faa5_1440w.jpg?source=1940ef5c)

**首部压缩（Header Compression）**
HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的[DEFLATE](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/DEFLATE) 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 [HPACK](https://link.zhihu.com/?target=http%3A//http2.github.io/http2-spec/compression.html) 算法。

![img](https://pic2.zhimg.com/80/c41c386f03b41f149a53fb17f520dd8d_1440w.jpg?source=1940ef5c)


**服务端推送（Server Push）**

服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，**服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。**

![img](https://pic1.zhimg.com/80/d9f07162d5391641b7a2645a61b24fc0_1440w.jpg?source=1940ef5c)



**关于 HTTP/2 的 Server Push 以及** **HTTP/2 的缓存策略**
典型问题:
**「如果客户端早已在缓存中有了一份 copy 怎么办？」还要 Push 吗?**
详情参考另一个答案:
[HTTP/2 对现在的网页访问，有什么大的优化呢？体现在什么地方](https://www.zhihu.com/question/24774343/answer/96586977)

> **PS:**
> 强烈推荐阅读 Mark Nottingham 在 **Velocity Beijing 2015** 的 speech
> **HTTP/2 for Front-End Developers** ,关于 HTTP/2 下的前端性能优化相关。
> Slide 地址：[HTTP/2 for Front-End Developers](https://link.zhihu.com/?target=https%3A//www.mnot.net/talks/h2fe/)
>
> 参考资料:
>
> - Gitbook 《HTTP2 讲解》 by Calvin Zhang and Simon Xia：[http2讲解 - GitBook](https://link.zhihu.com/?target=https%3A//www.gitbook.com/book/ye11ow/http2-explained/details)
>
> - HTTPS、SPDY 以及 HTTP/2 性能简单对比：[A Simple Performance Comparison of HTTPS, SPDY and HTTP/2](https://link.zhihu.com/?target=http%3A//blog.httpwatch.com/2015/01/16/a-simple-performance-comparison-of-https-spdy-and-http2/)
>
> - HTTP/2 的压缩算法--HPACK（RFC7541）：[HPACK: Header Compression for HTTP/2](https://link.zhihu.com/?target=https%3A//httpwg.github.io/specs/rfc7541.html)
>
> - NGINX HTTP/2 白皮书：[https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf](https://link.zhihu.com/?target=https%3A//www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf)
>
> - NGINX Blog--提升 HTTP/2 性能的 7个小建议：
>
> - - [7 Tips for Faster HTTP/2 Performance](https://link.zhihu.com/?target=https%3A//www.nginx.com/blog/7-tips-for-faster-http2-performance/)（原文）
>   - [[译\]使用HTTP/2提升性能的7个建议](https://link.zhihu.com/?target=http%3A//www.w3ctech.com/topic/1563%23tip7sharding)（李松峰译）
>
> - [HTTP/2 for a Faster Web](https://link.zhihu.com/?target=https%3A//cascadingmedia.com/insites/2015/03/http-2.html)
>
> - O'Reilly *HTTP2-high-perf-browser-networking：*[http://www.oreilly.com/webops-perf/free/files/HTTP2-high-perf-browser-networking.pdf](https://link.zhihu.com/?target=http%3A//www.oreilly.com/webops-perf/free/files/HTTP2-high-perf-browser-networking.pdf)
>
> - HTTP/2 新特性浅析：[HTTP/2 新特性浅析](https://link.zhihu.com/?target=http%3A//io.upyun.com/2015/05/13/http2/)
>
> - Kevin blog 关于 HTTP/2 的系列归档：[HTTP/2 | 凯文叔叔的网志](https://link.zhihu.com/?target=http%3A//www.unclekevin.org/%3Fcat%3D15)
>
> - Can i use 上关于支持HTTP/2 的浏览器：[Can I use... Support tables for HTML5, CSS3, etc](https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dhttp2)

#### 6.6.4 CORS

> [Deep dive in CORS: History, how it works, and best practices](https://ieftimov.com/post/deep-dive-cors-history-how-it-works-best-practices/)	<=	下面内容根据该文章进行简要叙述。原文章通俗易懂，有很多有趣的图片，建议阅读原文。

1. **子资源请求跨域**

   文中举例`<img>`标签，需要注意图片加载的请求路径在同域环境进行，否则为**cross-origin request**。

2. **同源和跨域**

   + 典型举例：HTTP和HTTPS，两者**协议不同**，且**端口不同**（HTTP：80，HTTPS：443）。

   + **"协议"（scheme）、"主机名"（host）、"端口"（post），三者中任意一个不同，即跨域**。

   + As an exercise if we run a comparison of the `https://blog.example.com/posts/foo.html` origin against other origins, we would get the following results:

     | URL                                            | Result    | Reason                                             |
     | ---------------------------------------------- | --------- | -------------------------------------------------- |
     | `https://blog.example.com/posts/bar.html`      | Same      | Only the path differs                              |
     | `https://blog.example.com/contact.html`        | Same      | Only the path differs                              |
     | `http://blog.example.com/posts/bar.html`       | Different | Different protocol                                 |
     | `https://blog.example.com:8080/posts/bar.html` | Different | Different port (`https://` is port 443 by default) |
     | `https://example.com/posts/bar.html`           | Different | Different host                                     |

     > A cross-origin request means, for example, a resource (i.e. page) such as `http://example.com/posts/bar.html` that would try to render a subresource from the `https://example.com` origin (note the scheme change!).

3. **危险的跨域请求**

   与前面提到的`<img>`标签类似的，还有`<script>`, `<frame>`, `<video>`,` <audio>`, `<iframe>`, `<link>`, `<form>`等。这些子资源在浏览器加载页面时发起请求，这些请求可能就是跨域请求。

   假设没有CORS，用户可以进行任何跨域请求。那么黑客可以通过CSRF攻击，恶意访问游客本地cookie，并且利用游客的本地cookie对游客进行攻击*（比如游客刚访问完网上银行，浏览器保存银行cookie，结果游客访问黑客网站时，被窃取该银行cookie，随后黑客利用该cookie假冒游客，对其银行账户进行操作）*

4. **同源政策**

   同源政策（Same-origin policy），CORS的前身。该政策同样支持前文提及的请求子资源的标签`<img>`等。

   Even though same-origin policy implementations are not required to follow an exact specification, all modern browsers implement some form of it. The principles of the policy are described in [RFC6454](https://tools.ietf.org/html/rfc6454) of the Internet Engineering Task Force (IETF).

   The implementation of the same-origin policy is defined with this ruleset:

   | Tags                  | Cross-origin        | Note                                                         |
   | --------------------- | ------------------- | ------------------------------------------------------------ |
   | `<iframe>`            | Embedding permitted | Depends on `X-Frame-Options`                                 |
   | `<link>`              | Embedding permitted | Proper `Content-Type` might be required                      |
   | `<form>`              | Writing permitted   | Cross-origin writes are common                               |
   | `<img>`               | Embedding permitted | Cross-origin reading via JavaScript and loading it in a `<canvas>` is forbidden |
   | `<audio>` / `<video>` | Embedding permitted |                                                              |
   | `<script>`            | Embedding permitted | Access to certain APIs might be forbidden                    |

   同源政策限制较多，不适用于现在的开发需求。

   CORS目标即放宽同源政策的限度，允许一部分跨域请求。

5. **CORS**

   Now it’s time to familiarize ourselves with Cross Origin Resource Sharing (CORS). CORS is a mechanism that allows control of access to subresources on a web page over a network. The mechanism classifies three different categories of subresource access:

   1. Cross-origin writes
   2. Cross-origin embeds
   3. Cross-origin reads

   需要注意的是，即使浏览器允许一部分类别的跨域请求，但是这些请求并不一定被服务器接受。（即浏览器和服务器对跨域请求的接受限度不同，很可能浏览器发出了跨域请求，但是被服务器拒绝）

   **Cross-origin writes** are links, redirects, and form submissions. With CORS active in your browser, these are all **allowed**. There is also a thing called **preflight request** that fine-tunes cross-origin writes, so while some writes might be permitted by default it doesn’t mean they can go through in practice. We’ll look into that a bit later.

   **Cross-origin embeds** are subresources loaded via: `<script>`, `<link>`, `<img>`, `<video>`, `<audio>`, `<object>`, `<embed>`, `<iframe>` and more. These are all **allowed** by default. `<iframe>` is a special one – as it’s purpose is to literally load a different page inside the frame, its cross-origin framing can be controlled by using the `X-Frame-options` header.

   When it comes to `<img>` and the other embeddable subresources – it’s in their nature to trigger cross-origin requests. That’s why in CORS differentiates between cross-origin embeds and cross-origin reads, and treats them differently.

   **Cross-origin reads** are subresources loaded via AJAX / `fetch` calls. These are by default **blocked** in your browser. There’s the workaround of embedding such subresources in a page, but such tricks are handled by another policy present in modern browsers.

   If your browser is up to date, all of these heuristics are already implemented in it.

....(更多内容，直接阅读原文吧，原文还是很好懂的。)

....(更多内容，直接阅读原文吧，原文还是很好懂的。)

....(更多内容，直接阅读原文吧，原文还是很好懂的。)

**最主要的就是需要注意，CORS涉及浏览器对请求、响应的拦截，同时也需要在服务器设置开放符合某一类规则的跨域请求。**

该博客原文提到的其他关键点（下面描述不一定精准，最好阅读原文）：

+ **复杂请求（哪些属于复杂请求complex request）**

  + A request that uses methods other than `GET`, `POST`, or `HEAD`
  + A request that includes headers other than `Accept`, `Accept-Language` or `Content-Language`
  + A request that has a `Content-Type` header value other than `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`

+ **Preflight requests（现代浏览器在发起复杂请求时，会先发送Preflight requests）**

  常见的Preflight requests就是`OPTIONS`请求

+ **浏览器拦截跨域请求的场景**

  + 解决：需要服务器设置允许跨域的规则（同时，浏览器发起的请求要符合服务器允许的跨域规则）

  *注意：浏览器只拦截符合"复杂请求"的跨域请求，非复杂请求，即使跨域也不拦截！*

+ **浏览器拦截跨域响应的场景**

  + 解决：需要服务器在响应中设置headers，设置允许跨域的源`Access-Control-Allow-Origin`

  *注意：浏览器放行请求，但是拦截响应时，状态码也会是200！*

+ **服务器设置允许跨域的规则**

  - `Access-Control-Allow-Methods` – it indicates which methods are supported by the response’s URL for the purposes of the CORS protocol.
  - `Access-Control-Allow-Headers` - it indicates which headers are supported by the response’s URL for the purposes of the CORS protocol.
  - `Access-Control-Max-Age` - it indicates the number of seconds (5 by default) the information provided by the `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` headers can be cached.

+ `Access-Control-Allow-Credentials`

  Another way to fine-tune CORS on our website is to use the `Access-Control-Allow-Credentials` response header. `Access-Control-Allow-Credentials` instructs browsers whether to expose the response to the frontend JavaScript code when the request’s credetials mode is `include`.

  The request’s credentials mode comes from the introduction of [the Fetch API](https://fetch.spec.whatwg.org/), which has its roots back the original `XMLHttpRequest` objects:

  ```javascript
  var client = new XMLHttpRequest()
  client.open("GET", "./")
  client.withCredentials = true
  ```

  With the introduction of `fetch`, the `withCredentials` option was transformed into an optional argument to the `fetch` call:

  ```javascript
  fetch("./", { credentials: "include" }).then(/* ... */)
  ```

  The available options for the `credentials` options are `omit`, `same-origin` and `include`. The different modes are available so developers can fine-tune the outbound request, whereas the response from the server will inform the browser how to behave when credentials are sent with the request (via the `Access-Control-Allow-Credentials` header).

  The Fetch API spec contains a well-written and thorough [breakdown](https://fetch.spec.whatwg.org/#cors-protocol-and-credentials) of the interplay of CORS and the `fetch` Web API, and the security mechanisms put in place by browsers.

+ CORS设置

  1. 允许所有源的请求`Access-Control-Allow-Origin: *`

     + 当服务无需认证、授权
     + 资源需要被大范围用户使用（且没有严格限定的要求）
     + 不清楚什么类型的源、用户会访问服务资源，或者你并不在意谁访问了

     这种情况下，小心黑客利用游客网络进行攻击。比如游客在公司VPN网络下浏览黑客网站，结果在黑客网站中加载了公司资源。（这样子黑客网站就窃取到公司机密了。当然前提是公司资源允许黑客网站的跨域请求）

  2. 仅允许来自指定源的请求

     文章举例子，前端js脚本定期发送用户数据到服务器API，此时我们只对同源的请求感兴趣，其他网站发送过来的用户数据，我们并不关心。

  3. `Access-Control-Allow-Origin`设置为`null`

     当请求来自本地静态文件时，Origin为null。如果明确请求都来自本地文件，则可以如此设置。但是如果是在服务器上，则千万别这么做。

     > Another interesting case are `null` origins. They occur when a resource is accessed by a browser that renders a local file. For example, requests coming from some JavaScript running in a static file on your local machine have the `Origin` header set to `null`.
     >
     > In such cases, if our servers do now allow access to resources for the `null` origin, then it can be a hindrance to the developer productivity. Allowing the `null` origin within your CORS policy has to be deliberately done, and only if the users of your website / product are developers.

+ 跨域发送Cookie

  跨域请求，浏览器默认不允许携带cookie，通过`Access-Control-Allow-Credentials: true`放行。

  放行跨域cookie是个危险操作，最好在明确知道哪些用户访问、且必须放行才能使服务正常运作时才考虑这么做。

  **因为放行跨域cookie的风险很大，所以当设置`Access-Control-Allow-Credentials: true`时，不允许再设置`Access-Control-Allow-Origin: *`**（虽然这一组合技术上可行，但是应该避免这么做！）

  **如果需要允许不同源的不同用户访问服务资源，应该首选考虑token机制，而不是cookies**。

  > As we saw before with the `Access-Control-Allow-Credentials`, cookies are not enabled by default. To allow cross-origin sending cookies, it as easy as returning `Access-Control-Allow-Credentials: true`. This header will tell browsers that they are allowed to send credentials (i.e. cookies) in cross-origin requests.
  >
  > Allowing and acepting cross-origin cookies can be tricky. You could expose yourself to potential attack vectors, so enable them only when **absolutely neccessary**.
  >
  > Cross-origin cookies work best in situations when you know exactly which clients will be accessing your server. That is why the CORS semantics do not allow us to set `Access-Control-Allow-Origin: *` when cross-origin credentials are allowed.
  >
  > While the `Access-Control-Allow-Origin: *` and `Access-Control-Allow-Credentials: true` combination is technically allowed, it’s a anti-pattern and should absolutely be avoided.
  >
  > If you would like your servers to be accessed by different clients and origins, you should probably look into building an API (with token-based authentication) instead of using cookies. But if going down the API path is not an option, then make sure you implement cross-site request forgery (CSRF) protection.

### 6.7 电子邮件协议(SMTP/POP3/IMAP)

#### 6.7.1 SMTP/POP3/IMAP概述

> [SMTP--百度百科](https://baike.baidu.com/item/SMTP/175887?fr=aladdin)
>
> SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。
>
> [POP3--百度百科](https://baike.baidu.com/item/POP3/175122?fr=aladdin)
>
> **POP3**，全名为“Post Office Protocol - Version 3”，即“[邮局协议](https://baike.baidu.com/item/邮局协议)版本3”。是[TCP/IP](https://baike.baidu.com/item/TCP%2FIP)协议族中的一员，由[RFC](https://baike.baidu.com/item/RFC)1939 定义。本协议主要用于支持使用客户端远程管理在[服务器](https://baike.baidu.com/item/服务器/100571)上的电子邮件。提供了[SSL](https://baike.baidu.com/item/SSL)加密的POP3协议被称为POP3S。
>
> **POP 协议**支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子[邮件客户端](https://baike.baidu.com/item/邮件客户端)调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从[邮件服务器](https://baike.baidu.com/item/邮件服务器/985736)端送到个人终端机器上，一般是PC机或MAC。一旦邮件发送到 PC 机或[MAC](https://baike.baidu.com/item/MAC)上，邮件服务器上的邮件将会被删除。但POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。
>
> [imap--百度百科](https://baike.baidu.com/item/imap/350154?fr=aladdin)
>
> IMAP（Internet Mail Access Protocol）以前称作交互邮件访问协议（Interactive Mail Access Protocol），是一个应用层协议。IMAP是[斯坦福大学](https://baike.baidu.com/item/斯坦福大学/278716)在1986年开发的一种邮件获取协议。它的主要作用是邮件[客户端](https://baike.baidu.com/item/客户端)可以通过这种协议从邮件[服务器](https://baike.baidu.com/item/服务器)上获取邮件的信息，下载邮件等。当前的权威定义是RFC3501。IMAP协议运行在[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP协议)之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的[邮件](https://baike.baidu.com/item/邮件/3110293)全部下载，可以通过[客户端](https://baike.baidu.com/item/客户端/101081)直接对[服务器](https://baike.baidu.com/item/服务器/100571)上的邮件进行操作。

简单理解就是，SMTP用来发送邮件，POP3和IMAP用于收邮件。

> [邮件系统域名设置小常识](https://www.altn.com.cn/1210.html)
>
> 邮件系统域名配置
> 域名服务器提供了域名与IP地址的转换。当一个邮件服务器发送邮件时，首先要将接收者的域名转换为对应的IP地址。对于一个类似 www.company.com这样的域名，一个IP地址对应着DNS服务器上的一条A（address）记录，一般是一一对应的关系。但是一般大家的电 子邮件地址上的域名常常是company.com这样的格式，只说明了邮件送到哪个域，而没有说明送到哪台具体的主机，这时邮件会送到哪里呢？
>
> 这时需要在 DNS服务器上指明由哪台主机来做本域的邮件服务器，在DNS中有一种**MX（邮件地址转换Mail exchanger）记录**，专门指明了本域中由哪一台或几台主机来做邮件服务器。MX记录由域名服务器（DNS）进行维护，MX记录告诉MTA本域名哪台主机是邮件服务器，将邮件最终送到哪里。
>
> [PTR记录--百度百科]([https://baike.baidu.com/item/PTR%E8%AE%B0%E5%BD%95/8243039?fr=aladdin](https://baike.baidu.com/item/PTR记录/8243039?fr=aladdin))

#### 6.7.2 SMTP

> [SMTP Service Extension for Secure SMTP over Transport Layer Security](https://www.rfc-editor.org/rfc/rfc3207.html)
>
> [协议基础：SMTP：使用Telnet学习SMTP协议](https://blog.csdn.net/liumiaocn/article/details/81131420)

​	SMTP是一种提供可靠且有效电子邮件传输的协议。它是**建立在FTP文件传输服务上的一种邮件服务**，主要用于传输系统之间的邮件信息并提供来信有关的通知。

​	SMTP重要的特性之一是它能跨越网络传输邮件，也即“SMTP邮件中继”。使用SMTP，可实现相同网络上处理机之间的邮件传输，也可以通过中继器或网关实现某处理机与其它网络之间的邮件传输。

#### 6.7.3 POP3

​	POP适用于C/S结构的脱机模型的[电子邮件协议](https://baike.baidu.com/item/电子邮件协议)，已发展POP3到第三版，称POP3。脱机模型即不能在线操作，POP不支持对[服务器](https://baike.baidu.com/item/服务器)邮件进行扩展操作，此过程需要更高级的IMAP4协议来完成。支持POP协议使用ASCII码来传输数据消息，这些数据消息可以是指令，也可以是应答。

​	POP[协议支持](https://baike.baidu.com/item/协议支持)离线邮件处理，当邮件发送到[服务器](https://baike.baidu.com/item/服务器)后，电子[邮件客户端](https://baike.baidu.com/item/邮件客户端)会调用邮件客户端程序，下载所有未阅读的电子邮件（这种离线访问模式是一种存储转发服务）。**当邮件从[邮件服务器](https://baike.baidu.com/item/邮件服务器)发送到[个人计算机](https://baike.baidu.com/item/个人计算机)上，同时邮件服务器会删除该邮件（但是很多POP3服务器都支持“下载邮件，服务器并不删除邮件”，也就是说在POP3中改进了POP协议）**。

#### 6.7.4 IMAP

> [什么是 POP3?](https://www.zhihu.com/question/356357769)

​	POP3是第一个离线协议标准，用户登录客户端设置POP3，可以将邮件从服务器存储到本地计算机，同时删除服务器上的邮件。POP3服务器是遵循POP3协议的接受邮件服务器，用于接收电子邮件。

​	IMAP与POP3类似，不同的是用户登录客户端设置IMAP，**在本地计算机存储邮件之后，邮件仍保留在服务器上，同时客户端的相关操作都会同步服务器，能够保持浏览器登录与客户端登录，看到的邮件及状态一致。**(POP3只显示未读邮件)

### 6.8 MQTT

#### 6.8.1 MQTT概述

> [MQTT_百度百科 (baidu.com)](https://baike.baidu.com/item/MQTT/3618851?fr=aladdin)
>
> [MQTT 入门介绍 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/mqtt-intro.html)
>
> [MQTT - Wikipedia](https://en.wikipedia.org/wiki/MQTT)
>
> [MQTT | Internet of Things Wiki | Fandom](https://iot-fpms.fandom.com/wiki/MQTT)
>
> [MQTT - The Standard for IoT Messaging](https://mqtt.org/)

​	MQTT（Message Queuing Telemetry Transport），基于TCP/IP协议，使用发布/订阅模式进行数据通信，常用于物联网(IoT)场景。MQTT能高效地在有限带宽和低配硬件之间实现网络通信。

![img](https://static.runoob.com/images/mix/mqtt-fidge-2.svg)

​	MQTT基于TCP，MQTT-SN基于UDP或Bluetooth。

​	<small>MQTT relies on the TCP protocol for data transmission. A variant, MQTT-SN, is used over other transports such as UDP or Bluetooth.</small>

​	默认情况下MQTT明文传输数据，可以配合TLS进行加密数据传输。

​	<small>MQTT sends connection credentials in plain text format and does not include any measures for security or authentication. This can be provided by using [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) to encrypt and protect the transferred information against interception, modification or forgery.</small>

​	默认的MQTT端口(未加密)为1883，配合TLS的加密端口为8883。

​	<small>The default unencrypted MQTT port is 1883. The encrypted port is 8883.</small>

## 7. 网络安全

### 7.1 网络安全概述

+ 两类密码体制（对称加密、非对称加密）
+ 数字签名
+ 因特网使用的安全协议
+ 链路加密与端到端加密
+ 防火墙

### 7.2 网络攻击模式与举例

#### 7.2.0 网络攻击模式

计算机网络上的通信面临以下的四种威胁：

1. **截获**——从网络上窃听他人的通信内容。
2. **中断**——有意中断他人在网络上的通信。
3. **篡改**——故意篡改网络上传送的报文。
4. **伪造**——伪造信息在网络上传送。

其中，截获信息的攻击称为**被动攻击**，而更改信息和拒绝用户使用资源的攻击称为**主动攻击**。

#### 7.2.1 截获

典型举例：同一网段下（交换机）下，在计算机发起ARP请求获取网关等的设备的MAC地址时，黑客启用原先设置好的脚本程序等，自动回应ARP请求，让受害者主机以为黑客主机的MAC地址就是路由器（网关设备）的MAC地址。之后受害者用户原本该向路由器发送的数据（跨网段传输的数据），都会经过黑客主机（该流程也叫ARP欺骗）。黑客可以设置转发用户的流量让用户无感知被**截获**数据，而黑客则在电脑上存放着所有受害则主机访问因特网的数据包信息。

#### 7.2.2 中断

一种情况是ARP欺骗后，拒绝转发用户流量，直接让用户上不了网。
另一种就是DOS和DDOS攻击。假设某受害者公司的带宽就50M，普通家庭拨号上网仅有2M上传带宽，如果单主机对服务器发起DOS攻击，那么撑死占用服务器2M资源，服务器还是有48M带宽可正常工作。黑客通过搜集"肉鸡"，发起指令，让成百上千肉鸡同时对受害者服务器进行DDOS攻击，一下子就能把服务器的带宽占满，使其没法正常为外界提供服务。

> [DDOS--百度百科]([https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/3802159?fromtitle=DDOS&fromid=444572&fr=aladdin](https://baike.baidu.com/item/分布式拒绝服务攻击/3802159?fromtitle=DDOS&fromid=444572&fr=aladdin))
>
> 分布式拒绝服务攻击可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用，分布式拒绝服务攻击已经出现了很多次，导致很多的大型网站都出现了无法进行操作的情况，这样不仅仅会影响用户的正常使用，同时造成的经济损失也是非常巨大的。
>
> 分布式拒绝服务攻击方式在进行攻击的时候，可以对源IP地址进行伪造，这样就使得这种攻击在发生的时候隐蔽性是非常好的，同时要对攻击进行检测也是非常困难的，因此这种攻击方式也成为了非常难以防范的攻击。
>
> [什么是高防？流量清洗的原理是什么？如何科学的防御DDoS攻击？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1cY411x7k8)

#### 7.2.3 篡改

典型举例：**篡改**需要建立在受害者已经被**截获**的前提下。受害者主机发送DNS请求时，黑客由于已经通过ARP欺骗**截获**了相同网段的所有其他主机访问其他网段的流量，当用户主机发起DNS请求时，黑客拦截该请求，并返回错误的解析结果。比如，用户浏览器输入url为`www.baidu.com`，主机自动发起DNS请求（一般是UDP+53，少部分时候TCP+53），黑客脚本自动拦截，返回一个错误的IP地址。用户无感知DNS解析过程，并且访问到一个错误的页面（此时浏览器的url栏同样还是显示`www.baidu.com`），一般黑客会挑选工商银行之类的重要页面进行DNS劫持，然后让用户跳转到一个外观一模一样的钓鱼网站，用户输入账号密码后，黑客主机也会有相同的账号密码记录。

#### 7.2.4 伪造

典型举例：某些网站或者服务器限制IP登录。黑客等原本拥有该IP地址的主机关机后，在**伪造**自己的IP为限定的IP地址。之后黑客就可以用事先通过其他途径获取到的受害者的登录密码等信息名正言顺地冒用其身份登录远程服务器等。

**截获**和**篡改**基于ARP欺骗。如果用户主机有开启ARP防火墙，那上面的攻击就无法成立。除非黑客是某网络环境的内鬼，事先在与其他用户共用的物理设备交换机上设置了端口监听，那么黑客就能直接获取交换机转发的所有数据，就用不着ARP欺骗了。(一般只有大工地网络的网络管理员才有权限配置交换机、路由器等)。
很早以前的攻击软件比如"cain"、"末日帝国DDOS攻击器"等。

### 7.3 恶意程序

#### 7.3.1 概述

+ 计算机病毒：会"传染"其他程序的程序，"传染"是通过修改其他程序来把自身或其变种复制进去完成的。（病毒也不一定目的是修改某些系统配置。有些会通过恶意的申请内存空间等操作，慢慢占用CPU和内存，让电脑死机。）
+ 计算机蠕虫：通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。
+ 特洛伊木马：一种程序，它执行的功能超出所声称的功能。
+ 逻辑炸弹：一种当运行环境满足某种特定条件时执行其他特殊功能的程序。

#### 7.3.2 举例

+ 计算机病毒：熊猫烧香。中毒后的电脑就算原本有ghost备份系统也无效，因为病毒会删除备份。只能系统重装。

  > [勒索病毒--百度百科]([https://baike.baidu.com/item/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/16623990?fr=aladdin](https://baike.baidu.com/item/勒索病毒/16623990?fr=aladdin))

+ 计算机蠕虫：

  > [蠕虫病毒--百度百科]([https://baike.baidu.com/item/%E8%A0%95%E8%99%AB%E7%97%85%E6%AF%92/4094075?fr=aladdin](https://baike.baidu.com/item/蠕虫病毒/4094075?fr=aladdin))
  >
  > 蠕虫是一种可以自我复制的代码，并且通过网络传播，通常无需人为干预就能传播。蠕虫病毒入侵并完全控制一台计算机之后，就会把这台机器作为宿主，进而扫描并感染其他计算机。当这些新的被蠕虫入侵的计算机被控制之后，[蠕虫](https://baike.baidu.com/item/蠕虫/4454380)会以这些计算机为宿主继续扫描并感染其他计算机，这种行为会一直延续下去。蠕虫使用这种递归的方法进行传播，按照指数增长的规律分布自己，进而及时控制越来越多的计算机。

+ 特洛伊木马：比如灰鸽子程序。可以修改图标发送给受害者，让受害者点击并中招。中灰鸽子木马的主机，会自动向黑客主机报告，让黑客主机能够远程操控自己。

+ 逻辑炸弹：也类似病毒，比如是定时运行的病毒程序，每到半夜三更之类的就自动执行某些恶意操作的脚本程序之类的。

有些病毒/木马需要建立网络连接，平时我们通过`netstat -an`要是看到什么奇怪的连接，就可以猜测自己是不是中招了。

### 7.4 加密技术

#### 7.4.1 常用的几种算法

> [对称加密--百度百科]([https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/2152944?fr=aladdin](https://baike.baidu.com/item/对称加密/2152944?fr=aladdin))
>
> [非对称加密算法--百度百科]([https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/1208652?fr=aladdin](https://baike.baidu.com/item/非对称加密算法/1208652?fr=aladdin))
>
> [单向散列算法--百度百科]([https://baike.baidu.com/item/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95/4632951](https://baike.baidu.com/item/单向散列算法/4632951))

+ 对称加密算法：采用单钥[密码系统](https://baike.baidu.com/item/密码系统/5823651)的加密方法，同一个[密钥](https://baike.baidu.com/item/密钥/101144)可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单[密钥加密](https://baike.baidu.com/item/密钥加密/5928903)。
  + DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。
  + 3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。
  + AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。
+ 非对称加密算法：非对称加密算法需要两个密钥：[公开密钥](https://baike.baidu.com/item/公开密钥/7453570)（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
  + RSA
+ 单向散列哈希算法：单向散列算法，又称[hash函数](https://baike.baidu.com/item/hash函数/10555888)，Hash函数（也称杂凑函数或杂凑算法）就是把任意长的输入消息串变化成固定长的输出串的一种函数。这个输出串称为该消息的杂凑值。一般用于产生[消息摘要](https://baike.baidu.com/item/消息摘要/4547744)，密钥加密等。
  + MD5
  + SHA
  + HMAC

#### 7.4.2 对称加密和非对称加密对比

1. 对称加密：

   优点：效率高

   缺点：密钥不适合在网络上传输

2. 非对称加密：

   优点：安全性比其对称加密更高；公钥可在网络上传播

   缺点：效率低

假如需要通信的A和B要进行文件加密传输，我们分析使用对称加密、非对称加密和混合使用这三种情况：

+ 采用对称加密：线上交流密钥会被盗用。需要线下交流密钥，繁琐。
+ 采用非对称加密：A线上将自己的公钥a告诉B，而B把自己的公钥b告诉A。之后A给B发送文件时用公钥b进行非对称加密，而B则用公钥a加密要发送给A的文件。由于A和B的私钥不公开，所以就算被监听，也难以盗取文件。但是非对称加密解密效率低，用户体验差。
+ 混合使用：A要向B发送加密文件前，用公钥b加密一个对称密钥s，B收到后，用自己的私钥解密，获取到对称密钥s。之后A向B发送文件或者B向A发送文件时，使用对称密钥s对文件进行加密解密。这种协商对称密钥时使用非对称加密，之后实际加密数据则采用对称加密的通讯方法，安全又高效。

#### 7.4.3 数字签名

> [数字签名--百度百科]([https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550?fr=aladdin](https://baike.baidu.com/item/数字签名/212550?fr=aladdin))
>
> 数字签名（又称[公钥](https://baike.baidu.com/item/公钥)数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它是一种类似写在纸上的普通的物理签名，但是使用了[公钥加密](https://baike.baidu.com/item/公钥加密/6245950)领域的技术来实现的，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。数字签名是非对称[密钥加密技术](https://baike.baidu.com/item/密钥加密技术)与[数字摘要](https://baike.baidu.com/item/数字摘要/4069118)技术的应用。
>
> [数字摘要--百度百科]([https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E6%91%98%E8%A6%81/4069118?fr=aladdin](https://baike.baidu.com/item/数字摘要/4069118?fr=aladdin))
>
> 数字摘要是将任意长度的消息变成固定长度的短消息，它类似于一个自变量是消息的函数，也就是Hash函数。数字摘要就是采用单向Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文这一串密文**又称为数字指纹**，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。

如果说对称加密和非对称加密是用来加密数据的，那**数字签名是用来校验身份的**。

前面非对称加密，A和B通讯时，A使用B的公钥加密数据并传输给B，由于B的密钥只有B知道，所以只有B能解密秘文。

A为了向B证实自己是A，当A向B发送无需加密的数据时，A使用Hash算法得出数据的**摘要**，然后使用A自己的<u>密钥对摘要进行加密</u>得到**数字签名**。之后A向B发送2部分内容（原数据，数字签名）。B收到后，对原数据使用同样的Hash算法获得摘要，用A的公钥解密数字签名，如果解密数字签名后得到的数据和B自己Hash算出来的摘要内容一致，那么认为该数据没被篡改，且确实来自"A"。

数字签名，防止抵赖，能够验证签名之后的内容是否被更改。

#### 7.4.4 数字证书

> [数字证书--百度百科]([https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/326874?fr=aladdin](https://baike.baidu.com/item/数字证书/326874?fr=aladdin))
>
> 数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。 [1] 
>
> 因此数字证书又称为数字标识。数字证书对网络用户在[计算机网络](https://baike.baidu.com/item/计算机网络/18763)交流中的信息和数据等以[加密](https://baike.baidu.com/item/加密/752748)或[解密](https://baike.baidu.com/item/解密/18611004)的形式保证了信息和数据的完整性和安全性。
>
> [CA证书--百度百科]([https://baike.baidu.com/item/CA%E8%AF%81%E4%B9%A6/10028741?fromtitle=CA&fromid=20721560#viewPageContent](https://baike.baidu.com/item/CA证书/10028741?fromtitle=CA&fromid=20721560#viewPageContent))

​	数字证书与数字签名类似，但是数字证书更具有权威性，因为是需要用户向CA机构注册的。打个比方就是，数字签名是你自制的身份证，而数字证书是公安局登记并颁发的身份证，那么肯定是后者更有公信力。



使用数字证书后，A预向B发送一份无需加密的合同文件，需要以下几个步骤：

1. A向CA注册证书，需填写各种能标明真实身份的信息。CA机构经过各种方式认证后，同意颁发证书，发送给A带有CA机构签名的密钥对。
2. A假设要发个合同给B，于是发送3（合同原件，A私钥加密过的合同数字摘要、CA签名的A的公钥）内容给B。
3. B收到后，先用网上认证的CA公钥解密获得A的公钥（CA签名，CA证书上记录的A公钥要是和解密获得的一致，也证明A的公钥是从CA机构认证后得到的）。然后对合同自己也计算摘要，再用A公钥解密获得A计算的合同数字摘要，发现和自己计算的一样，于是认定合同原件没有被捏造，确实是A发给自己的。

#### 7.4.5 SSL数字证书常见应用场景

> [SSL证书--百度百科]([https://baike.baidu.com/item/SSL%E8%AF%81%E4%B9%A6/5201468?fr=aladdin](https://baike.baidu.com/item/SSL证书/5201468?fr=aladdin))
>
> SSL证书是[数字证书](https://baike.baidu.com/item/数字证书/326874)的一种，类似于驾驶证、护照和营业执照的电子副本。因为配置在服务器上，也称为SSL服务器证书。
>
> SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。

1. 邮箱系统

   假设A和B要互相发送邮件，然后A给自己的邮箱账号注册了个人邮箱使用的SSL证书。

   + A->B：A用自己的私钥对邮件进行签名，之后B用CA签名的A公钥解密邮件，验证邮件确实由A本人发送而来。
   + B->A：B用A的公钥对邮件进行加密，之后A用自己的私钥解密邮件。

   这里由于B没有申请证书，所以A无法获取可信任的B的公钥，进而无法发送仅B能解密的加密邮件。

   同理，由于B没有注册CA证书，没法向A发送有公信力的数字签名过的邮件。

2. web服务站点

   往往只有服务器注册并安装了CA证书。其向用户返回响应数据时，用自己的密钥对数据进行数字签名，用户即可相信数据来源。

> [CRL--百度百科](https://baike.baidu.com/item/CRL/4219827?fr=aladdin)
>
> 证书具有一个指定的寿命，但 CA 可通过称为证书吊销的过程来缩短这一寿命。CA 发布一个证书吊销列表 (CRL)，列出被认为不能再使用的证书的序列号。
>
> **用户验证其他用户的CA证书时，也会查看证书是否失效**。

### 7.5 应用层安全

#### 7.5.1 OAuth1.0和OAuth2.0概述

> [OpenID--百度百科](https://baike.baidu.com/item/OpenID/2267230?fr=aladdin)
>
> OpenID 是一个以用户为中心的数字身份识别框架，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 [URL](https://baike.baidu.com/item/URL/110640) 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的[身份认证](https://baike.baidu.com/item/身份认证/5294713)。
>
> 登录一个支持 OpenID 的网站非常简单（即便你是第一次访问这个网站也是一样）。只需要输入你注册好的 OpenID 用户名，然后你登录的网站会跳转到你的 OpenID 服务网站，在你的 OpenID 服务网站输入密码（或者其它需要填写的信息）验证通过后，你会回到登录的网站并且已经成功登录。**OpenID 系统可以应用于所有需要[身份验证](https://baike.baidu.com/item/身份验证)的地方，既可以应用于单点登录系统，也可以用于共享敏感数据时的[身份认证](https://baike.baidu.com/item/身份认证)。**
>
> 除了一处注册，到处通行以外，OpenID 给所有支持 OpenID 的网站带来了价值—共享用户资源。用户可以清楚的控制哪些信息可以被共享，例如姓名、地址、电话号码等。
>
> <small>2014年5月，新加坡南洋理工大学一位名叫王晶(Wang Jing)的物理和数学科学学院博士生，发现了[OAuth](https://baike.baidu.com/item/OAuth)和**OpenID**开源登录工具的"[隐蔽重定向漏洞](https://baike.baidu.com/item/隐蔽重定向漏洞)"(Covert Redirect)。</small>
>
> <small>其实漏洞不是出现在OpenID这个协议本身，这个协议本身是没有问题的，之所以存在问题是因为各个厂商没有严格引用官方文档，只是实现了简版。问题的原因在于OpenID的提供方提供OpenID授权过程中没有对回调的URL进行校验，从而导致可以被赋值为非原定的回调URL。</small>

> [OAuth 1.0，1.0a 和 2.0 的之间的区别有哪些？](https://www.zhihu.com/question/19851243)
>
> [OAuth & OpenID & SAML 工作流程梳理对比](https://www.jianshu.com/p/6e25a892db89)

​	在OAuth1.0和OAuth2.0之前，类似的于用户相关的框架有OpenID。OpenID主要是用来身份认证的，仅仅用于登录账号。

​	OpenID和OAuth系列的区别在于，**OpenID只负责身份认证，而OAuth着重于用户授权**（当然也可以做成连带身份认证的）。

*<small>个人感觉网上的人，说来说去都一个说法，我举些例子，自己感觉比较好理解。</small>*

​	OpenID等于让你不用每个平台都另外注册一个新账号，可以用别的平台的账号登录。<small>但是有些平台，你靠OpenID登录后，还是会要求你绑定一个本平台账号，如果没有就需要新注册一个。</small>（实际上，支持OpenID登录的平台，同样也会在自己的数据库记录该用户，等于自动帮你用你其他平台的账号信息给你注册了一下它们平台的账号，以后身份校验就走本地数据库。或者你要是实在太懒，再用其他平台账号登录，它同样会根据自己已经生成的用户信息比对，然后找到相应的用户身份让你登录。）

​	OAuth系列，则是当你使用平台A的服务时，需要占用你也有使用的平台B的资源，此时平台A自动向B申请要资源，获取请求令牌后，再请求你授权该令牌（一般授权方式就是用你平台B的账号密码登录平台B的某授权页面），你授权后，A拿到来自平台B的授权后令牌，然后再用该授权令牌去平台B兑换资源。（一般授权都是平台B只给平台A部分功能，比如网易云音乐分享音乐到QQ上，网易云音乐就必须向QQ申请访问你QQ用户列表的权限，当然最后你授权了它也只能拿到这部分的权限。它不至于说还能兑换到添加好友、删除好友等功能的权限。）

​	要我总结的话，OpenID和OAuth可以粗糙地理解为：

+ OpenID用你提供的其他平台B的信息帮你自动注册/登录当前访问的平台A。

  <small>一般用OpenID，你感觉不到注册过程。其实就是平台B用你授权的平台A的用户信息帮你在数据库注册了一个用户user_auto，而这个user_auto往往使用你平台A公布的部分信息设置一些用户信息，比如头像和你QQ头像一样，昵称也一样之类的。实际数据库有个对照关系。比如你授权用QQ号1登录，平台B向平台A申请获取你部分用户信息时，中间获取到平台A返回的一个token令牌之类的参数，与你这个QQ号1唯一对应。那么它数据库加一条token_QQ_1 --> user_auto标识这样对照关系的记录就好了。</small>

+ OAuth系列用你授权的平台A令牌得以让你在当前访问的平台B上使用部分平台A的功能。

  <small>一般用OAuth，就是平台A只需要临时占用平台B的资源，而不需要永久保存其身份的情况。比如"分享至QQ"、"使用微信支付"、"使用支付宝支付"等，这些往往只需要调用其部分功能，"分享至QQ"就只需要平台B的好友列表和发送聊天的功能；"使用微信支付"、"使用支付宝支付"都只需要其支付功能。当然，OAuth不是说只能用于这种部分授权的场景，能做到部分授权，同样也可以做到用户登录/注册，如常见的"第三方账号登录"。和OpenID常做的事情一样，平台A会保存部分来自平台B的信息，用于以后鉴别用户，毕竟平台B总不可能每次你用QQ登录都给你重新新建个用户，然后把你在平台B上的信息全清空吧？</small>

#### 7.5.2 OAuth1.0

> [OAuth 1.0 简介](https://blog.csdn.net/joeyon1985/article/details/42026039)

![OAuth1.0Core](http://sexywp.com/wp-content/uploads/2014/05/OAuth1.0Core.png)

​	*<small>网络上的文章都写得很详细了。这里就不再累述了，就简单概述流程。</small>*

最初的OAuth1.0，假设网易云音乐点击分享至QQ，那么经过如下流程：<small>（具体的参数什么的，我觉得没必要说的那么详细。下面流程是虚构的。）</small>

1. 你在网易云界面点击"分享至QQ"一瞬间，网易云音乐携带之前在QQ平台注册的参数，向QQ平台发起"需要使用QQ用户的聊天列表的功能"的授权请求；QQ平台返回给网易云一个授权该请求的跳转连接。
2. 网易云把从QQ那拿到的授权连接给你，你输入你QQ的账号密码表示愿意授权让网易云可以用你的"用户聊天列表功能"。你登录后，等于又发出请求给QQ平台。
3. QQ平台确认是存在这个QQ号的用户登录要求给网易云授权，让网易云可以用你的QQ号的聊天列表。于是QQ下发给网易云关于你账号的令牌，其表明你这个QQ号身份，同时也表明只能使用"聊天列表功能"。
4. 网易云平台拿到这个授权过的令牌后，再拿着这个授权过的令牌找QQ平台。
5. QQ平台一看网易云给自己一个授权过的令牌，解码/解密等操作后，知道是要给网易云平台关于这个QQ用户的聊天列表功能的权限，于是返回给网易云该QQ用户的好友列表操作界面。这时候我们就能在浏览器上选择要把歌分享给哪个QQ好友了。

最初的OAuth1.0存在安全漏洞，如果黑客在分享音乐界面，没有选择登录自己的QQ号之前，而是故意把该界面的链接转发给受害者，受害则出于某种原因，真在用户授权界面（登录自己的其他平台账号）的界面输入密码并点击确认。黑客由于预先做过调查工作，知道用户登录QQ授权后，页面会跳转到什么链接，所以可抢先在受害者之前访问该链接，并得到服务器原本要发给登录者的已授权令牌。获取受害者的授权令牌后，黑客就可以看到受害者的QQ好友列表了。（产生该漏洞的原因主要是，提供授权的QQ平台和要求授权的网易云平台本身没有检查要求授权的用户和进行授权的用户从头到尾是不是同一个人在操作。）

由于OAuth1.0的安全漏洞，后面出了"打上安全补丁"的OAuth1.0a，其在申请授权、授权等步骤提交的HTTP申请和HTTP响应中添加了新参数，用于确保至始至终是同一个用户操作，避免某受害者的授权令牌被黑客利用。

> [OAuth1.0](https://openapi.baidu.com/wiki/index.php?title=OAuth1.0#.E8.AF.B7.E6.B1.82.E7.AD.BE.E5.90.8D)

#### 7.5.3 OAuth2.0

> [OAuth2.0--百度百科](https://baike.baidu.com/item/OAuth2.0/6788617?fr=aladdin)
>
> OAuth2.0是OAuth协议的延续版本，但**不向前兼容OAuth 1.0(即完全废止了OAuth1.0)**。 OAuth 2.0关注客户端开发者的简易性。要么通过组织在资源拥有者和HTTP服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。2012年10月，OAuth 2.0协议正式发布为RFC 6749。
>
> 原先的OAuth，会发行一个 有效期非常长的token(典型的是一年有效期或者无有效期限制)，在OAuth 2.0中，server将发行一个短有效期的access token和长生命期的refresh token。这将允许客户端无需用户再次操作而获取一个新的access token，并且也限制了access token的有效期。
>
> [理解OAuth2.0认证与客户端授权码模式详解](https://segmentfault.com/a/1190000010540911)

​	![clipboard.png](https://segmentfault.com/img/bVSnXh?w=561&h=372)

​	*<small>之前在"网络安全/OAuth/OAuth学习杂记"里面搜集并学习了很多关于OAuth2.0的文章了，也曾在项目用JWT+Redis自己实现了token和refresh_token的机制。这里也不多对OAuth2.0进行累述了。</small>*

​	OAuth2.0最严谨同时也是最常用的模式就是`授权码模式`。

其步骤如下：

1. 用户访问客户端，后者将前者导向认证服务器

2. 用户选择是否给予客户端授权

3. 假设用户给予授权，认证服务器将用户导向客户端事先指定的重定向`URI`，同时附上一个授权码

4. 客户端收到授权码，附上早先的重定向`URI`，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见

5. 认证服务器核对了授权码和重定向`URI`，确认无误后，向客户端发送访问令牌（`access token`）和更新令牌（`refresh token`）等

![clipboard.png](https://segmentfault.com/img/bVSn2t?w=715&h=414)

总结整个请求过程：<small>（其他杂七杂八的参数我全部省略，只保留必须的，同样不考虑第三方需要保证的`state`和用户关联的设计问题）</small>：

1. 用户点击按钮，`第三方Client`把用户重定向到`Auth Server`(因为用户本来访问的域是第三方而不是`Auth Server`,所以是重定向而不是转发)

   ```http
   GET https://server.example.com/v1/oauth/authorize?response_type=AUTHORIZATION_CODE
   &client_id=s6BhdRkqt3
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
   &scope=read
   &state=xxx
   
   Host: server.example.com
   
   + response_type：授权类型，必选项，此处的值固定为"code",指授权码模式。
   + client_id：客户端的ID，必选项。这个是第三方在所有步骤之前很早就去找Auth Server注册的(注册后获得client_ID和secret)
   + redirect_uri：重定向URI，必选项。指用户获取core后，需要重定向回第三方应用的哪个URL链接好让第三方能拿到core(第三方定死的，并且在老早之前去Auth Server注册的时候就要写好了，不能乱改，redirect_uri是注册信息之一，注册后获得client_ID和secret)
   + scope：申请的权限范围，可选项。比如分享页面至QQ，那么scope的值需要能表示"获取QQ用户聊天列表"(具体用什么值，Auth Server那里会有网站列清单和你说清楚)
   + state：任意值，认证服务器会原样返回,用于抵制CSRF(跨站请求伪造)攻击。一般需要能和授权用户身份对应，不然如果无论哪个用户请求core时携带的state都是一样的，state就没有意义了。
   ```

2. 步骤1后，用户跳转到`Auth Server`专门用于用户授权的页面，链接就是步骤一那个。用户登录账号或者其他操作之后，点击"授权"。

3. `Auth Server`根据获取到的用户登录信息比对自己数据库，确认有该用户注册过自己的服务平台。然后也确认用户步骤1链接过来的请求URL的`response_type`、`client_id`、`redirect_uri`和`scope`都是第三方有找自己注册过且允许的。都确认无错误后，响应，将用户重定回步骤1指定的`redirect_uri`，携带原本步骤1带有的`state`和这次颁发的`core`。

   ```http
   HTTP/1.1 302 Found https://client.example.com/cb?
   code=SplxlOBeZQQYbYS6WxSbIA
   &state=xxx
   
   
   + code：授权码，必选项。授权码有效期通常设为10分钟，一次性使用。该码与客户端ID(client_id)、重定向URI(redirect_uri)以及用户，是一一对应关系。(每次生成的不一样，并且code算消耗品，同一个code同一时间只能兑换到一个最后步骤的access_token,下一个人要是用同一个code去申请access_token会失效。这样如果中间人提前获得并申请到access_token，那么用户操作的第三方应用慢一步使用同一个code，无法获得access_token，于是用户发现授权失败，会再重新请求一遍，这就使得中间人提前无用功。要是中间人慢一步，那就直接通过同一个code获取access_token。)
   + state：原样返回客户端步骤1传的该参数的值。(返回一样的，这样第三方就能确认之前state参数给的是用户1，之后也是用户1携带的code和state给自己，确保code是同一个用户获取到的，而不是中间人CSRF攻击用中间人自己获取的code。一般第三方需要能判断state和用户的对应关系，而不是单纯看URL链接的state参数判断是否同一个人，因为不管谁用这个链接state不都没变过。)
   ```

4. `第三方Client`携带从用户重定向回来访问自己的URL中的`code`去找`Auth Server`要`access_token`。

   ```http
   POST /token HTTP/1.1
   Host: server.example.com
   Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
   Content-Type: application/x-www-form-urlencoded
    
   grant_type=AUTHORIZATION_CODE
   &client_id=s6BhdRkqt3
   &client_secret=asjdasd456a4sd
   &authorization_code=SplxlOBeZQQYbYS6WxSbIA
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
   
   + grant_type: 表示使用的授权模式，必选项，此处的值固定为"authorization_code"。(和步骤1的response_type是相对应的)
   
   + client_id: 和步骤1的相同，第三方老早之前去Auth Sever指定的页面注册的。
   
   + client_secret: 协议里不是必须项，但一般为了安全，都会启用这个参数。在第三方以前找Auth Server申请时，client_secret是和client_id配对发给第三方保存的。这个仅最后第三方找Auth Server申请要access_token时携带，好让Auth Server多一个参数可以验证来访者是否是以前找自己注册过的第三方。
   
   + authorization_code: 参数步骤3用户授权后重定向回来第三方顺带在URL中的code参数
   
   + redirect_uri: 参数是令牌颁发后的回调的网址，和步骤1是同一个，是第三方老早去Auth Server注册时填写的。
   ```

5. `Auth Server`验证第三方信息确实在自己这里注册过，且code等参数有效，以及可能还有验证其他附加参数之后，同意给`第三方Client`颁发`access_token`。之后第三方就可以凭借这个`access_token`从同样是`Auth Server`组织的`Client Rource`那获取想要的数据、资源等东西了。

   ```http
   HTTP/1.1 200 OK
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store
   Pragma: no-cache
   
   {    
       "access_token":"asjdk2h982921hashlld",
       "token_type":"bearer",
       "expires_in":2592000,
       "refresh_token":"ajskdj289asidh910y2edN",
       "scope":"read",
       "uid":100101,
       "info":{...}
   }
   
   json数据里面前4个属性是一般都要有的，其余的都是各个Auth Server自由发挥了。
   从返回的头信息也可以得知Auth Server要求第三方别缓存这些信息在浏览器等User-agent用户代理软件/应用上。
   
   + access_token：表示令牌，后面第三方都是携带这个去找对应的服务方要数据/服务的。(用户无感知)
   
   + token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型
   
   + expires_in：表示过期时间，单位为秒
   
   + refresh_token：表示更新令牌，用来获取下一次令牌(如果原本access_token过期了，服务方在你仍携带它和这个refresh_token找它要服务要数据时，它看你带着这个refresh_token和自己的client_id，一查，在它数据库那里记录还有效没过期，就可以继续给你第三方颁发个新的access_token)
   
   + scope：表示权限范围，如果与客户端申请的范围一致，可以省略。(就是步骤1，打算最后找Auth Server要多少关于授权的用户的服务、数据、权限等)
   ```

> [微信开发文档](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)
>
> [关于 OAuth2.0 安全性你应该要知道的一些事](https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html)
>
> [Oauth2.0详解及安全使用](https://www.cnblogs.com/maoxiaolv/p/5838680.html)
>
> [Refresh_token机制](https://blog.csdn.net/shilihuakai/article/details/102750261)
>
> Refresh_token的作用是刷新AccessToken。认证服务器会提供一个刷新接口，我们传入Refresh_token和client_id，认证服务器通过后会返回一个新的AccessToken。但是为了安全，Oauth2.0引入了两个措施：
> 1，要求refresh_token必须保存在客户端的服务器上，调用refresh_token的时候一定是从服务器到服务器的访问。
> 2，OAuth2引入了Client_Secret机制。每一个Client_id,都对应一个Client_Secret。这个Client_Secret会在客户端申请Client_id时，随Client_id一起分配给客户端。客户端把他们都保存在服务器上，刷新Refresh_token时，需要验证这个Client_Secret。
>
> [理解 OAuth2.0](https://www.cnblogs.com/leeyongbard/p/10539599.html)
>
> + **OAuth2.0的`code`只能使用一次，这可有效防止中间人攻击**。因为中间人提前用了，会导致用户携带`code`的重定向获取`access_token`失败，用户必定会重新申请一次来获取`access_token`，这导致中间人携带`code`从服务提供者那换来的`access_token`立马就失效了；如果中间人比用户晚用截获的`code`了，那么用户会被后面中间人获取的`access_token`挤下线，用户莫名下线，马上又会重新授权又获取`access_token`，把中间人挤下线。
> + `secret`用于确保申请用户授权的是在服务提供者那注册过的（注册过的当然知道secret是多少，这个保密的，不让外界知道，用`code`找服务提供者换取`access_token`时需要给服务提供者，让其验证确实是在它那里登记过的第三方开发者要兑换`access_token`。**第三方获取到用户授权后得以从`Auth Server`那返回的`code`之后<small>（第三方获取`code`之后）</small>，第三方直接<small>(不用再经过我们这些用户确认啥的，无感知)</small>携带`code`和`secret`向`Auth Server`申请`access Token`**<small>（`secret`是所有步骤之前，第三方就先得到`Auth Server`指定平台上注册获得的）</small>。
> + `state`和`secret`类似作用，`state`是允许给第三方授权申请的用户携带第三方应用给自己的`state`向服务提供者申请要`code`时校验的<small>（也就是`state`是第三方给我们的一个标识，在第三方将我们重定向去授权访问`Auth Server`的请求，和授权后`Auth Server`响应携带`code`将重定向我们回第三方应用时存在，对应上图步骤2和3）</small>。**第三方应用必须确保自己有方式能够验证`state`和当初点击要授权账号的用户是同一个人。**
>   + 假设`state`参数无用：中间人携带`state`授权后`Auth Server`重定向回第三方的时候，故意阻断重定向（这时候第三方不知道，所以第三方没有拿到中间人授权后取回的`code`）。中间人自己拿着这个携带`code`的URL链接让受害者访问，等于让受害者完成原本<small>被中间人</small>中断的携带`code`重定向回第三方的过程。中间人想让第三方以为这个`core`就是受害者的，其实这个受害者等于现在用的中间人身份，受害者本人不知道，可能会在第三方程序上传一些隐私数据（等于给中间人的账号上添加信息了）。以后中间人就重新用自己的身份上线第三方应用就可以获取到受害者隐私数据。（CSRF攻击）
>   + 启用`state`参数：不管是谁使用该第三方应用，第三方应用都应该给出不一样的、能够区分各个用户的`state`。比如受害者A每次都是用QQ-1号来授权第三方使用自己QQ的部分服务，那么第三方应该根据该QQ-1号，每次给相同的`state`参数，让其携带着重定向到`Auth Server`申请`code`，之后`Auth Server`返回`code`的时候也会顺带这个`state`，让第三方知道是同一个人，也就是整个获取`code`的流程都是由受害者申请和获取到`code`的，没有他人干涉。这种情况下，根据前面CSRF攻击，由于中间人的`state`和当前受害者的信息不相符，所以就算受害者点击链接，把中间人重定向回第三方的`state`和`code`交给了第三方，由于第三方对`state`进行校验，发现上次申请的用户的一些电脑参数信息等和上次的不符合，所以拒绝该`state`<small>（这里点击链接，虽然链接上带有`state`和`core`参数，但是第三方必须确保验证用户和`state`的匹配不是单纯靠URL上的参数，比如说用户第一次携带`state`重定向到`Auth Server`时给客户端写入一个临时的cookie标记用户或者给用户发一个临时的token存在浏览器之类的。）</small>。这样就阻止了CSRF攻击。

#### 7.5.4 XSS攻击

> [XSS攻击--百度百科]([https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin](https://baike.baidu.com/item/XSS攻击/954065?fr=aladdin))
>
> XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。
>
> <small>人们经常将跨站脚本攻击（Cross Site Scripting）缩写为CSS，但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。</small>

**原理**：

HTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（<）被看作是HTML标签的开始，\<title>与\</title>之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如<）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。

**类型**：

从攻击代码的工作方式可以分为三个类型：

（1）持久型跨站：最直接的危害类型，跨站代码存储在服务器（数据库）。

（2）非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。

（3）DOM跨站（DOM XSS）：DOM（document object model文档对象模型），客户端脚本处理逻辑导致的安全问题。

基于DOM的XSS漏洞是指受害者端的网页脚本在修改本地页面DOM环境时未进行合理的处置，而使得攻击脚本被执行。在整个攻击过程中，服务器响应的页面并没有发生变化，引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用。

**常见防范手段**：

- 首先是过滤。对诸如\<script>、\<img>、\<a>等标签进行过滤。
- 其次是编码。像一些常见的符号，如\<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。
- 最后是限制。通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。

**XSS总结：黑客想办法往前端嵌入代码/指令，使得受害者无意间执行某些代码/指令。**（不一定针对受害者本身）

> [什么是XSS攻击？如何防御XSS攻击？](https://baijiahao.baidu.com/s?id=1653681087434824406&wfr=spider&for=pc)
>
> [浅谈XSS攻击的那些事（附常用绕过姿势）](https://zhuanlan.zhihu.com/p/26177815)
>
> 归根结底，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。
>
> + 避免cookie被窃取：Cookie设置Http-Only。

#### 7.5.5 CSRF攻击

> [跨站请求伪造--百度百科]([https://baike.baidu.com/item/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0?fromtitle=CSRF&fromid=2735433](https://baike.baidu.com/item/跨站请求伪造?fromtitle=CSRF&fromid=2735433))
>
> **跨站请求伪造**（英语：Cross-site request forgery），也被称为 **one-click attack** 或者 **session riding**，通常缩写为 **CSRF** 或者 **XSRF**， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟[跨网站脚本](https://baike.baidu.com/item/跨网站脚本)（XSS）相比，**XSS** 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

**常见防范手段**：

1. 尽量使用POST，限制GET
   GET接口容易被拿来做CSRF攻击，只要构造一个`img标签`并在`src`属性加入捏造的HTTP请求就可完成攻击。由于`img标签`一般是不能过滤的数据，所以安全性要求高的接口最好限制为POST使用，GET则无效，降低攻击风险。
   当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，但这样就增加暴露的可能性。

2. 将cookie设置为HttpOnly

   CRSF攻击很大程度上是利用了浏览器的cookie，为了防止站内的XSS漏洞盗取cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。
   在Java的Servlet的API中设置cookie为HttpOnly的代码如下：
   `response.setHeader( "Set-Cookie", "cookiename=cookievalue;HttpOnly");`

3. 增加token
   CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：**在请求中放入攻击者所不能伪造的信息，并且该信息不存在于cookie之中**。鉴于此，系统开发人员可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求。
   假设请求通过POST方式提交，则可以在相应的表单中增加一个隐藏域：
   `<input type="hidden" name="_toicen" value="tokenvalue"/>`
   token的值通过服务端生成，表单提交后token的值通过POST请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者因无法获取到token，也就无法伪造请求。
   在session中添加token的实现代码：

   ```java
   HttpSession session = request.getSession();
   Object token = session.getAttribute("_token");
   if(token == null || "".equals(token)) {
       session.setAttribute("_token", UUID.randomUUIDO .toString());
   }
   ```

4. 通过Referer识别
   根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问`http://www.xxx.com/transfer.do`页面完成的，用户必须先登录`www.xxx.com`，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的URL（本例为[www.xxx](https://link.jianshu.com?t=http%3A%2F%2Fwww.xxx). com/[transfer.do](https://link.jianshu.com?t=http%3A%2F%2Ftransfer.do)）。如果攻击者要对银行网站实施CSRF攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的Referer的值是其他网站的地址，而不是银行转账页面的地址。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值即可，如果是以`www.xx.om`域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的；如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。
   取得HTTP请求Referer：
   `String referer = request.getHeader("Referer");`

**CSRF总结：黑客想办法往前端嵌入代码/指令，使得受害者以自己独有的身份无意间执行某些代码/指令。**（一般针对受害者本身，主要以盗用受害者身份进行非法操作来谋利，身份信息一般从cookie中盗用）

> [安全|常见的Web攻击手段之CSRF攻击](https://www.jianshu.com/p/67408d73c66d)

#### 7.5.6 DNS污染

> [什么是DNS污染？DNS污染怎么解决？](https://zhuanlan.zhihu.com/p/101908711)
>
> [DNS污染--百度百科]([https://baike.baidu.com/item/DNS%E6%B1%A1%E6%9F%93/8620359?fr=aladdin](https://baike.baidu.com/item/DNS污染/8620359?fr=aladdin))

​	**网域服务器缓存污染**（DNS cache pollution），又称**域名服务器缓存投毒**（DNS cache poisoning），是指一些刻意制造或无意中制造出来的域名服务器[数据包](https://baike.baidu.com/item/数据包)，把域名指往不正确的IP地址。一般来说，在[互联网](https://baike.baidu.com/item/互联网)上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。

​	某些[网络运营商](https://baike.baidu.com/item/网络运营商)为了某些目的，对[DNS](https://baike.baidu.com/item/DNS/427444)进行了某些操作，导致使用[ISP](https://baike.baidu.com/item/ISP/10152)的正常上网设置无法通过域名取得正确的IP地址。

某些国家或地区出于某些目的为了防止某网站被访问，而且其又掌握部分国际DNS根目录服务器或镜像，也会利用此方法进行屏蔽。

常用的手段有：[DNS劫持](https://baike.baidu.com/item/DNS劫持)和DNS污染。

*<small>(吐槽：github系列的网站，时不时就有BGP劫持、DNS污染等问题)</small>*

> [使用dnscrypt解决dns污染问题](https://jingyan.baidu.com/article/455a995085dfc7a16727785d.html)
>
> `ipconfig /flushdns`清空本地DNS缓存后，再配合DNSCrypt使用安全的DNS解析服务。亲测有效，终于能访问自己的github笔记了。（可以再用`nslookup`检测下`github.io`的DNS解析记录，会发现恢复正常，不再是127.0.0.1）

#### 7.5.7 Hash洪流攻击

> [什么是哈希洪水攻击（Hash-Flooding Attack）？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/286529973/answer/676981827)
>
> [漫谈非加密哈希算法 - SegmentFault 思否](https://segmentfault.com/a/1190000010990136)

严格意义上，hash洪流攻击并非网络相关的攻击，但是也是常见的应用层能想到的网络应用攻击手段。

编程语言一般支持类似HashMap的数据结构，而一般对key进行hash，当key的hash值冲突时，会用链表、红黑树等数据结构来存储hash值一致的key对应的value值。

**攻击方式**：

当攻击者（以某种方式）知道被攻击方使用的hash算法时，则故意生成大量hash值一致的值，向被攻击方发起请求，使得被攻击方的HashMap一直处于hash冲突状态，使得服务端hashMap查询效率急剧下降，进而请求超时，占用大量服务器请求线程（大量线程处理请求超时），服务器无法腾出线程为其他正常用户处理请求。

**常见预防方式**：

使用诸如SipHash等带有加密性质的Hash算法，使得攻击者在仅知道hash算法但不知道加密密钥的情况下无法轻易造成hash-flooding攻击。

*ps：但是使用这类hash算法，计算hash值的耗时会相对高一点，需要酌情使用。*

### 7.6 传输层安全

#### 7.6.1 SSL和TLS概述

> [什么是 SSL 和 TLS 协议？](https://zhidao.baidu.com/question/57526226.html)
>
> [图解SSL/TLS协议](https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
>
> [ssl--百度百科](https://baike.baidu.com/item/ssl)
>
> SSL(Secure Sockets Layer [安全套接字协议](https://baike.baidu.com/item/安全套接字协议)),及其继任者[传输层安全](https://baike.baidu.com/item/传输层安全)（Transport Layer Security，TLS）是为[网络通信](https://baike.baidu.com/item/网络通信/9636548)提供安全及[数据完整性](https://baike.baidu.com/item/数据完整性/110071)的一种安全协议。TLS与SSL在[传输层](https://baike.baidu.com/item/传输层/4329536)与应用层之间对网络连接进行加密。
>
> [TLS--百度百科](https://baike.baidu.com/item/TLS/2979545?fr=aladdin)
>
> 安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。
>
> 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS [握手协议](https://baike.baidu.com/item/握手协议/4058729)（TLS Handshake）。
>
> [Transport Layer Security (TLS)](https://developer.mozilla.org/en-US/docs/Glossary/TLS)

概述：

​	在发送方，SSL接受应用层的数据（如HTTP或IMAP报文），对数据进行加密，然后把加了密的数据送往TCP套接字。

​	在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。

常见的使用SSL的应用层服务开放的端口：

+ imaps——tcp+993
+ pop3s——tcp+995
+ smtps——tcp+465
+ https——tcp+443

#### 7.6.2 SSL功能

1. SSL服务器鉴别：

   ​	允许用户证实服务器的身份。具有SSL功能的浏览器维护一张表，上面有一些可信赖的**认证中心CA**（Certificate Authority）和它们的公钥。

2. 加密的SSL会话：

   ​	客户和服务器交互的所有数据都在发送方加密，在接受方解密。

3. SSL客户鉴别：

   ​	允许服务器证实客户的身份。

建立安全连接，常见的安全警报：

1. 该安全证书由您没有选定信任的公司颁发。可以查看证书以便确定您是否信任该验证机构。
   + 主机上的证书管理界面，误删了对应的CA证书，导致计算机认为该CA证书无有效来源。
   + CA证书是该站点自己给自己颁发的，不是来自主机信任的CA机构（计算机自己有配置一些公信的CA机构）
   + ......

2. 该安全证书已到期或还未生效。
   + 证书都是有时限的，证书已过期失效。
   + ......
3. 安全证书上的名称无效，或者与站点名称不匹配。
   + 证书绑定的是域名1，但是你通过域名2访问同一个网站；
   + 证书绑定的是域名，但是你直接输入IP地址访问；
   + 有人冒用证书
   + ......

*<small>（SSL服务器鉴别，就是建立会话前出示CA证书，这个**CA证书和域名绑定**，并且有一些企业的注册信息。而有些网站也会要求SSL客户端鉴别，那用户也必须出示证书，服务器才会允许和用户建立会话。）</small>*

*<small>（注意，如果证书填写的域名和实际安装CA证书的域名所在服务器不同，那么用户通过浏览器试图与其建立安全连接时，浏览器会警告用户，其预建立连接的web站点的域名和CA证书上注册的域名不相符。通常有这类警告，可能就是钓鱼网站。）</small>*

#### 7.6.3 SSL证书类别(DV/OV/EV)

> [SSL证书的类型有哪几种?](https://zhidao.baidu.com/question/1305558963166709579.html)

“SSL证书”类型不同，支持域名数量不同，从支持的域名数量来说，SSL证书分为：

1. 单域名：仅支持一个域名使用;
2. 多域名：支持多个顶级域名完全不同的域名使用，比如 `http://a.domain.com` 和`http://b.domain.com`要算作2个域名;
3. 泛域名：支持`*.http://domain.com`通配符子域名，且不限制该级子域名数量。

从**信任等级**的角度来说，SSL证书主要分为三类：

1. 域名型https证书(DV SSL)：信任等级一般，只需验证网站的真实性便可颁发证书保护网站;
2. 企业型https证书(OV SSL)：信任等级高，须要验证企业的身份，审核严格，安全性更强;
3. 增强型https证书(EV SSL)：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最好，同时可以激活绿色网址栏。

#### 7.6.4 SSL建立会话

> [HTTPS中CA证书的签发及使用过程](https://www.cnblogs.com/xdyixia/p/11610102.html)
>
> [ssl 原理和建立连接过程](https://www.cnblogs.com/fengfengyang/p/9852481.html)
>
> [图解SSL/TLS协议](https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

![img](https://www.ruanyifeng.com/blogimg/asset/2014/bg2014092002.png)

```none
第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。

第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。

第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。

第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。

第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。
```

上面这是早期的SSL连接，后来还有在握手过程结合DH算法完成交换密钥的。

![img](https://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png)

> [Diffie-Hellman算法--百度百科](https://baike.baidu.com/item/Diffie-Hellman/9827194?fr=aladdin)
>
> 这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实现加密和解密消息。

#### 7.6.5 TLS建立会话

> [TLS--百度百科](https://baike.baidu.com/item/TLS/2979545?fr=aladdin)
>
> 安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。
>
> 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS [握手协议](https://baike.baidu.com/item/握手协议/4058729)（TLS Handshake）。
>
> [TLS详解](https://www.jianshu.com/p/1fc7130eb2c2)
>
> TLS协议主要解决如下三个网络安全问题：
>
> 1. 保密(message privacy)，保密通过加密encryption实现，所有信息都加密传输，第三方无法嗅探；
> 2. 完整性(message integrity)，通过MAC校验机制，一旦被篡改，通信双方会立刻发现；
> 3. 认证(mutual authentication)，双方认证,双方都可以配备证书，防止身份被冒充；

​	TLS其实就是基于SSL3.0之后改进的，比其SSL，TLS更健壮。（由于一些历史原因，一般也不会特地把TLS和SSL区分开，比如证书一般也还是说SSL证书）。

​	*<small>在交换过程中使用的[公钥](https://baike.baidu.com/item/公钥)/[私钥](https://baike.baidu.com/item/私钥)加密[密钥](https://baike.baidu.com/item/密钥)的长度和在交换协议过程中使用的公钥证书也各不相同，因而提供的**强健性**的安全。2013年7月，[Google](https://baike.baidu.com/item/Google)宣布向其用户提供的TLS加密将不再使用1024位公钥并切换到2048位，以提高安全性。</small>*

1. **记录协议（TLS Record）**

   通过使用客户端和服务端协商后的秘钥进行数据加密传输。

2. **握手协议（Handshake Protocol）**
   客户端和服务端进行协商，确定一组用于数据传输加密的秘钥串。

**TLS记录协议**：

![img](https://upload-images.jianshu.io/upload_images/3742190-0fdda24fb9133f28.png?imageMogr2/auto-orient/strip|imageView2/2/w/786/format/webp)

**TLS握手过程**：

![img](https://upload-images.jianshu.io/upload_images/3742190-f19152b9a63fe9d6.png?imageMogr2/auto-orient/strip|imageView2/2/w/567/format/webp)

实际抓包的TLS建立连接过程如下：（访问`https://www.baidu.com`)

```none
No.  Times       Source         Destination    Protocol Length  Info
401	5.084212	192.168.1.103	163.177.151.109	TLSv1.2	262	Client Hello
403	5.113482	163.177.151.109	192.168.1.103	TLSv1.2	122	Server Hello
406	5.113482	163.177.151.109	192.168.1.103	TLSv1.2	935	Certificate
409	5.116360	163.177.151.109	192.168.1.103	TLSv1.2	392	Server Key Exchange
410	5.116360	163.177.151.109	192.168.1.103	TLSv1.2	63	Server Hello Done
414	5.123378	192.168.1.103	163.177.151.109	TLSv1.2	180	Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message
415	5.123775	192.168.1.103	163.177.151.109	TLSv1.2	763	Application Data
417	5.146319	163.177.151.109	192.168.1.103	TLSv1.2	229	New Session Ticket
418	5.146319	163.177.151.109	192.168.1.103	TLSv1.2	60	Change Cipher Spec
419	5.146319	163.177.151.109	192.168.1.103	TLSv1.2	99	Encrypted Handshake Message

##之后下面就是数据交互了

427	5.525133	163.177.151.109	192.168.1.103	TLSv1.2	1203	Application Data
428	5.525133	163.177.151.109	192.168.1.103	TLSv1.2	179	Application Data
```

​	其实如果不注重细节的话，SSL/TLS做的最关键的事情就是，**通过非对称加密传输了协商后的对称加密密钥，之后数据则通过协商后的对称密钥加密传输**。由于TLS连接建立后，双方数据可以用协商后的对称密钥加密，所以中间人攻击必须从TLS握手阶段开始，相对成功率就更低了(毕竟中间人想截获流量，也必须要能收到流量才行。中间人所能监听到的路由范围不一定是用户和服务器的数据包所经过的)。

> [Github 中间人攻击原理分析](https://zhuanlan.zhihu.com/p/119030756)
>
> 据猜测是BGP劫持。（毕竟ARP欺骗只能本网段，BGP才是跨AS的，换言之BGP劫持才能做到跨网段的IP欺骗）。不过BGP劫持，就算网络层安全的范畴了。
>
> [Facebook流量又被BGP劫持至俄罗斯](https://zhuanlan.zhihu.com/p/126274831)
>
> 一般情况下AS都是归ISP或政府机构管理的，所以一般人要实现BGP劫持还不大可能，因为必须先劫持AS的"**BGP发言人**"。

> [在SSL中，为什么要有一个单独的修改密码规范协议，而不是在握手协议中包含change_cipher_spec报文](https://zhidao.baidu.com/question/55082076.html)
>
> 因为SSL规定通信双方直到他们发送或收到更改密码规格协议信息时才能开始使用前面已经协商好的密码套件。这个协议只是一个开始使用加密的标志，它应该是握手协议完成的表现。
>
> [证书的应用之一 —— TCP&SSL通信实例及协议分析(中)](https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html)
>
> 有详细抓包解析过程，建议阅读。
>
> 大致流程还是（下面不是严格按照一个一个包的顺序拆分步骤的。只说明一些重点步骤）：
>
> 客户端->服务器（生成对称密钥的参数随机值1、可使用的算法清单）；
>
> 服务器->客户端（生成对称密钥的参数随机值2、从客户端算法清单中选择非对称加密-对称加密-单向散列Hash算法、证书-带有公钥和一些信息）；
>
> 客户端->服务器（根据前两次参数随机值1、2，以及自己再生成一个随机值3，使用服务器证书的public key加密）；
>
> 上面3个大致的过程，实际抓包还是有细分更小的步骤的。经过粗制拆分的第三步骤后，客户端和服务器都能获得之后数据加密用的对称密钥；同时如果有计算Session ID、Session ticket的需求，也是通过上诉的随机值和协商要使用的算法来计算的。

### 7.7 网络层安全

#### 7.7.1 IPSec概述

> [ipsec--百度百科](https://baike.baidu.com/item/ipsec/2472311?fr=aladdin)
>
> （英语：Internet Protocol Security，缩写为IPsec），是一个协议包，通过对[IP协议](https://baike.baidu.com/item/IP协议)的[分组](https://baike.baidu.com/item/分组)进行[加密](https://baike.baidu.com/item/加密)和[认证](https://baike.baidu.com/item/认证)来保护IP协议的[网络传输协议](https://baike.baidu.com/item/网络传输协议)族（一些相互关联的协议的集合）。
>
> IPsec协议工作在[OSI模型](https://baike.baidu.com/item/OSI模型)的第三层，使其在单独使用时适于保护基于[TCP](https://baike.baidu.com/item/TCP)或[UDP](https://baike.baidu.com/item/UDP)的协议（**如安全套接子层（[SSL](https://baike.baidu.com/item/SSL)）就不能保护UDP层的通信流**）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。相对而言，[SSL](https://baike.baidu.com/item/SSL)/[TLS](https://baike.baidu.com/item/TLS)依靠更高层的[TCP](https://baike.baidu.com/item/TCP)（OSI的第四层）来管理可靠性和分片。

​	*<small>回顾应用层安全，基本就是应用程序对数据的加密解密以及用户授权/鉴权；而传输层安全可借用位于传输层和应用层之间的SSL/TLS进行密钥协商和数据加密（中间还涉及Session ID和Session Ticket，用于快速恢复安全连接，而不用重复握手），整个过程无需开发人员在应用层或传输层进行干涉<--特指TCP开发，UDP的话如果要用证书，还是得手动编写相关的SSL握手过程等代码。毕竟TCP/IP由系统内核实现，运行于内核态，而我们苦逼的UDP用户态，虽然更灵活，但是需要手动开发的东西就更多了。</small>*

​	IPSec是在网络层就对数据加密或者签名。这样别人就算截获了也看不懂，或者篡改了也能被发现。

​	网络层安全对用户透明。

*<small>（这样就算网络层以上的传输层、应用层没有加密，由于网络传输时只用到下三层，而下三层最高一层的网络层加密了，那么网络传输的数据就是加密过了的）</small>*

​	IPSec类似加密电话。加密电话需要在把声波模拟信号转换成数字信号后按照既定的方式再加密传输，这样中间就算有人监听了，由于不知道特定的解密方式，转换成声波模拟信号后听上去就和杂乱的噪音没什么区别。（比如线下协商码分复用的码型，或者直接用对称密钥加密数字信号数据...）

​	IPSec的加密解密在网卡进行，双方应用无感知。*<small>（换言之，就是操作系统帮你协调调度，完成加密解密）</small>*

#### 7.7.2 安全关联SA(Security Association)

​	在使用AH或ESP之前，先要从源主机到目的主机建立一条网络层的逻辑连接。此逻辑连接叫作**安全关联SA**。

​	IPsec把传统的因特网无连接的网络层转换成具有逻辑连接的层。

​	<u>SA（安全关联）是够成IPsec的基础，是两个通信实体经协商（利用IKE协议）建立起来的一种协议，它决定了用来保护数据分组安全的安全协议（AH协议或者ESP协议）、转码方式、密钥及密钥的有效存在时间等</u>。

​	*（SA主要作用就是协商两方保护数据的方式：只要签名，还是签名+加密，然后密钥多久刷新一次等等）*

​	*（**只签名——> AH；签名+加密——>ESP**）*

#### 7.7.3 IPsec最主要的协议

+ **鉴别首部AH**（Authentication Header）：AH鉴别源点和检查数据完整性，但不能保密。
+ **封装安全有效载荷ESP**（Encapsulation Security Payload）：ESP比AH复杂得多，它鉴别源点、检查数据完整性和提供保密。

从功能上看，可以大致认为：AH签名；ESP签名+加密。

> [ipsec(AH和ESP)](https://blog.csdn.net/lyg920/article/details/51658295/)

#### 7.7.4 鉴别首部协议AH

​	在使用鉴别首部协议AH时，把**AH首部插在原数据报数据部分的前面**，同时把IP首部中的**协议字段置为51**。

​	在传输过程中，**中间的路由器都不查看AH首部**。当数据报到达终点时，目的主机才处理AH字段，以鉴别源点和检查数据报的完整性。

```none
[IP首部-协议号=51][AH首部][TCP/UDP报文段]

[原IP报头][IPSec(AH)报头][传输层报头TCP/UDP][应用程序数据]
```

<table style="text-align:center;vertical-align:middle;">
    <tr>
    	<th>0~7bit</th>
        <th>8~15bit</th>
        <th>16~23bit</th>
        <th>24~31bit</th>
    </tr>
    <tr>
    	<td>下一个首部</td>
    	<td>有效负载长度</td>
    	<td colspan="2" >保留</td>
    </tr>
    <tr>
    	<td colspan="4" >安全参数索引SPI</td>
    </tr>
    <tr>
    	<td colspan="4" >序列号</td>
    </tr>
    <tr>
    	<td colspan="4" >鉴别数据(可变)</td>
    </tr>
</table>

字段含义：

- 下一个首部（下一个头）：表示紧跟在AH头部后面的协议类型。在传输模式下，该字段是处于保护中的传输层协议的值，如6（TCP），17（UDP）或50（ESP）。在隧道模式下，AH保护整个IP包，该值是4，表示是IP-in-IP协议。
- 有效负载长度（载荷长度）：认证头包的大小。其值是以32位（4字节）为单位的整个AH数据（包括头部和变长验证数据）的长度再减2。
- 保留：准备将来对AH协议扩展时使用，目前协议规定这个字段应该被置为0。
- 安全参数索引SPI：与IP地址一同用来标识安全参数，值为[256,2^32-1]。实际上它是用来标识发送方在处理IP数据包时使用了哪些安全策略，当接收方看到这个字段后就知道如何处理收到的IPsec包。
- 序列号（串行号）：一个单调递增的计数器，为每个AH包赋予一个序号。当通信双方建立SA时，初始化为0。SA是单向的，每发送/接收一个包，外出/进入SA的计数器增1。该字段可用于抗重放攻击。
- 鉴别数据（认证数据）：可变长，取决于采用何种消息验证算法。包含完整性验证码，也就是HMAC算法的结果，称为ICV，它的生成算法由SA指定。

AH是在网络层和传输层之间插入了一个AH首部；

AH首部里的SPI是通讯两方协商的，协商后就固定了。

AH首部里的鉴别数据就是鉴别数据报有没有被改动过，充当数字签名的作用。

#### 7.7.5 封装安全有效载荷ESP

​	使用ESP时，IP数据报首部的**协议字段置为50**，当IP首部检查到协议字段是50时，就知道在IP首部后面紧接着的是ESP首部，同时**在原IP数据报后面增加了两个字段，即ESP尾部和ESP数据**。

```none
              |<---------鉴别的部分---------->|
                      |<-----加密的部分------>|
[IP首部-协议=50][ESP首部][TCP/UDP报文段][ESP尾部][ESP鉴别]
                      |原数据报数据部分|
|<-----------------使用ESP的IP数据报------------------>|

ESP首部存放之前协商的SPI;序号
ESP尾部标识数据报的协议类别
ESP鉴别存放ESP对鉴别的部分的鉴别结果(对方收到后再更根据"ESP鉴别"字段验证"鉴别的部分"是否被更改)
```

<table style="text-align:center;vertical-align:middle;">
    <tr>
    	<th>0~7bit</th>
        <th>8~15bit</th>
        <th>16~23bit</th>
        <th>24~31bit</th>
    </tr>
    <tr>
    	<td colspan="4" >安全参数串行(SPI)</td>
    </tr>
    <tr>
    	<td colspan="4" >串行号</td>
    </tr>
    <tr>
    	<td colspan="4" >载荷(可变长度)</td>
    </tr>
    <tr>
    	<td></td>
    	<td colspan="3" >填充(可变长度)</td>
    </tr>
    <tr>
    	<td colspan="2"></td>
    	<td>填充长度</td>
    	<td>下一个头</td>
    </tr>
    <tr>
    	<td colspan="4" >认证数据(可变长度)</td>
    </tr>
</table>

字段含义：

- 安全参数索引SPI：与IP地址一同用来标识安全参数，值为[256,2^32-1]。
- 串行号：单调递增的数值，用来防止重放攻击。
- 载荷数据：实际要传输的数据，是变长的字段，如果SA采用加密，该部分是加密后的密文；如果没有加密，该部分就是明文。
- 填充：某些块加密算法用此将数据填充至块的长度。是可选的字段，为了对齐待加密数据而根据需要将其填充到4字节边界。
- 填充长度：以字节为单位指示填充项长度，范围为[0，255]。保证加密数据的长度适应分组加密算法的长度，也可以用以掩饰载荷的真实长度对抗流量分析。
- 下一个头：表示紧跟在ESP头部后面的协议，其中值为6表示后面封装的是TCP。
- 认证数据：包含了认证当前包所必须的数据。是变长字段，只有选择了验证服务时才需要有该字段。

#### 7.7.6 AH和ESP的异同点

​	IPSec的子协议头认证协议AH，为IP报文提供数据完整性验证和数据源身份认证，使用的是HMAC算法，HMAC算法和非常相似，一般是由Hash算法演变而来，也就是将输入报文和双方事先已经共享的对称密钥结合然后应用Hash算法。采用相同的HMAC算法并共享密钥的双方才能产生相同的验证数据。所有的IPSec必须实现两个算法：HMAC-MD5和HMAC-SHA1. 

​	ESP协议提供数据完整性验证和数据源身份认证的原理和AH一样，只是和AH比ESP的验证范围要小些。ESP协议规定了所有IPSec系统必须实现的验证算法：HMAC-MD5，HMAC-SHA1，NULL。和L2TP，GRE，AH等其他轨道技术相比，ESP具有特有的安全机制——加密，而且**可以和其他隧道协议结合使用**，为用户的远程通信提供更强大的安全支持。ESP加密采用的则是对称加密算法，它规定了所有IPSec系统必须实现的加密算法是DES-CBC和NULL，使用NULL是指实际上不进行加密或验证。

​	AH和ESP的最大区别有两个：一个是**AH不提供加密服务**，另一个是它们验证的范围不同，**ESP不验证IP报头，而AH同时验证部分报头**，所以需要结合使用AH和ESP才能保证IP报头的机密性和完整性。**AH为IP报头提供尽可能多的验证保护，验证失败的包将被丢弃，不交给上层协议解密，这种操作模式可以减少拒绝服务攻击成功的机会**。

​	<u>很多情况下，AH的功能已经能满足安全的需要，ESP由于需要使用高强度的加密算法，需要消耗更多的计算机运算资源，使用上受到一定限制。</u>

​	<u>在IPSec协议簇中使用两种不同功能的协议使得IPSec具有对网络安全细粒度的功能选则，便于用户依据自己的安全需要对网络进行灵活配置。</u>

#### 7.7.7 身份验证与AH

​	**AH通过对报文应用一个使用密钥的单向散列函数来创建一个散列或消息摘要来进行身份验证**。散列与文本合在一起传输。接收方对接收到的报文运用同样的单向散列函数并将结果与发送方提供的消息摘要的值比较，从而检测报文在传输过程中是否有部分发生变化。由于单向散列也包含两个系统之间的一个共享密钥，因此能确保真实性。 
​	AH作用于整个报文，但任意会在传输中改变的IP头字段除外。例如，由沿传输路径的路由器修改的生存时间（Time to Live, TTL）字段是可变字段。

AH的处理过程顺序如下：
	步骤1，使用共享密钥对IP头和数据载荷进行散列。 
	步骤2，散列构建一个新的AH头，插入到原始报文中。 
	步骤3，新报文路由器使用共享密钥对IP头和数据载荷进行散列，从AH头中取出传输的散列，再比较两个散列。

散列值必须精确匹配。如果报文传输中有一个比特位发生了变化，则接收到的报文的散列输出将改变，AH头将不能匹配。

AH支持HMAC-MD5和HMAC-SHA-1算法。**在使用NAT的环境中，AH可能会遇到问题**。

#### 7.7.8 使用ESP进行身份验证与加密

​	ESP通过加密载荷实现机密性，它支持多种对称加密算法。如果选择了ESP作为IPSec协议，也必须选择一种加密算法。IPSec的默认算法是56位DES。

​	ESP也能提供完整性和认证。首先对载荷加密，然后对加密过的载荷使用一种散列算法（HMAC-MD5或HMAC-SHA-1）。散列为数据载荷提供认证和数据完整性。

​	作为可选功能，ESP还能进行防重放保护。防重放保护验证每个报文是唯一的且没有被复制，这种保护确保黑客不能拦截报文和在数据流中插入改变后的报文。防重放的工作原理是跟踪报文顺序号并在目的端使用一个滑动窗口。当在源和目的间建立了一条连接时，两端的计数器被初始化为0。每次有报文发送时，源给报文追加一个顺序号，目的端使用滑动窗口确定预期的顺序号。目的端验证的报文的顺序号不是复制的，并且以正确的顺序被接收。例如，如果目的端的滑动窗口设为1，目的端期望接收到顺序号为1的报文。收到这样的报文后，滑动窗口进入到2。如果检测到重放的报文，重放报文将被丢弃，对此事件记录日志。

​	原始数据通过ESP得到良好保护，因为**完整的原始IP数据报和ESP附加尾部都被加密**。使用ESP认证，加密的IP数据报和附加尾部以及ESP头都得到散列进程处理。最后，一个新的IP头被附加到经过认证的载荷，使用新的IP地址在Internet中路由报文。

​	**如果同时选择了认证和加密，先执行加密。这种处理顺序的一个原因是它有助于接收设备快速检测和丢弃重放的或伪造的报文。在解密报文之前，接收方可以认证进入的报文。这样可以快速检测到问题，并间接的降低了DoS攻击的影响。**

#### 7.7.9 IPSec的优点/安全特性

1. 节约成本和网络管理
2. IPSec隧道可以用来创建安全的网络
3. IPSec隧道可以用来安全的远程管理
4. 确保安全通信的认证和机密性
5. 数据包认证提高了地址伪造与地址欺骗攻击的难度
6. 通过non-end-to-end服务，IPSec可以确保一对一或一组站点之间的消息都是加密的

IPSec的安全特性主要有：

+ 不可否认性

  "不可否认性"可以证实消息发送方是唯一可能的发送者，发送者不能否认发送过消息。"不可否认性"是采用公钥技术的一个特征，当使用公钥技术时，发送方用[私钥](https://baike.baidu.com/item/私钥)产生一个[数字签名](https://baike.baidu.com/item/数字签名)随消息一起发送，接收方用发送者的公钥来验证数字签名。由于在理论上只有发送者才唯一拥有[私钥](https://baike.baidu.com/item/私钥)，也只有发送者才可能产生该[数字签名](https://baike.baidu.com/item/数字签名)，所以只要数字签名通过验证，发送者就不能否认曾发送过该消息。但"不可否认性"不是基于认证的共享[密钥](https://baike.baidu.com/item/密钥)技术的特征，因为在基于认证的共享密钥技术中，发送方和接收方掌握相同的密钥。

+ 反重播性

  "反重播"确保每个IP包的唯一性，保证信息万一被截取复制后，不能再被重新利用、重新传输回目的地址。该特性可以防止攻击者截取破译信息后，再用相同的[信息包](https://baike.baidu.com/item/信息包)冒取非法访问权（即使这种冒取行为发生在数月之后）。

+ 数据完整性

  防止传输过程中数据被篡改，确保发出数据和接收数据的一致性。IPSec利用Hash函数为每个数据包产生一个加密检查和，接收方在打开包前先计算检查和，若包遭篡改导致检查和不相符，数据包即被丢弃。

+ 数据可靠性

  在传输前，对数据进行加密，可以保证在传输过程中，即使数据包遭截取，信息也无法被读。该特性在IPSec中为可选项，与IPSec策略的具体设置相关。

> [ipsec(AH)和ESP](https://blog.csdn.net/lyg920/article/details/51658295/)
>
> [ipsec--百度百科](https://baike.baidu.com/item/ipsec/2472311?fr=aladdin)

### 7.8 数据链路层安全

#### 7.8.1 概述

​	之前的IPsec网络层安全，就点到点，网卡发送前加密，另一头网卡收到时解密，中间路由器不参与加密解密。

​	而数据链路层安全，每段链路的接口1到线的另一头接口2，都要进行一次加密解密。每段链路用的密钥也都不一样。

​	常见的链路层安全就是 PPP协议。PPP本身带有身份认证的功能。（早期ADSL用电话线上网时，使用的就是PPP协议。现在ADSL一般用的TCP/IP。）

#### 7.8.2 PPP实现链路层安全

​	某一条网线有接口1和接口2，两端分别连接一个路由器。给接口1连接的路由器接口配置另一个路由器的身份认证账号；另一头同理。这样只有双方的共享密钥相同时，路由器才能连通，否则身份认证不通过。

> [PPP中的PAP和CHAP的区别](https://blog.csdn.net/aiduan6474/article/details/101986196)
>
> PAP是简单认证，明文传送，客户端直接发送包含用户名/口令的认证请求，服务器端处理并回应。
>
> CHAP是加密认证,先由服务器端给客户端发送一个随机码 challenge，客户端根据 challenge 对口令进行加密，算法是 md5(password,challenge,ppp_id)。然后把这个结果发送给服务器端，服务器端从数据库中取出口令 password2，同样进行加密处理 md5(password2,challenge,ppp_id)，最后比较加密的结果是否相同。如果相同，则认证通过，向客户端发送认可消息。
>
> [PPP中的CHAP认证实验](http://www.ming4.com/news/3548.html)

### 7.9 防火墙

#### 7.9.1 概述

> [防火墙（网络术语）]([https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99/52767?fr=aladdin](https://baike.baidu.com/item/防火墙/52767?fr=aladdin))
>
> 防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。 
>
> 防火墙技术的功能主要在于及时发现并处理计算机网络运行时可能存在的安全风险、数据传输等问题，其中处理措施包括隔离与保护，同时可对计算机网络安全当中的各项操作实施记录与检测，以确保计算机网络运行的安全性，保障用户资料与信息的完整性，为用户提供更好、更安全的计算机网络使用体验。

​	防火墙是由软件、硬件构成的系统，是一种特殊编程的路由器，用来在两个网络之间实施接入控制策略。接入控制策略是由使用防火墙的单位自行制定的，为的是更好地适应单位的需求。

​	防火墙内的网络称为"可信赖的网络（trusted network）"，而防火墙外的因特网称为"不可信赖的网络"（untrusted network）。

​	防火墙可用来**解决内联网和外联网之间的安全问题**。

*（企业内网连外网，防火墙可以限制某些网段才能与外界通信。高级点的甚至可以限制传输的内容类别；限制什么时间能联网什么时间不行等等。）*

#### 7.9.2 防火墙分类

1. 网络级防火墙（过滤型防火墙）

   ​	过滤型防火墙是在**网络层与传输层**中，可以基于数据源头的地址以及协议类型等标志特征进行分析，确定是否可以通过。在符合防火墙规定标准之下，满足安全性能以及类型才可以进行信息的传递，而一些不安全的因素则会被防火墙过滤、阻挡。

   *（常见的就是限制IP、限制端口、限制协议TCP或UDP等。一般不对实际的数据内容进行过滤）*

2. 应用代理类型防火墙（应用级防火墙）：

   ​	应用代理防火墙主要的工作范围就是在OSI的最高层，位于**应用层**之上。其主要的特征是可以完全隔离网络通信流，通过特定的代理程序就可以实现对应用层的监督与控制。通常使用应用网关或代理服务来区分各种应用。例如，可以只允许通过访问万维网的应用，而阻止FTP应用的通过。

3. 复合型：

   ​	目前应用较为广泛的防火墙技术当属复合型防火墙技术，综合了**包过滤防火墙技术**以及**应用代理防火墙技术**的优点，譬如发过来的安全策略是**[包过滤](https://baike.baidu.com/item/包过滤/2724082)策略**，那么可以针对**报文的报头部分**进行访问控制；如果安全策略是**代理策略**，就可以针对**报文的内容数据**进行访问控制，因此复合型防火墙技术综合了其组成部分的优点，同时摒弃了两种防火墙的原有缺点，大大提高了防火墙技术在应用实践中的灵活性和安全性。

#### 7.9.3 防火墙网络拓扑

+ 边缘防火墙

  ```none
  内部网络---本地主机防火墙---外部网络---VPN客户端网络
  ```

+ 三向外围网

  ```none
  可信网络(企业内网)----防火墙---------不可信网络和服务器(有可信用户和不可信用户连接)
                       |
                 DMZ(企业向外提供服务的服务器)
                 
  # 因为防火墙三接口，因特网、企业内网、企业服务器，所以"三向"
  # 可以设置成，内网访问外网;外网只能访问DMZ服务器
  ```

+ 背靠背防火墙

  ```none
  内部网络----本地主机防火墙1----外围网络(服务器)----前端防火墙2----外部网络
  
  # 建议两个防火墙使用不同型号不同厂商的，避免被同时攻破
  # 外网访问服务器只经过一层防火墙(如果要黑入企业内网，还需要多攻破一道防火墙)
  ```

+ 单一网卡防火墙

  ```none
  内部网络-----本地主机防火墙-----外部网络
  
  # 不管是外网到内网还是内网到外网，设置路由必经防火墙。
  ```

### 7.10 Web安全

#### 7.10.1 HTTPS和HTTP混合web页面

> [混合內容 - Web 安全 | MDN (mozilla.org)](https://developer.mozilla.org/zh-TW/docs/Web/Security/Mixed_content)	<=	实际开发中会遇到的问题



## 8. 因特网上的音频视频

### 8.1 因特网传输流媒体所遇问题

1. 占用带宽高（文件一般很大）
2. 需要网速恒定（如果是实时播放的视频，网速不恒定，会掉帧。即有些包来得早了有些晚了。）

​	我们现实中播放视频，一般都会在客户端设置缓存。这样即时服务器上传带宽不稳定（或用户下载带宽不稳定），客户端播放器仍然以类匀速解码的形式播放视频。（因为流媒体文件被拆分多块后，服务器上传，客户端下载到本地缓存，缓存有数据后，播放器再从缓存里匀速解码，播放速度平均，观看就不会有卡顿感。）

### 8.2 音频/视频服务类型

+ 流式（streaming）存储音频/视频——边下载边播放
+ 流式实况音频/视频——边录制边发送
+ 交互式音频/视频——实时交互式通信



1. 流式（streaming）存储音频/视频：

   ​	一般就是用户事先录制好了视频/音频，并上传到流媒体服务器上。由于数据在流媒体服务器上一般经过加密处理，所以我们观看一些视频网站，会发现没法下载。视频被加密处理，只有播放视频的站点有解码方式，所以只能在线缓存、播放，不能下载。

2. 流式实况音频/视频：

   ​	让带有实时编码功能的计算机连接一个摄像头设备，然后摄像头录制实况视频，数据直接交由计算机。

   ​	计算机将视频数据实时编码（一般进行多种编码，产出各种分辨率的流媒体文件），将编码后的流媒体文件实时上传到流媒体服务器。

   ​	观众用户再通过流媒体服务器下载、缓存，观看直播的实况视频。

3. 交互式音频/视频：

   ​	QQ的视频聊天等，一般通过UDP、TCP等进行实时数据交互，编码后传输，到达客户端后由客户端解码。

### 8.3 流媒体服务场景分析

1. 常见的视频网站：

   ​	由于实际的视频文件，一般分布式地存放在多个流媒体服务器上。

   ​	由于用户不可能记住所有流媒体服务器的访问连接，所以出现了充当目录作用的web站点。web站点内再设置访问流媒体的连接。把web站点和实际的流媒体服务器分离，不仅降低了流媒体服务器被攻击的可能性（可限制流媒体服务器只允许信任的web站点直接访问），同时也方便对流媒体统一管理。web站点可对流媒体进行分类、打标签等，然后再通过推荐算法向用户推荐视频。用户无需关心实际的流媒体文件处于哪一个服务器上，只需通过web站点就能观看视频。

2. 直播平台：

   ​	摄像头将画面/声音传输到计算机，计算机实时编码，传输各种分辨率的流媒体文件到流媒体服务器。

   ​	如果与负责视频编码的计算机交互的流媒体服务器直接向用户提供直播画面，那么单个流媒体服务器的上行带宽往往是供不应求的。好一点的话，可能能够撑住10~100个用户同时观看，再多一点就不行了。

   ​	为解决这种问题，获取到流媒体文件的服务器（可能单台or多台），一般不直接向用户提供直播画面，而是再把流媒体文件下发给多个直播服务器。然后用户再访问这些直播服务器。（这样子流媒体服务器只需要复制几分文件分发给屈指可数的服务器就行了，上行带宽完全够用；而具体提供直播画面的服务器，可以选择其他配置一般，而上行带宽较高的服务器。）

   ​	一般直播、视频网站常有的频道切换等，就是从某一些流媒体服务器切换到访问其他流媒体服务器。（比如原本频道1的上行带宽几乎被占满，那么我们切换频道2，其含有的服务器上行带宽还有剩余。）

   ​	**跨越地域的流媒体服务，一般会在不同地域设置几台中转的流媒体分发点**。比如：北京某领导发话，如果直接把编码后的视频发送给南京，那么南京只要观看的用户够多，北京到南京之间的路由器就不得不承担多分流媒体的流量传输，容易导致网络拥塞。这时候，我们在北京到南京沿途经过的几个重点城市设置流媒体服务器，这样北京的流媒体传输到南京之间，中间的路由器只需要传输一份流媒体文件即可。（而且跨越的路由器越少，丢包、丢帧的概率更小。这样子中间路由器负载的流量也是可以接收的量。流媒体文件到达南京后，再由南京的多台流媒体服务器负载均衡，分担用户的访问流量）

### 8.4 IP电话

#### 8.4.1 概述

+ **狭义的IP电话**就是指IP网络上打电话。所谓的"IP网络"就是"**使用IP协议的分组交换网**"的简称。

+ **广义的IP电话**则不仅仅是电话通信，而且还可以是在IP网络上进行交互式多媒体实时通信（包括话音、视像等），甚至还包括**即时通信**IM（Instant Messaging）。

​	传统的电话机，电路交换需要经过实际的物理链路的建立连接和释放连接过程。连接建立时，沿途占用的电路交换机的其中某个端口被占用，其他用户无法再使用该端口。（这也就是电话占线。如果A和B打通电话，其他用户就无法和A或者B通信，因为A和B通信用的端口已经和电话交换机的某个端口绑定了。其他用户必须等端口释放后，才能再和A或者B连线通话。）

IP电话场景举例：*<small>（下面的是虚构的场景，提到的电话不一定真有）</small>*

​	某单位拨打长途电话，如果前缀用"010"拨号，会比单位注册的前缀"19777"拨号贵。原因是：传统的"010"前缀，走的纯电路交换，需要从比如北京到南京一路的电话交换机占用专线，这样子占用资源很多，所以运营商会采取多收费的措施限制用户拨打长途电话。而前缀"19777"走的是电话交换和因特网混合的网络。比如电话连接到北京某电话交换机，其一头是电话机接口，另一头连接因特网，那么用户只占用北京范围的电话交换机，电话信号在因特网传播，南京那头在用某个电话交换机读取该电话信号，另一头在走传统电路交换和收听电话的用户连线。（整个过程占线较少，所以收费更少）。

> [漫游费是什么意思？](https://zhidao.baidu.com/question/580037182.html)
>
> 手机号在非所属地的地方通话或者流量产生的费用。（2017就取消国内长途和漫游费了，下面描述过去情况）
>
> A地区手机卡给B地区打电话，收长途费；
>
> A地区手机卡在B地区往A地区打电话，收漫游费；
>
> A地区手机卡在B地区往非A地区打电话，收长途+漫游费。

#### 8.4.2 IP电话网关的几种连接方法

+ PC到PC：PC----因特网---PC

+ PC到固定电话机：PC----因特网---IP电话网关---公用电话网---固定电话机

+ 固定电话机到固定电话机：*<small>（走因特网比较不稳定，通常还会有声音质量差的问题。早些时候这样，现在应该好很多了）</small>*

  ```none
  固定电话机----公用电话网----IP电话网关----因特网----IP电话网关----公用电话网----固定电话机
  
  |------电路交换------|------------分组交换----------------|--------电话交换---------|
  ```

#### 8.4.3 IP电话通话质量

​	IP电话的通信质量主要由两个因素决定。一个是通话双方端到端的**时延和时延抖动**，另一个是**话音分组的丢失率**。但这两个因素是不确定的，是取决于当时网络上的通信量。

​	经验证明，在电话交谈中，端到端的时延不应该超过250ms，否则交谈者就能感受到明显的不自然。

#### 8.5 视频/音频传输

​	实际生活中，我们往往希望视频通话、语音通话等通话数据能优先被网络传输、处理。通常有以下几种手段：

1. 给不同性质的分组打上不同的**标记**。为了让通话的数据尽早在路由器中的得到处理和转发，可以在IP分组上启用"**服务类型**"字段，也就是QoS。给需要优先传递的分组的"服务类型"设置更高的优先级，使其被路由器优先处理和转发。（需要路由器设备支持）。
2. 使路由器增加**分类**（classification）机制，即路由器根据某些准则（例如，根据发送数据的地址）对输入分组进行分类，然后对不同类别的通信量给予不同的**优先级**。
3. 使路由器能对数据流进行通信量的**管制**（policing），使该数据流不影响其他正常数据流在网络中通过。例如，可将H1的数据率限定为1Mb/s。R1不停地监视H1地数据率。 只要数据率超过规定的1Mb/s，R1就将其中的某些分组丢弃。（H1指某些主机、服务器；R1指因特网上的路由器）
4. 在路由器中增加**调度**（scheduling）机制。利用调度功能给实时音频分配1.0Mb/s的带宽，给文件传送分配0.5Mb/s的带宽（相当于在带宽为1.5Mb/s的链路中划分出两个逻辑链路），因而对这两种应用都有响应的服务质量保证。
5. 数据流进入网络之前，需要**预先声明**所需的服务质量，然后网络根据实际剩余可用带宽和数据流的优先级，决定是否让该数据流进入网络。这叫作**呼叫接纳**（call admission）。比如带宽1.5Mb/s，已被占用1Mb/s，某服务此时申请要占用0.7Mb/s带宽，判断剩余0.5Mb/s带宽不足以满足需求，于是拒绝向该申请者提供网络带宽。

## 9. 无线网络

### 9.1 引言

> [办公室联网,PAN,LAN,WAN,MAN到底是什么?](https://zhidao.baidu.com/question/327606644578208445.html)
>
> PAN:个域网	LAN:局域网	MAN:城域网	WAN:广域网
>
> [无线网络协议]([https://baike.baidu.com/item/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/6290457?fr=aladdin](https://baike.baidu.com/item/无线网络协议/6290457?fr=aladdin))

+ PAN：802.15.4 ZigBee（100kb/s）；802.15.1蓝牙（1Mb/s）；802.15.3 超宽带（100Mb/s）
+ LAN：802.11b（1Mb/s~10Mb/s）；802.11g a（10Mb/s~100Mb/s）
+ MAN：802.16 WiMAX（10Mb/s）
+ WAN：2G移动通信（10kb/s~100kb/s）；3G移动通信（100kb/s~1Mb/s）；4G移动通信（100Mb/s~1Gb/s）

### 9.2 无线网络组网

#### 9.2.1 无线AP和无线路由器

> [AP （无线访问接入点(WirelessAccessPoint)）](https://baike.baidu.com/item/AP/2760808?fr=aladdin)
>
> 无线AP（Access Point）：即[无线接入点](https://baike.baidu.com/item/无线接入点/9345190)，它用于无线网络的无线交换机，也是[无线网络](https://baike.baidu.com/item/无线网络/169080)的核心。无线AP是移动计算机用户进入[有线网络](https://baike.baidu.com/item/有线网络/403338)的接入点，主要用于宽带家庭、大楼内部以及园区内部，可以覆盖几十米至上百米。无线AP（又称会话点或存取[桥接器](https://baike.baidu.com/item/桥接器/4161119)）是一个包含很广的名称，它不仅包含单纯性无线接入点（无线AP），同样也是无线路由器（含[无线网关](https://baike.baidu.com/item/无线网关/5862945)、无线网桥）等类设备的统称。

1. 无线AP和无线路由器：

   **无线AP**≈无线交换机，作用也就是扩大无线网络的覆盖范围。单纯的无线AP是无法上网的，因为只具备交换机的功能（二层），不具备路由器的功能（三层）。

   ​	通常说的"扩展型AP"，即**无线路由器**，才具备路由功能。

   ​	单纯型无线AP通常有一个接有线的RJ45网口、一个电源接口、配置口（USB口或通过WEB界面配置），并且指示灯较少；而无<u>线路由则多了四个有线网口，除了一个WAN口用于上联上级网络设备，四个LAN口可以有线连接内网中计算机</u>，而指示灯自然也多了一些。

2. 应用：

   ​	**无线路由器其实就是无线AP+路由功能**，很多的无线路由器都拥有AP功能。如果你家是ADSL或小区宽带，应该选择无线路由而不是无线AP来共享网络，如果你家有路由器了，买个无线AP就行了，对于一般的家庭用户笔者强烈推荐选择无线路由器。

   ​	在SOHO办公环境中，一个无线路由就可以满足需求了。通过整合的宽带接入路由器和无线AP功能，它可以轻松实现无线网络的连接。**无线路由器一般包括了[网络地址转换](https://baike.baidu.com/item/网络地址转换)(NAT)协议，支持网络连接共享**，这对于soho办公来说非常有用。

   ​	**无线路由器有基本的[防火墙](https://baike.baidu.com/item/防火墙)或者信息包过滤器来防止端口扫描[软件](https://baike.baidu.com/item/软件)和其他针对宽带连接的攻击**。另外无线路由器的四个有线端口也很实用，它可以连接几台有线的PC，这对于管理路由器或共享打印机都是非常有用的。

#### 9.2.2 BSS和ESS

> [服务集--wiki](https://zh.wikipedia.org/zh-hans/%E6%9C%8D%E5%8A%A1%E9%9B%86_(%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91))
>
> **服务集**（Service set）是[无线局域网](https://zh.wikipedia.org/wiki/无线局域网)中的一个术语，用以描述[802.11](https://zh.wikipedia.org/wiki/802.11)无线网络的构成单位（一组互相有联系的无线设备），使用**服务集标识符**（SSID）作为识别。可以分为**独立基本服务集**（IBSS）、**基本服务集**（BSS）和**扩展服务集**（ESS）三类。其中IBSS属于对等拓扑模式（又称[Ad-Hoc模式、无线随意网络](https://zh.wikipedia.org/wiki/無線隨意網路)），而BSS和ESS属于基础架构模式。这些拓扑是原始的802.11规范中定义的，其他的如[网桥](https://zh.wikipedia.org/wiki/网桥)、[中继器](https://zh.wikipedia.org/wiki/中继器)等则是属于特定厂商的扩展或者[WDS](https://zh.wikipedia.org/wiki/WDS)的拓扑模式。
>
> 一些新的访问点支持伪装成多个独立的访问点，各自拥有独立的SSID、[安全规则](https://zh.wikipedia.org/wiki/无线局域网#无线局域网安全)等等，但这也不属于原始的802.11规范。

![图中略去了BSSID](https://upload.wikimedia.org/wikipedia/commons/6/6e/WLAN_Service_Set.png)

**服务集标识符SSID**

服务集标识符（英语：Service Set Identifier，**SSID**）是**一个或一组基础架构模式[无线网络](https://zh.wikipedia.org/wiki/无线网络)的标识**，依照标识方式又可细分为两种：

- **基本服务集标识符（BSSID）**，表示的是[AP](https://zh.wikipedia.org/wiki/無線接取器)的[数据链路层](https://zh.wikipedia.org/wiki/数据链路层)的[MAC地址](https://zh.wikipedia.org/wiki/MAC地址)
- **扩展服务集定标识符（ESSID）**，一个最长32[字节](https://zh.wikipedia.org/wiki/字节)区分大小写的[字符串](https://zh.wikipedia.org/wiki/字符串)，表示无线网络的名称

多个[AP](https://zh.wikipedia.org/wiki/無線接取器)可以拥有同一个ESSID以对客户提供**漫游**能力，但是**BSSID必须唯一，因为[数据链路层](https://zh.wikipedia.org/wiki/数据链路层)的MAC地址是唯一的**。

**一个全为1的BSSID表示广播，一般用于检查可用无线访问点**。

[AP](https://zh.wikipedia.org/wiki/無線接取器)可以选择在信标中暴露自己的ESSID（称为**SSID广播**），也可以选择隐藏。特别的，当客户端发出加入空白ESSID网络的请求时，按照标准，所有[AP](https://zh.wikipedia.org/wiki/無線接取器)必须发送自己的ESSID以供客户检测可用网络。不过有一些AP允许关闭此功能，例如[Linux](https://zh.wikipedia.org/wiki/Linux)下的[hostapd](https://zh.wikipedia.org/w/index.php?title=Hostapd&action=edit&redlink=1)软件。

---

**独立基本服务集IBSS**

这种服务集隶属于对等拓扑模式，**各客户端之间直接相互连接而不需要[访问点](https://zh.wikipedia.org/wiki/無線接取器)的协助**。目前大多数操作系统都对此模式提供了支持，并且通常提供工具（比如[Windows XP](https://zh.wikipedia.org/wiki/Windows_XP)中自带的Wireless Zero Configuration）以简化此种网络的创建、维护和拆除。

该模式常见于小型办公室或是家庭中。因为要求所有客户端之间都可以互相直接连接，其覆盖范围非常有限。该模式的网络还有一个缺点是**不容易保护**。

在此种模式下，**最先创建起该网络的主机实际上可以控制整个IBSS中的数据传输过程，并且所有设备都会广播所加入网络的[SSID](https://zh.wikipedia.org/wiki/服务集_(无线局域网)#服务集标识符)**。<u>该种网络的BSSID（基础服务集标识符）由一个46位随机数产生，并且会指定**全局/本地**位为1（本地），同时指定**独立/组**位为0（独立）。**对应的ESSID（扩展服务集标识符）则由最先创建网络的主机决定**。</u>

> [连接WLAN热点时，MAC地址为什么会随机变化，如何设置](https://consumer.huawei.com/cn/support/content/zh-cn00754915/)
>
> IBSS也就是我们手机/电脑开启热点时的SSID，一般手机/电脑连接热点时，都会为了安全伪装自己的MAC。自己试试就知道了，笔记本连接家里wifi和手机热点的时候，使用指令`ipconfig /all`，确实可以看到两次MAC地址不同。
>
> [Windows查看WIFI的BSSID，获取热点MAC地址](https://blog.csdn.net/pzcsdn/article/details/105036605)
>
> WIFI热点的BSSID其实就是WIFI的MAC地址，Windows查看WIFI MAC地址，`netsh wlan show networks mode=bssid`
>
> 其中SSID为WIFI的热点名称，BSSID冒号后面为WIFI的MAC地址。（**手机热点的SSID就是你分享热点设置的名字，而BSSID就是手机的mac地址**，亲测如此）
>
> 除了上述命令查看所有附近WIFI的BSSID和SSID以外，也可以运行`netsh wlan show interfaces`命令查看已经连接的WIFI的BSSID和SSID（这个数据比较隐私，下面就不贴显示的结果了）
>
> **Windows上获取WIFI热点的SSID和BSSID，典型的应用场景是在设置路由器无线桥接时，中继隐藏热点的WIFI，常规情况下，如果WIFI没有广播热点名称，路由器设置界面可能无法找到这个WIFI热点。**

windows执行`netsh wlan show networks mode=bssid`

```none
## 下面为了隐私，保险起见,除了协议外，所有字母数字都改过了

C:\Users\xxxxx>netsh wlan show networks mode=bssid

接口名称 : WLAN
当前有 22 个网络可见。

SSID 1 : asdasd-adaszx
    Network type            : 结构
    身份验证                : WPA - 个人
    加密                    : TKIP
    BSSID 1                 : c5:72:1c:b8:24:2e
         Signal             : 8%
         Radio type         : 802.11g
         Band               : 2.4 GHz
         Channel            : 11
         基本速率(Mbps)     : 1 2 5.5 11
         其他速率(Mbps)     : 6 9 12 18 24 36 48 54

SSID 2 : jasljlasdj
    Network type            : 结构
    身份验证                : WPA2 - 个人
    加密                    : CCMP
    BSSID 1                 : c5:27:35:a5:1e:42
         Signal             : 8%
         Radio type         : 802.11n
         Band               : 2.4 GHz
         Channel            : 1
         基本速率(Mbps)     : 1 2 5.5 11
         其他速率(Mbps)     : 6 9 12 18 24 36 48 54
    BSSID 2                 : 14:3d:af:60:43:6e
         Signal             : 8%
         Radio type         : 802.11n
         Band               : 2.4 GHz
         Channel            : 11
         基本速率(Mbps)     : 1 2 5.5 11
         其他速率(Mbps)     : 6 9 12 18 24 36 48 54

SSID 3 :
    Network type            : 结构
    身份验证                : WPA2 - 个人
    加密                    : CCMP
    BSSID 1                 : 16:c1:30:ca:53:48
         Signal             : 8%
         Radio type         : 802.11n
         Band               : 2.4 GHz
         Channel            : 11
         基本速率(Mbps)     : 1 2 5.5 11
         其他速率(Mbps)     : 6 9 12 18 24 36 48 54
    BSSID 2                 : c2:4d:c3:a6:ff:a9
         Signal             : 15%
         Radio type         : 802.11n
         Band               : 2.4 GHz
         Channel            : 11
         基本速率(Mbps)     : 1 2 5.5 11
         其他速率(Mbps)     : 6 9 12 18 24 36 48 54
    BSSID 3                 : 40:1d:c4:08:a4:14
         Signal             : 16%
         Radio type         : 802.11n
         Band               : 2.4 GHz
         Channel            : 11
         基本速率(Mbps)     : 1 2 5.5 11
         其他速率(Mbps)     : 6 9 12 18 24 36 48 54

## ....下面就是SSID 4... SSID 22了
```

windows执行`netsh wlan show interfaces`和上诉结果差不多，只不过只显示当前连接的。

```none
## 为了隐私，把下面出现的数字、字母都改了，除了协议之类的没有改动
C:\Users\XXXX>netsh wlan show interfaces

系统上有 1 个接口:

    名称                   : WLAN
    描述                   : Intel(R) Dual Band Wireless-AC 5451
    GUID                   : 86bc7a0-34ef-5ce9-d41a-92641880dcd2
    物理地址               : 46:ae:da:7d:db:9c
    状态                   : 已连接
    SSID                   : TP-LINK_D5D3C8
    BSSID                  : af:38:7e:ff:e2:c1
    网络类型               : 结构
    无线电类型             : 802.11n
    身份验证               : WPA2 - 个人
    密码                   : CCMP
    连接模式               : 自动连接
    信道                   : 1
    接收速率(Mbps)         : 81
    传输速率 (Mbps)        : 81
    信号                   : 80%
    配置文件               : TP-LINK_D5D3C8

    承载网络状态  : 不可用
```

---

**基本架构模式**

基础架构模式下，**所有客户端和一个（BSS）或多个（ESS）访问点关联**，各客户端间的数据传输通过[访问点](https://zh.wikipedia.org/wiki/無線接取器)中转，各客户端之间不直接相互通信（规范也不允许直接通信），因此每个客户只要在访问点的有效信号范围内就可以了，但是这也带来了部分设备不可见的问题，因为**用于避免在无线链路上发生[冲突](https://zh.wikipedia.org/w/index.php?title=冲突_(通信)&action=edit&redlink=1)的[CSMA/CA](https://zh.wikipedia.org/wiki/CSMA/CA)技术依赖于每个设备之间的互相可见性**。[[3\]](https://zh.wikipedia.org/wiki/服务集_(无线局域网)#cite_note-3)通常情况下，其覆盖范围通常比对等拓扑模式广。

> [对等网络--百度百科]([https://baike.baidu.com/item/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C/5482934?fr=aladdin](https://baike.baidu.com/item/对等网络/5482934?fr=aladdin))
>
> 在P2P网络环境中，彼此连接的多台计算机之间都处于对等的地位，各台计算机有相同的功能，无主从之分，一台计算机既可作为服务器，设定共享资源供网络中其他计算机所使用，又可以作为工作站，整个网络一般来说不依赖专用的集中服务器，也没有专用的工作站。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求做出响应，提供资源、服务和内容。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU计算能力共享）、存储共享（如缓存和磁盘空间的使用）、网络共享、打印机共享等。
>
> P2P网络主要基于两种最基本的模式，即**集中目录模式**和**非集中目录模式**。
>
> **集中目录模式**(先找中心服务器获取所有结点的共享信息，再根据共享信息找到想要联系的结点。)
>
> 集中目录式的P2P模式也称为结构化的P2P模式。在这种模式中，通过设置一个中心服务器来负责记录和管理所有结点的共享信息资源。每个对等结点通过查询该服务器来了解对等网络中哪一个结点拥有自己所需要的共享信息资源，查找到以后，获取其主机地址，然后进一步向该主机请求自己所需要的信息资源，最后由该主机将其共享信息复制并发送给请求的主机集中目录式P2P网络。 [3] 
>
> **非集中目录模式**（访问邻居结点，让邻居结点告知是否有自己想要的资源，没有就让其再继续访问邻居结点，直到最后找到目标结点）
>
> 非集中目录的P2P模式也称为纯P2P模式。在非集中式的P2P模式中，对等网络不需要设置一个中心服务器来负责记录和管理所有结点的共享信息资源。任何一个结点要获取某个共享信息资源都是首先询问其相邻结点是否有该资源，如果某个相邻结点没有，则进一步向它的相邻结点询问（询问报文中必须包括初始请求结点的地址），直到具有该信息资源的结点接收到询问请求，那么就由这个结点向最初的请求结点进行肯定应答（同时指明自己的地址）。最后，由初始请求结点向这个结点提出资源请求，这个结点就将其共享信息复制并发送给初始请求结点。

---

**基本服务集BSS**

**在基本服务集中，所有无线设备关联到一个[访问点](https://zh.wikipedia.org/wiki/無線接取器)上，该访问点连接其他有线设备（也可能不连接），并且控制和主导整个BSS中的全部数据的传输过程**。BSS使用发射器的[第二层](https://zh.wikipedia.org/wiki/OSI模型)地址**（通常是[MAC地址](https://zh.wikipedia.org/wiki/MAC地址)）作为其BSSID**（基础服务集标识符），亦可以指定一个ESSID（扩展服务集标识符）来帮助记忆。

BSS的覆盖范围称为基本服务区（BSA）或是[蜂窝](https://zh.wikipedia.org/wiki/蜂窩)。只有在BSS为构成单元，BSA为其覆盖范围的情况下，BSS和BSA才可以互换。

例如上面出现的图中，忽略其他有线网络设备，两个访问点虽然使用了同一个ESSID（扩展服务集标识符），但是二者的第二层地址不一样，因此是两个BSS，两台[笔记本电脑](https://zh.wikipedia.org/wiki/笔记本电脑)分别属于这两个BSS。若是没有其他设备辅助，二者无法直接通信。

---

**扩展服务集ESS**

在扩展服务集（ESS）中，无线设备关联到一个或多个[访问点](https://zh.wikipedia.org/wiki/無線接取器)上。**ESS实质上是多个BSS通过各种手段互相连接得来，ESS使用用户指定的ESSID作识别。**

通过将多个BSS比邻安置，可以扩展网络的范围，如果这些BSS通过各种分布系统互联（无论是有线的还是无线的），拥有一致的ESSID，并且对于[逻辑链路控制](https://zh.wikipedia.org/wiki/逻辑链路控制)层来说可以认为是一个BSS的话，那么这些BSS可以被统一为一个ESS。

**在同一个ESS中的不同BSS之间切换的过程称为<u>漫游</u>。**一般而言，<u>一个ESS中的BSS都会使用相同的[安全](https://zh.wikipedia.org/wiki/无线局域网#无线局域网安全)机制以提供接近于无缝漫游的可能</u>。两个BSS之间通常有15%左右的重叠范围来保证漫游时信号不会长时间丢失，并且**设置在不同[频段](https://zh.wikipedia.org/wiki/WLAN信道列表)来防止相互[干扰](https://zh.wikipedia.org/wiki/干扰)**。

同样在上面的图中，**两个访问点通过一台[交换机](https://zh.wikipedia.org/wiki/網路交換器)实现了分布式系统，并且拥有一样的ESSID**，这样一来两台分别属于不同BSS的电脑之间就可以互相通信，就好像都连接在同一台访问点上一样。

当图中Laptop0**进入两个访问点信号重叠部分时，操作系统会自动判断信号强弱并切换关联的访问点**。这样，在完全失去右侧访问点的信号前，会有足够的时间让电脑切换到左侧的访问点。这当中只需要几秒钟便可完成。

----

> [WIFI信道有十几个，为什么搜索到的大多数都是1、6、11这三个信道？](https://www.zhihu.com/question/21935550/answer/33608131)
>
> 简言之就是频段叠加会互相干扰信号，而1，6，11正好都是互不干扰的频段。如果有3个路由器，就可以考虑各自从中选一个频道。
>
> [无线局域网安全（三）————CCMP加密](https://blog.csdn.net/lee244868149/article/details/52733277/)
>
> CCMP（Counter CBC-MAC Protocol） 计数器模式密码块链消息完整码协议。CCMP主要是两个算法所组合而成的，分别是CTR mode以及CBC-MAC mode。CTR mode为[加密算法](https://baike.baidu.com/item/加密算法/2816213)，CBC-MAC用于讯息完整性的运算。在IEEE [802.11i](https://baike.baidu.com/item/802.11i/611896) 规格书中，CCMP为default mode，在所谓的RSN network中，扮演相当重要的角色。以下将分别简介CTR mode以及CBC-MAC。
>
> [蜂窝网络--wiki](https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C)
>
> 蜂窝网络（英语：Cellular network），又称移动网络（mobile network）是一种[移动通信](https://zh.wikipedia.org/wiki/移动通信)硬件架构，分为模拟蜂窝网络和数字蜂窝网络。由于构成网络覆盖的各[通信基地台](https://zh.wikipedia.org/wiki/蜂窝站)的信号覆盖呈六边形，从而使整个网络像一个[蜂窝](https://zh.wikipedia.org/wiki/蜂窩)而得名。
>
> 目前世界的主流蜂窝网络类型有：[GSM](https://zh.wikipedia.org/wiki/GSM)、[WCDMA](https://zh.wikipedia.org/wiki/WCDMA)／[CDMA2000](https://zh.wikipedia.org/wiki/CDMA2000)（[3G](https://zh.wikipedia.org/wiki/3G)）、[LTE](https://zh.wikipedia.org/wiki/長期演進技術)／[LTE-A](https://zh.wikipedia.org/wiki/長期演進技術升級版)（[4G](https://zh.wikipedia.org/wiki/4G)）等。
>
> 蜂窝网络的组成：蜂窝网络组成主要有以下三部分：**移动站，基站子系统，网络子系统**。移动站就是我们的网络终端设备，比如手机或者一些蜂窝工控设备 。基站子系统包括我们日常见到的移动基站（大铁塔）、无线收发设备、专用网络（一般是[光纤](https://zh.wikipedia.org/wiki/光纤)）、无数的数字设备等等的。**我们可以把基站子系统看作是[无线网络](https://zh.wikipedia.org/wiki/无线网络)与有线网络之间的转换器**。
>
> [802.11(wifi)中SSID、BSSID、ESSID的区别](https://blog.csdn.net/sllin/article/details/107174729)
>
> 举个例子，一家公司面积比较大，安装了若干台无线接入点（AP或者无线路由器），公司员工只需要知道一个SSID就可以在公司范围内任意地方接入无线网络。BSSID其实就是每个无线接入点的MAC地址。当员工在公司内部移动的时候，SSID是不变的。但BSSID随着你切换到不同的无线接入点，是在不停变化的。
>
> ESS包括了网络中所有的BSS。**一般ESSID就是SSID。**
>
> 通常，手机WLAN中，BSSID其实就是无线路由的MAC地址. ESSID 也可认为是SSID, WIFI 网络名
>
> [WIFI 考勤打卡 浅析](https://www.jianshu.com/p/bab8351321fa)
>
> 现在比较火爆的由阿里团队研发的钉钉，以及纷享销客APP，在Android端，他们的处理都是**获取周围wifi信息(并不是当前手机连接的wifi)进行打卡**。(也很好理解，因为WIFI信号范围有限，要是能进入WIFI覆盖范围，那么就肯定在工作区了，所以自动完成打卡。)

#### 9.2.3 无线AC和无线AP

> [无线控制器--百度百科]([https://baike.baidu.com/item/%E6%97%A0%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8/1319032?fr=aladdin](https://baike.baidu.com/item/无线控制器/1319032?fr=aladdin))
>
> 无线控制器（Wireless Access Point Controller）是一种网络设备，用来集中化控制[无线AP](https://baike.baidu.com/item/无线AP)，是一个无线网络的核心，负责管理无线网络中的所有无线AP，对AP管理包括：下发配置、修改相关配置参数、射频智能管理、接入安全控制等。
>
> [无线AP与AC的区别](https://zhidao.baidu.com/question/2139053660985438588.html)
>
> [AC跟AP有什么区别？](https://zhidao.baidu.com/question/758712321185491404.html)
>
> [AC加AP是什么意思？跟我们用的路由器有什么区别？](https://tieba.baidu.com/p/6056011162)
>
> [POE （有源以太网(Power Over Ethernet)）](https://baike.baidu.com/item/POE/65616?fr=aladdin)
>
> 以太网供电（Power over Ethernet，简称PoE）也称为PoE供电，是一种**可以在以太网路中透过<u>双绞线</u>来传输电力与资料到装置上的技术**。以太网供电技术的出发点是让IP电话、WLAN接入点、网络摄像头等小型网络设备，可以直接从以太网线（4对双绞线中空闲的2对来传输）获得电力，无需单独铺设电力线，以简化系统布线，降低网络基础设施的建设成本。

![img](https://bkimg.cdn.bcebos.com/pic/1e30e924b899a9017f4b896b1e950a7b0208f575?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxMTY=,g_7,xp_5,yp_5)

WLAN系统一般由**AC（接入控制器）**和**AP（无线接入点）**组成。

+ **无线AP**（Wireless Access Point），它是用于无线网络的**无线交换机**，也是无线网络的核心。无线AP是移动计算机用户进入有线网络的**接入点**，主要用于宽带家庭、大楼内部以及园区内部，典型距离覆盖几十米至上百米，目前主要技术为802.11系列。**大多数无线AP还带有接入点客户端模式（AP client），可以和其它AP进行无线连接，延展网络的覆盖范围**。

* **无线AC**(Wireless Access Point Controller)，无线局域网接入控制设备，负责把来自不同AP的数据进行汇聚并接入Internet，同时完成AP设备的配置管理、无线用户的认证、管理及宽带访问、安全等控制功能。

![img](https://iknow-pic.cdn.bcebos.com/3c6d55fbb2fb431636d580772da4462308f7d3f1?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)

*扩展资料：Wi-Fi是一种允许电子设备连接到一个无线局域网（WLAN）的技术，通常使用2.4G UHF或5G SHF ISM 射频频段。连接到无线局域网通常是有密码保护的；但也可是开放的，这样就允许任何在WLAN范围内的设备可以连接上。Wi-Fi是一个无线网络通信技术的品牌，由Wi-Fi联盟所持有。目的是改善基于IEEE 802.11标准的无线网路产品之间的互通性。有人把使用IEEE 802.11系列协议的局域网就称为无线保真。甚至把Wi-Fi等同于无线网际网路（Wi-Fi是WLAN的重要组成部分）。*

**要我总结的话，AP可类比无线版本的二层交换机<small>（AP可自动广播供用户发现，也就是为什么手机能扫描到wifi设备）</small>；无线AC类比无线版本的三层交换机<small>（但是AC还有配置管理AP的功能）</small>；而路由器和AC无关，倒是有一些高级路由器带有AC功能，不然纯AC还需要配合路由器才能上网。**

> [AC和路由器在功能上有什么区别，是干什么用的？](https://zhidao.baidu.com/question/541510609.html)
>
> ​	AC路由器是路由器的一种。
> ​	11ac路由器，全称是**802.11ac**，是继**802.11n**之后的新一代Wi-Fi标准。如同大家喜闻乐见的，现在市面上百元档基本都是**802.11n路由器，最快速度在300Mbps**。而**11ac路由器，网速最快可达1.3Gbps，也就是传说中的千兆路由**。
> 11ac路由器支持5GHz和2.4GHz两个频段，他们的传输速度分别是5GHz的900Mbps、2.4GHz的400Mbps。
> ​	一般的路由器（802.11n）只支持2.4GHz频段，容易受电磁炉、微波炉等干扰。
>
> [求推荐性价比高带AC功能的路由器?](https://www.zhihu.com/question/357104928)

#### 9.2.4 无线局域网和移动自组网络

> [DS （计算机网络术语）](https://baike.baidu.com/item/DS/2618543#viewPageContent)
>
> DS（ Distribution System 分发系统）是用来连接不同BSA的通信信道，可以是有线信道或者无线信道。在多数情况下，有线DS系统与骨干网都采用[IEEE 802.3](https://baike.baidu.com/item/IEEE 802.3)标准，而无线DS系统（WDS）可以通过AP间的无线连接实现BSS连接。DS通过Portal与骨干网相联，从WLAN发往骨干网的数据，都必须经过Portal，反之亦然。这样，通过Portal将WLAN与骨干网连接起来。Portal可以与AP集成在一起，也可以是单一的设备(如网桥、[路由器](https://baike.baidu.com/item/路由器)、网关主机等)。
>
> [骨干网--百度百科]([https://baike.baidu.com/item/%E9%AA%A8%E5%B9%B2%E7%BD%91/7371439?fr=aladdin](https://baike.baidu.com/item/骨干网/7371439?fr=aladdin))
>
> 骨干网（Backbone Network）是用来连接多个区域或地区的高速网络。每个骨干网中至少有一个和其他骨干网进行互联互通的连接点。**不同的网络供应商都拥有自己的骨干网，用以连接其位于不同区域的网络**。
>
> Internet backbone：Internet 骨干网
>
> 几台计算机连接起来，互相可以看到其他人的文件，这叫局域网，整个城市的计算机都连接起来，就是[城域网](https://baike.baidu.com/item/城域网)，**把[城市之间](https://baike.baidu.com/item/城市之间)连接起来的网就叫骨干网**。**<u>这些骨干网是国家批准的可以直接和国外连接的互联网。其他有接入功能的ISP（互联网服务提供商）想连到国外都得通过这些骨干网。</u>**
>
> “骨干网”通常是用于描述大型网络结构时经常使用的词语，描述网络结构，主要是要看清楚[网络拓扑结构](https://baike.baidu.com/item/网络拓扑结构)，而非具体使用的传输方式或协议。**骨干网一般都是[广域网](https://baike.baidu.com/item/广域网):作用范围几十到几千公里.**
>
> 骨干网是由多种传输方式，多种协议组合构成的。
>
> 我国拥有9大骨干网：
>
> ❶．[中国公用计算机互联网](https://baike.baidu.com/item/中国公用计算机互联网)([CHINANET](https://baike.baidu.com/item/CHINANET))
>
> ❷．[中国金桥信息网](https://baike.baidu.com/item/中国金桥信息网)([CHINAGBN](https://baike.baidu.com/item/CHINAGBN))
>
> ❸．[中国联通](https://baike.baidu.com/item/中国联通)计算机互联网(UNINET)
>
> ❹．[中国网通](https://baike.baidu.com/item/中国网通)公用互联网(CNCNET)
>
> ❺．[中国移动](https://baike.baidu.com/item/中国移动)互联网(CMNET)
>
> ❻．[中国教育和科研计算机网](https://baike.baidu.com/item/中国教育和科研计算机网)([CERNET](https://baike.baidu.com/item/CERNET))
>
> ❼．[中国科技网](https://baike.baidu.com/item/中国科技网) (CSTNET)
>
> ❽．[中国长城互联网](https://baike.baidu.com/item/中国长城互联网)(CGWNET)
>
> ❾．中国国际经济贸易互联网(CIETNET)

**无线局域网**：

​	多个独立的BSS基本服务集可通过分配系统DS连接成一个ESS扩展服务集。分配系统DS与各个BSS进行有线或者无线连接，其一头Portal连接至其他802.x局域网，另一个则是连接路由器再进行ADSL拨号上网or连接光猫配上光纤连接因特网。

​	一个基本服务集BSS包括一个基站和若干个移动站，所有的站在本BSS以内都可以直接通信，但在本BSS以外的站通信时，都要经过本BSS的基站。

​	基本服务集内的基站叫作接入点AP（Access Point）。

​	当网络管理员安装AP时，必须为该AP分配一个不超过32字节的**服务集标识符SSID**（生活中看到，就是WIFI名）和一个**信道**（用的频段是哪里到哪里范围的）。

​	*上面这种教科书般的说法，如果是家庭用的小范围网络，那就可以对应平时所说的AC+AP了。经过上面的笔记，应该也都很好理解了吧？*

**移动自组网络**：

​	自组网络是没有固定基础设施（即没有AP）的无线局域网。这种网络由一些处于平等状态的移动站之间互相通信组成的临时网络。

​	*对应生活常见的小型自组网络的话，那就是常见的热点了。*



生活案例：

1. 手机流量上网：

   ​	平时走在路上开流量的话，之所以能上网，就是手机自己往附近信号比较强的基站注册自己，然后基站为我们分配IP等信息。基站那里会记录用户信息，所以电信、移动等ISP能够知道哪个设备在哪个时间段在哪个基站注册了，并且能够统计用户使用的流量，之后收费。

2. 手机打电话：

   ​	比如在南京打电话要打到北京。你附近的基站接收信号，打电话时，基站会从移动、电信之类的服务商那里查数据库，得知哪些基站通过哪根光纤可通信到北京那边的基站。然后你手机就把信号发送到对应的基站，由它传输。北京那头的人通过北京的基站接收到你的通话信号，与你进行通讯。

   *（基站和基站之间通过光纤或者其他设备通信连接。）*

   *（打电话绝对不是手机信号直接到手机信号，我们手机信号强度没那么强，不可能直接传播那么远。）*

3. 位置检测（大致精度）：

   ​	我们拿手机走路上移动位置，每过一段路程可能就会注册到不同的基站，然后就需要再向移动、电信等的数据库提交新的信息。通过和基站的数据交换，它们就知道哪个用户注册到哪个基站了。这就是为什么有些人到某些地段旅游，会突然收到"XXX欢迎你来游玩"之类的短信，因为它们地段的基站检测到你这个新用户注册到它们的数据库里了。

> [基站--百度百科]([https://baike.baidu.com/item/%E5%9F%BA%E7%AB%99/1260692?fr=aladdin](https://baike.baidu.com/item/基站/1260692?fr=aladdin))
>
> 基站即公用移动通信基站，**是移动设备接入[互联网](https://baike.baidu.com/item/互联网/199186)的[接口设备](https://baike.baidu.com/item/接口设备/5700310)**，也是无线电台站的一种形式，是指在一定的无线电覆盖区中，通过移动通信交换中心，与移动电话终端之间进行信息传递的无线电收发信电台。移动通信基站的建设是移动通信运营商投资的重要部分，[移动通信基站](https://baike.baidu.com/item/移动通信基站/422202)的建设一般都是围绕覆盖面、通话质量、投资效益、建设难易、维护方便等要素进行。随着移动通信网络业务向数据化、分组化方向发展，移动通信基站的发展趋势也必然是宽带化、大覆盖面建设及IP化。
>
> [手机是如何通过基站/WIFI接入互联网的](https://zhidao.baidu.com/question/1116278907314841859.html)
>
> 手机通过基站/WIFI等两大类无线热点接入互联网，以下是各类的网络框架。
>
> （1）移动通信网（基站）2G/3G/4G
> （2）固定通信网（WIFI）ADSL/EPON
>
> [isp是怎么接入到Internet的](https://zhidao.baidu.com/question/5188269.html)
>
> ISP分不同的级别，如一级、二级、三级。一级最高，你可以理解为电信、网通、联通。还有一些公司从一级那里批发带宽，再给用户提供接入，那么就属于二级。
> 一级ISP都有自己的网络基础设施，如长距光纤、光通信设备，并和国际的Internet出口相连。
> 二级则直接接到一级的接入设备上，通常是接入到城域网路由器、MPLS路由器等等。
> 用户-----二级-------一级--------国际出口

### 9.3 无线局域网-数据链路层

#### 9.3.1 CSMA/CA

>[CSMA/CA--百度百科](https://baike.baidu.com/item/CSMA%2FCA/10898090?fr=aladdin) <= 以下内容主要出处。

​	CSMA/CA（Carrier Sense Multiple Access with Collision Avoid，即带有**冲突避免**的[载波侦听多路访问](https://baike.baidu.com/item/载波侦听多路访问/9467111)）是一种[数据传输](https://baike.baidu.com/item/数据传输/2987565)时**避免各站点之间数据传输冲突**的算法，其特点是**发送包的同时不能检测到信道上有无冲突，只能尽量“避免”**。

​	*例如，如果计算机A和计算机C同时给计算机B发送一个控制消息，它们将同时到达计算机B，导致冲突的发生。当这种冲突发生时，发送者可以随机等待一段时间，然后重发控制消息。因为控制消息比数据信息要短得多，所以发生第二次冲突的可能性也要比传统以太网要小很多。最终将有一个控制消息正确到达，然后计算机B发送一个响应消息。*

​	**通常CSMA/CA利用ACK信号来避免冲突的发生，也就是说，只有当客户端收到网络上返回的ACK信号后才确认送出的数据已经正确到达目的**。

![img](https://bkimg.cdn.bcebos.com/pic/64380cd7912397dd7108362b5982b2b7d0a287a8?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

---

**产生背景**

​	**虽然[CSMA/CD](https://baike.baidu.com/item/CSMA%2FCD/986847)协议已成功地应用于有线连接的[局域网](https://baike.baidu.com/item/局域网/98626)，但[无线局域网](https://baike.baidu.com/item/无线局域网/176200)不能简单地搬用CSMA/CD协议**。其主要原因是：

1. CSMA/CD协议要求一个[站点](https://baike.baidu.com/item/站点/7108922)在发送本站数据的同时还必须不间断地检测[信道](https://baike.baidu.com/item/信道/499862)，以便发现是否有其他的站也在发送数据，这样才能实现“冲突检测”的功能。但在无线局域网的设备中要实现这种功能花费过大。

   <small>（CSMA/CD要求发送数据时进行"冲突检测"，无线局域网实现复杂开销大。毕竟无线局域网的成员站点不固定，可能时而出现、时而消失，不像有线局域网网络的成员相对稳定不变动。）</small>

2. 更重要的是，即使能够实现冲突检测的功能，且在发送[数据报](https://baike.baidu.com/item/数据报/2194617)时检测到信道是空闲的，但是，由于[无线电波](https://baike.baidu.com/item/无线电波/942435)能够向所有的方向传播，且其传播距离受限，在接收端仍然有可能发生冲突，从而产生隐藏站问题和暴露站问题。

   <small>(无线网络传输数据的环境更不稳定，对数据传输的把控不严格。)</small>

3. [无线信道](https://baike.baidu.com/item/无线信道/3375810)还由于传输条件特殊，造成信号强度的动态范围非常大。这就使发送站无法使用冲突检测的方法来确定是否发生了碰撞。

因此，无线局域网不能使用CSMA/CD协议，而是以此为基础，制定出更适合无线网络共享信道的载波监听多路访问/冲突避免CSMA/CA协议。CSMA/CA协议利用[ACK](https://baike.baidu.com/item/ACK/3692629)信号来避免冲突的发生，也就是说，只有当客户端收到网络上返回的ACK信号后，才确认送出的数据已经正确到达目的。

---

**工作流程**

> [IEEE 802.11--百度百科]([https://baike.baidu.com/item/IEEE%20802.11/8447947?fromtitle=802.11&fromid=6262490](https://baike.baidu.com/item/IEEE 802.11/8447947?fromtitle=802.11&fromid=6262490))
>
> **IEEE 802.11**是现今[无线局域网](https://baike.baidu.com/item/无线局域网)通用的标准，它是由[电气和电子工程师协会](https://baike.baidu.com/item/电气和电子工程师协会)（IEEE）所定义的[无线网络](https://baike.baidu.com/item/无线网络)通信的标准。
>
> 虽然经常将[Wi-Fi](https://baike.baidu.com/item/Wi-Fi)与802.11混为一谈，但两者并不等同。
>
> [BSA （基本服务区）--百度百科](https://baike.baidu.com/item/BSA/15459654?fr=aladdin)
>
> **WLAN能覆盖的区域范围称为服务区（Service Area，SA）**。
>
> 由移动站的无线收发信机及地理环境确定的通信覆盖区域称为基本服务区（Basic Service Area，BSA）或小区（Cell），是**网络的最小单元**。
>
> **一个BSA内相互联系，相互通信的一组主机组成了基本服务集BSS**

​	[802.11](https://baike.baidu.com/item/802.11/6262490)标准为[数据帧](https://baike.baidu.com/item/数据帧/10571824)定义了**不同的信道使用优先级，使用三种不同的时间参数**：**短帧间隔SIFS**、**长帧间隔DIFS**和**点协同间隔PIFS**。

+ **SIFS最短**，使用它作为等待时延的结点将用**最高的信道使用优先级**来发送数据帧。<u>网络中的**[控制帧](https://baike.baidu.com/item/控制帧/9032456)**以及对所接收数据的**确认帧**都采用SIFS作为发送之前的等待时延。</u>
+ **DIFS最长**，<u>所有的**数据帧**都采用DIFS作为等待时延</u>。
+ PIFS具有中等级别的优先级，<u>主要作为AP定期向**服务区**（Service Area，SA）内发送**管理帧**或**探测帧**所用的等待时延</u>。

主要工作流程：

1. 当[主机](https://baike.baidu.com/item/主机/455151)需要发送一个数据帧时，首先检测信道，在持续检测到信道空闲达一个DIFS之后，主机发送数据帧。接收主机正确接收到该数据帧，等待一个SIFS后马上发出对该数据帧的确认。<u>若源站在规定时间内没有收到确认帧ACK，就必须重传此帧，直到收到确认为止，或者经过若干次重传失败后放弃发送</u>。

2. <u>当一个站**检测**到正在信道中传送的MAC帧首部的“持续时间”字段时，就调整自己的网络分配向量NAV</u>。NAV指出了必须经过多少时间才能完成这次传输，才能使信道转入空闲状态。因此，信道处于忙态，或者是由于物理层的载波监听检测到信道忙，或者是由于MAC层的虚拟载波监听机制指出了信道忙。

![img](https://bkimg.cdn.bcebos.com/pic/d52a2834349b033be78242011bce36d3d439bde7?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxMTY=,g_7,xp_5,yp_5)

---

**CSMA/CA分类**

​	CSMA/CA分为两类，第一类是**[时分多路复用](https://baike.baidu.com/item/时分多路复用/7831037)技术与CSMA/CD相结合的方式**；第二类是**二次检测避免冲突方式**。下面分别介绍这两种方式。

+ 时分复用TDMA+CSMA/CD结合的方式
  + 优点
    + 工作效率高
  + 缺点
    + 实现复杂
+ 二次检测避免冲突方式
  + 优点
    + 实现较简单
  + 缺点
    + **发送后产生的冲突，需要发送完毕才能感知(不能停止已发生冲突的帧发送动作)**

1. 第一类避免冲突的工作方式要点如下：每次传递结束后，立即把时间划分成时间片，这些时间片分属网络中各结点。结点根据时间片的先后发送信息，具有第一个时间片的结点首先发送，发送结束后，按优先权顺序把发送权交给具有第二个时间片的结点。轮到某个结点而该结点又无报文可发时，它的时间片就空闲不用。如果在时间片轮回一周后，所有结点都无报文可发，那么网络就返回到CSMA/CD方式，这时又按竞争方式获取信道。信道在CSMA/CD方式下使用一次后，系统又回到时间片方式。在这种可避免冲突的系统中，通常给某些结点以特殊的优先权，使它们总是能在第一个时间片发送信息。如果给它们的时间片没有使用，则重新在其他结点轮流分配时间片。在这种系统中，结点必须有能力完成时间片的同步，执行分配时间片的算法以及CSMA/CD方式的算法，因此，**实现起来较复杂，价格也较贵。这种方法的优点是效率高。**

2. 第二类避免冲突的CSMA/CA技术，称为二次检测信道访问技术。这是一种与第一种方式完全不同的CSMA/CA技术。它由结点在发送信息前对介质进行两次检测来避免冲突的发生，其工作方式如下：准备发送信息的结点在发送前侦听介质一段时间（大约为介质最长传播延迟时间的2倍），如果在这一段时间内介质为“闲”，则开始准备发送，发送准备的时间较长，约为前一段侦听时间的2~3倍。准备结束后，真正要将信息发送前，再由结点对介质进行一次迅速短暂的侦听，若仍为空闲，则可正式发送。如果这时侦听到介质上有信息传输，则马上停止自己即将开始的发送。按某种算法延迟一段随机时间，然后再重复以上的二次检测过程，所以这种方式又称为“二次检测”法。由于第二次侦听的时间短，在这么短暂的时间内有两个点同时发送信息的可能性很小，因此基本上可以避免冲突。同时，**这种方式没有“边发边听”，而仅仅是“先听后发”，这样，用不着“边听边发”的复杂的冲突检测装置，降低了成本**。这种方法的**缺点是，发送后一旦发生冲突，也不中止自己的发送，直到发送完毕才知道错误，再重新侦听、重发**。

#### 9.3.2 无线CSMA/CA、有有线CSMA/CD区别

> [无线局域网为什么不用 CSMA/CD 而用 CSMA/CA](https://blog.csdn.net/skyejy/article/details/94657972)
>
> CSMA/CD:载波侦听多路访问/碰撞检测
> CSMA/CA:载波监听多路访问/碰撞避免
> CSMA/CD协议已经成功地应用于使用**有线连接**的局域网，但在无线局域网的环境下，却不能简单地搬运CSMA/CD协议。
>
> 主要有两个原因：
>
> 1. 接受信号的强度往往会小于发送信号的强度，且在无线介质上信号强度动态变化范围很广。因此若要实现碰撞检测，在硬件上的花费就会过大；
> 2. 在无线通信中，并非所有的站点都能够听见对方。而<u>“所有站点都能够听见对方”正是实现CSMA/CD协议必备的基础</u>。
>
> **CSMA/CD协议的特点是：先听再发，边听边发，冲突停发，随机重发；**
> **CSMA/CA协议的特点是：发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免发生碰撞；**

+ CSMA/CD可以检测冲突，但无法避免冲突；
+ 对于CSMA/CA，在发送包的同时不能检测到信道上有无冲突，只能尽量避免。

CSMA/CD和CSMA/CA的主要差别表现在：

1. **[传输介质](https://baike.baidu.com/item/传输介质/5538029)不同**
   + CSMA/CD用于总线式以太网
   + CSMA/CA用于无线局域网802.11a/b/g/n等。

2. **检测方式不同**

   + CSMA/CD通过电缆中**电压的变化**来检测，当数据发生碰撞时，[电缆](https://baike.baidu.com/item/电缆/5942260)中的电压就会随着发生变化

   + CSMA/CA采用**能量检测（ED）**、**载波检测（CS）**和**能量载波**混合检测三种检测信道空闲的方式。

3. WLAN信号覆盖

   对于[WLAN](https://baike.baidu.com/item/WLAN/612199)中的某个结点，其刚刚发出的信号强度要远高于来自其他结点的信号强度，也就是说它自己的信号会把其他的信号覆盖掉。

4. **在WLAN中，本结点处有冲突并不意味着在接收结点处就有冲突**

> [CSMA/CA--百度百科](https://baike.baidu.com/item/CSMA%2FCA/10898090?fr=aladdin)
>
> [急求CSMA/CD与CSMA/CA的区别！！！~](https://zhidao.baidu.com/question/339856527.html)
>
> [CSMA/CD 与 CSMA/CA概述](https://blog.csdn.net/ljh618625/article/details/86151428) <== 有图，建议阅读。这里只截取部分文字
>
> 1. CSMA/CD主要着眼点在冲突的**侦测**，当侦测到冲突时，进行相应的处理，**要求设备能一边侦测一边发送数据**。 
> 2. CSMA/CA主要着眼点在冲突的**避免**，协议里也看到经常是等待一段时间再做动作，通过退避尽量去避免冲突，还有就是先发送一些特别小的信道侦测帧来测试信道是否有冲突。