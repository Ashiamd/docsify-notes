# äºŒå‰æœç´¢æ ‘

> [æ¢ç´¢--äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/leetbook/detail/introduction-to-data-structure-binary-search-tree/)

## 01 æ¦‚è¿°

## 02 äºŒå‰æœç´¢æ ‘ç®€ä»‹

### éªŒè¯äºŒå‰æœç´¢æ ‘

è¯­è¨€ï¼šjava

æ€è·¯ï¼šé€’å½’å·¦å³å­æ ‘ï¼Œå¦‚æœå‡ºç°é å·¦<æ ¹<å³çš„æƒ…å†µï¼Œåˆ™è¿”å›falseã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯å·¦å³å­—æ•°çš„é€’å½’è°ƒç”¨ï¼Œé€’å½’å³å­æ ‘æ—¶ï¼Œä¸»è¦è€ƒè™‘åŸèŠ‚ç‚¹æ˜¯å¦å¤§äºç­‰äºå³å­æ ‘çš„å€¼ï¼›é€’å½’å·¦å­æ ‘æ—¶ä¸»è¦åˆ¤æ–­åŸèŠ‚ç‚¹æ˜¯å°äºç­‰äºåŸèŠ‚ç‚¹ã€‚

ä»£ç ï¼ˆ0msï¼‰ï¼š

```java
class Solution {
  public boolean isValidBST(TreeNode root) {
    return dfs(root, null, null);
  }

  public boolean dfs(TreeNode cur, Integer low, Integer high) {
    if (cur == null) {
      return true;
    }
    if (low != null && cur.val <= low) {
      return false;
    }
    if (high != null && cur.val >= high) {
      return false;
    }
    if (!dfs(cur.right, cur.val, high)) {
      return false;
    }
    if (!dfs(cur.left, low, cur.val)) {
      return false;
    }
    return true;
  }
}
```

å‚è€ƒä»£ç 1ï¼ˆ0msï¼‰ï¼š

> [ä¸­åºéå†è½»æ¾æ‹¿ä¸‹ï¼ŒğŸ¤·â€â™€ï¸å¿…é¡»ç§’æ‡‚](https://leetcode-cn.com/problems/validate-binary-search-tree/solution/zhong-xu-bian-li-qing-song-na-xia-bi-xu-miao-dong-/)

ä½¿ç”¨ä¸€ä¸ª`long`å­—æ®µä¿å­˜ä¸Šä¸€ä¸ªèŠ‚ç‚¹å€¼ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦ç¬¦åˆå·¦<æ ¹<å³

```java
class Solution {
  long pre = Long.MIN_VALUE;
  public boolean isValidBST(TreeNode root) {
    if (root == null) {
      return true;
    }
    // è®¿é—®å·¦å­æ ‘
    if (!isValidBST(root.left)) {
      return false;
    }
    // è®¿é—®å½“å‰èŠ‚ç‚¹ï¼šå¦‚æœå½“å‰èŠ‚ç‚¹å°äºç­‰äºä¸­åºéå†çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¯´æ˜ä¸æ»¡è¶³BSTï¼Œè¿”å› falseï¼›å¦åˆ™ç»§ç»­éå†ã€‚
    if (root.val <= pre) {
      return false;
    }
    pre = root.val;
    // è®¿é—®å³å­æ ‘
    return isValidBST(root.right);
  }
}
```

### äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨

è¯­è¨€ï¼šjava

æ€è·¯ï¼šå°±ä¸­åºéå†ï¼Œç”¨`List`å­˜å‚¨éå†åˆ°çš„å€¼ã€‚ä½†æ˜¯è¿™ä¸ªä¸ç¬¦åˆè¦æ±‚çš„ç©ºé—´å¤æ‚åº¦`O(h)`

ä»£ç ï¼ˆ23msï¼Œ92.96%ï¼‰ï¼š

```java
class BSTIterator {
  List<Integer> res;
  int index = 0;
  public BSTIterator(TreeNode root) {
    res = new ArrayList<>();
    dfs(root);
  }

  public void dfs(TreeNode root){
    if(root==null){
      return;
    }
    dfs(root.left);
    res.add(root.val);
    dfs(root.right);
  }

  /** @return the next smallest number */
  public int next() {
    return res.get(index++);
  }

  /** @return whether we have a next smallest number */
  public boolean hasNext() {
    return index<res.size();
  }
}
```

å‚è€ƒä»£ç 1ï¼ˆ21msï¼Œ99.513%ï¼‰ï¼š

> [äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨--å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/binary-search-tree-iterator/solution/er-cha-sou-suo-shu-die-dai-qi-by-leetcode/)

å—æ§é€’å½’ã€‚ä½¿ç”¨æ ˆã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode(int x) { val = x; }
 * }
 */
class BSTIterator {

  Stack<TreeNode> stack;

  public BSTIterator(TreeNode root) {

    // Stack for the recursion simulation
    this.stack = new Stack<TreeNode>();

    // Remember that the algorithm starts with a call to the helper function
    // with the root node as the input
    this._leftmostInorder(root);
  }

  private void _leftmostInorder(TreeNode root) {

    // For a given node, add all the elements in the leftmost branch of the tree
    // under it to the stack.
    while (root != null) {
      this.stack.push(root);
      root = root.left;
    }
  }

  /**
     * @return the next smallest number
     */
  public int next() {
    // Node at the top of the stack is the next smallest element
    TreeNode topmostNode = this.stack.pop();

    // Need to maintain the invariant. If the node has a right child, call the 
    // helper function for the right child
    if (topmostNode.right != null) {
      this._leftmostInorder(topmostNode.right);
    }

    return topmostNode.val;
  }

  /**
     * @return whether we have a next smallest number
     */
  public boolean hasNext() {
    return this.stack.size() > 0;
  }
}
```

