# 《代码大全2》-读书笔记

> 个人认为相对重要的章节，标注*（星号）

# 阅读指南

1. 初级程序员：优先18章
2. 高级程序员：优先4章
3. 项目经理：优先33章
4. 低年级学生：优先11章
5. 高年级学生：优先8章
6. 制定编码标准的人：优先32章
7. 自学编程的人：优先7章
8. 喜欢参与网上争议的人：13.3和17.3

# 第1部分 打好基础

# 第1章 欢迎进入软件构建的世界

## 1.1 什么是软件构建

软件开发过程中的不同活动：

+ 定义问题
+ 需求分析
+ 规划构建
+ 软件架构，高层设计
+ 详细设计
+ 编码与调试
+ 单元测试
+ 集成测试
+ 集成
+ 系统测试
+ 保障维护

## 1.2 软件构建为何如此重要

## 1.3 如何阅读本书

# 第2章 用隐喻来更充分地理解软件开发

## 2.1 隐喻的重要性

类比，比较， 最后使用隐喻表述，即“建模”(modeling)。

## 2.2 如何使用软件隐喻

将问题有效地概念化。（个人理解上就是将问题拆解成通俗、广为人知的小问题或者概念，而不是指一昧地造词增加理解难度）

## 2.3 常见的软件隐喻

+ 隐喻是启示而不是算法。因此它们往往有一点随意（sloopy）。
+ 隐喻把软件开发过程与其他你熟系的活动联系在一起，帮助你更好地理解。 有些隐喻比其他一些隐喻更贴切。
+ 通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备 是必要的，而大型项目和小型项目之间也是有差异的。
+ 通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程 序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制 宜地选择正确工具是成为能有效编程的程序员的关键。
+ 不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。

# 第3章 三思而后行: 前期准备

## 3.1 前期准备的重要性

造成准备工作不充分的常见原因：

1. 开发人员本身不具备做前期准备的专业技能能力
2. 无法抵抗快速开始代码工作的欲望
3. 管理者轻视准备工作并压缩开发者的工作时间

##  3.2 辨明你所从事的软件的类型

## 3.3 问题定义的先决条件

除非问题本身背景就是程序本身，否则尽量使用客户语言（非程序语言）表述问题本身，并且通常不需要夹带自认为的解决方案（初衷是好的，但是自认为的解决方案本身不一定是正确的或者合适的）

## 3.4 需求的先决条件

开发前明确需求，减少分歧以及开发中额外增加工作量打乱节奏。

1. 确保每一个人都知道需求变更的代价（比如产品可能灵光一闪需要加改动，那么需要明确周知改动量和排期变动，而不是在现有排期无脑追加工作量）
2. 建立一套变更控制程序（遇到频繁变更需求要求的场景，和客户协商变更流程，而非一股脑接收随时提出的变更）
3. 使用能适应变更的开发方法（即有些时候可以先做一部分设计，然后和客户对齐需求，如果没有歧义，继续响应剩余的需求内容，完成设计）
4. 放弃这个项目（如果项目本身捉摸不定，那么可以协商取消）
5. **注意项目的商业案例**（如果需求本身没有带来商业收益，可以此为理由拒绝部分需求内容）

## * 3.5 架构的先决条件

+ 程序组织
  1. 架构需要有明确的主要的类，以及说明这些主要的类之间如何联系和工作
+ 主要的类

  1. 架构应该给出选用当前架构的理由（这个比较理想，不乏使用新架构仅仅是KPI考核的情况）

  1. 架构无需详细说明系统每一个类，但对于构成系统的80%行为的20%的类应该详细说明（也就是和整个架构执行流程强相关的重点类，应该详细说明，比如链式调用流程等等）
+ 数据设计

  1. 主要的文件和数据表的设计应该具体描述技术选型和原因（比如设计顺序访问的ID，那么需要比较顺序访问ID和随机访问ID在该场景下的优劣和选择原因）
  2. **数据通常只应该由一个子系统或者一个类直接访问**：例外的情况就是透过访问器类（access class）或访问器子程序（access routine）——以受控且抽象的方式来访问数据。（实际开发中一般也建议某一个MySQL表统一由某个类完成CRUD访问，或者只由某个RPC服务负责提供CRUD该数据表的接口）
  3. 架构应该详细定义所用数据库的高层组织结构和内容。应该解释为什么单个数据库比多个数据库好（反之亦然），解释为什么不用平坦的文件而是数据库，指出与其他访问统一数据的程序的可能交互方式（比如提供RPC接口等），说明创建哪些数据视图（view），等等。
+ 业务规则

  1. 如果架构依赖于特定的业务规则，就应该详细描述这些业务规则，并描述规则对系统设计的影响。
+ 用户界面设计

  1. 通常用户界面在需求阶段进行详细说明（一般指前端UI页面设计等，通常和前端有关，另外可能影响后端接口交互形式）。如果没有，则应该在软件架构中进行详细说明。

  2. 架构应该模块化，以便在替换成新用户界面时不影响业务规则和程序的输出部分。
+ 资源管理

  1. **架构应该描述一份管理稀缺资源的计划。稀缺资源包括数据库连接，线程，句柄（handle）等**。
+ 安全性

  1. 架构应该描述实现设计层面和代码层面的安全性的方法。（比如数据应该编码后再入库，避免XSS攻击等；SQL应该预编译处理避免SQL注入攻击；cookie内仅存储加密后的数据等等）
+ 性能

  1. 如果需要关注性能，需求中应详细定义性能目标。（比如接口耗时，内存使用，机器资源成本等）
  2. 架构应该提供估计的数据，并解释为什么能达到性能目标。（比如预估Redis使用的内存并申请资源）
+ 可扩展性（可伸缩性）

  1. 架构设计时应考虑如何应对用户数量，服务器数量，网络节点数量，数据库记录数，数据库记录的长度，交易量的增长。
+ 互用性

  1. 如果预计这个系统会和其他软件或硬件共享数据和资源，架构需描述如何完成该任务。（比如通过RPC统一收口某些资源的访问等等）
+ 国际化/本地化

  1. 交互系统，需要架构留意国际化问题，并说明如何设计实现以及原因（比如状态显示，异常文案，帮助信息等如何国际化，一般会开发一套内部的译文平台用于统一管理）
+ 输入/输出

  1. 输入输出(I/O)是架构中值得注意的另一个领域。架构应该详细定义读取策略 (reading scheme)是先做(look-ahead)、后做(look-behind)还是即时做(just-in-time)。 而且应该描述在哪一层检测I/O错误：在字段、记录、流，或者文件的层次。
+ 错误处理

  1. 错误处理，是纠正还是仅检测（纠正比如超出分页范围，则采用指定的最大分页范围；检测即超出最大值直接抛出异常）
  2. 错误检测，主动还是被动（主动：比如界面在输入完后停顿1s检测输入合法性；被动：比如表单上传后，再对数据校验报错）
  3. 如何传播错误，忽略错误数据继续处理剩余数据；遇到错误则进入错误处理状态；等到所有处理结束后，统一汇总错误信息并返回
  4. 错误消息处理的约定，架构应该建设一套有关错误消息的约定（比如后端统一的异常处理器，前端则采用相同样式的异常消息吐司提示框）
  5. **如何处理异常，架构应规定代码何时能抛出异常，什么地方捕获异常，如何记录log异常，以及如何在文档中描述异常**
  6. 在什么层次处理错误，发现异常的地方处理；错误传递到专门的处理类上；沿函数调用链向上传递错误
  7. **每个类在验证输入的有效性方面该负何种责任，每个类单独负责验证自己的数据有效性，还是一组类负责验证整个系统数据的有效性，某个层级上的类是否能假设自己接收的数据是干净的(无错误的)**（举例子，在DDD领域开发模式下，很可能不同类针对不同业务场景对相同字段会有不同的校验规则，或者同一个字段的不同校验规则维护到某一个类中；还有就是不同业务各自针对同一个字段维护不同的业务校验逻辑，并且在业务调用链路上彼此不影响）
  8. 错误处理机制，采用运行环境内建的错误处理机制，或者自建一套机制（通常针对业务抛出的异常有统一的异常处理方式；而其他非主动捕获的运行时异常再用另一个统一处理器处理）
+ 容错性
  1. 如果可能的话从错误中恢复；如果不能的话则包容其不利影响
+ 架构的可行性
  1. 性能，资源，网络环境等，架构需要论证系统的技术可行性
+ 过度工程
  1. 架构应该清楚地指出程序员应该“为了谨慎起见宁可进行过度工程”，还是应该作出最简单的能工作的东西
+ 买or造轮子的决策
  1. 架构如果不采用现货供应的组件， 那么应该说明“自己定制的组件应在哪些方面胜过现成的程序库和组件”。
+ 关于复用的决策
  1. 如果复用已存在的软件、测试用例、数据格式或其他原料，架构应该说明：如何对复用的软件进行加工，使之符合其他架构目标
+ 变更策略
  1. 架构应该尽量灵活，以适应可能出现的变化
  2. 架构应该清楚地描述处理变更的策略，尽可能料想可能的变化以及应对方案（比如增加版本字段，或对代码生成器只需简单修改）
  3. 架构应提出“延迟提交”所用的策略（比如或许该规定使用表驱动技术，规定表保存在外部文件，而非直接硬编码代码，或许能做到不重新编译的情况下修改程序，等等）
+ 架构的总体质量
  1. 架构不应该包含任何仅仅为了取悦老板的东西
  2. 架构不应该包含任何对自己而言很难理解的东西
  3. 架构只包含需要的部分，不为了镀金而做多余的部分

## 3.6 花费在前期准备上的时间长度

一个良好运作的项目会在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间。如果有必要，架构工作也可以作为独立的项目来对待（比如遗老项目整体维护成本特别高，可能需要考虑小组一同按照新架构进行业务迁移）

# 第4章 关键的"构建"决策

## 4.1 选择编程语言

## 4.2 编程约定

在"构建"开始之前，讲清楚使用的编程约定。编程约定细节要达到这样的精确度：在编写完软件之后，几乎不可能改变（翻新）软件所遵循的编码约定。

## 4.3 你在技术浪潮中的位置

## 4.4 选择主要的构建实践方法

+ 每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点。 
+ **在开始编程之前，做好一些约定（convention）。“改变代码使之符合这些约定”是近乎不可能的。**
+ “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法。
+ 问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制?请记得“深入一种语言去编程”，不要仅“在一种语言上编程”。 
+ 你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标。

# 第2部分 创建高质量的代码

# 第5章 软件构建中的设计

## 5.1 设计中的挑战

## 5.2 关键的设计概念

高质量的设计具有很多常见的特征，常见的有：

1. 最小的复杂度
2. 易于维护
3. 松散耦合
4. 可扩展性
5. 可重用性
6. 高扇入（大量的类使用某个给定的类，系统很好地利用了较低层级上的工具类）
7. 低扇出（一个类中少量或适中地使用其他的类）
8. 可移植性
9. 精简性
10. 层次性
11. 标准技术

## * 5.3 设计构造块: 启发式方法

查阅常用的设计模式：适配器，桥接，装饰器，外观，工厂方法，观察者，单件，策略，模板方法。

常见的设计模式

| 模式     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 抽象工厂 | 通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象 |
| 适配器   | 把一个类的接口转变成另一个接口                               |
| 桥接     | 把接口和实现分离开来，使它们可以独立地变化                   |
| 组合     | 创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象 |
| 装饰器   | 给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类（派生类） |
| 外观     | 为没有提供一致接口的代码提供一个一致的接口                   |
| 工厂方法 | 做特定基类的派生类的实例化时，除了在Factory Method内部之外的均无须了解各派对象的具体类型 |
| 迭代器   | 提供一个服务对象来顺序地访问一组元素中的各个元素             |
| 观察者   | 使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象 |
| 单例     | 为有且仅有一个实例的类提供一种全局访问功能                   |
| 策略     | 定义一组算法或行为，使得它们可以动态地相互替换               |
| 模板方法 | 定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类） |

## 5.4 设计实践

## 5.5 对流行的设计方法的评论

# 第6章 可以工作的类

## * 6.1 类的基础: 抽象数据类型(ADTs)

使用ADT的好处：

1. 可以隐藏实现细节（比如文字素材设计，包含大小，单位，字体等属性，封装后可随时单独拓展）
2. 改动不会影响到整个程序
3. 让接口能提供更多信息
4. 更容易提高性能
5. 让程序的正确性更显而易见
6. 程序更具自我说明性
7. 无须在程序内到处传递数据
8. 你可以像在现实世界中那样操作实体，而不用在底层实现上操作它
9. 把常见的底层数据结构创建为ADT并使用这些ADT，而不再使用底层数据类型（常见的有高级语言已经封装好的队列，栈，数组等数据结构；以及一些中间件会根据实际情况封装特别的数据结构，如从后往前添加元素的队列等等）
10. 把像文件这样的常用对象当作ADT（高级语言通常会封装好磁盘文件操作的API）
11. 简单的事物也可当作ADT
12. 不要让ADT依赖于其存储介质（比如类名本身不携带File，好让未来可适配文件以外的其他存储方式）

## * 6.2 良好的类接口

1. 类的接口应该展现一致的抽象层次（把类仅当作一个ADT的实现，如果某个类实现了不止一种ADT，可能需要考虑拆分类实现）
2. 一定要理解类所实现的抽象是什么
3. 提供成对的服务（有些情况可能需要提供相反操作的方法）
4. 把不相关的信息转移到其他类中（比如类中一半子程序采用该类一半的数据，另一半子程序采用该类剩余的其他数据，那么此时可能实际需要拆分成两个类）
5. 尽可能让接口可编程，而不是表达语义（语义即人为要求某接口的使用方式，这些本身与编辑器代码检查无关）
6. 谨防在修改时破坏接口的抽象
7. 不要添加与接口抽象不一致的共用成员
8. 同时考虑抽象性和内聚性
9. 尽可能地限制类和成员的可访问性
10. 不要公开暴露成员数据
11. 避免把私用的实现细节放入类的接口中（举例C++中不建议把接口具体实现用到的私有成员变量声明到当前接口类中，而是只声明一个实现类指针，该实现类指针后续指向的实现类可以有多个自己私有成员变量）
12. 不要对类的使用者做出任何假设
13. 避免使用友元类（friend class）（一般情况下，C++的友元类会破坏封装）
14. 不要因为一个子程序里仅使用公用子程序，就把它归入公开接口
15. 让阅读代码比编写代码更方便（即不要为了省事把不相关的方法加入某个类中，而是考虑拆分维护一套新的接口和实现类）
16. 要格外警惕从语义上破坏封装性
17. 留意过于紧密的耦合关系

> [【C++】友元类 ( 友元类简介 | 友元类声明 | 友元类单向性 | 友元类继承性 | 友元类作用 | 友元类和友元函数由来 | Java 反射机制 | C / C++ 编译过程 )-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2342009)

## * 6.3 有关设计和实现的问题

+ 包含（has a）

  1. 通过包含来实现“有一个/has a”的关系
  2. 在万不得已时通过private继承来实现"有一个"的关系（C++）
  3. 警惕有超过约7个数据成员的类

+ 继承（is a）

  1. 用public继承来实现"是一个"的关系
  2. 要么使用继承并进行详细说明，要么就不要用它
  3. 遵循Liskov替换原则
  4. 确保只继承需要继承的部分
  5. 不要"覆盖"一个不可覆盖的成员函数
  6. 把共用的接口、数据及操作放到继承树中尽可能高的位置
  7. 只有一个实例的类是指的怀疑的
  8. 只有一个派生类的基类也值得怀疑
  9. 派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑
  10. **避免让继承体系过深**（实际工程不建议3层以上的继承关系，除非有把握封装得十分清晰合理。因为继承层级越多，在开发过程中，新增字段或方法时，就需更多考虑在哪一层级完成设计）
  11. **尽量使用多态，避免大量的类型检查**（部分场景如果有频繁的switch-case语句，或许多态会是一种解决方案）
  12. 让所有数据都是private（而非protected）（若派生类确实需要直接访问基类属性，可考虑提供protected访问器函数；当然声明protected能直接说明某个字段会用于派生类访问）

+ **何时使用继承（is a）或者包含（has a）**

  1. 如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象。
  2. 如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序。
  3. 如果多个类既共享数据也共享行为，应该让它们从一个共同的基类继承而 来，并在基类里定义共用的数据和子程序。
  4. 当你想由基类控制接口时，使用继承；当你想自己控制接口时，使用包含。

+ 成员函数和数据成员

  1. 让类中子程序的数量尽可能少
  2. 禁止隐式地产生你不需要的成员函数和运算符
  3. 减少类所调用的不同子程序的数量
  4. 对其他类的子程序的间接调用要尽可能少

  5. 一般来说，应尽量减少类和类之间互相合作的范围
  6. 如果可能，应该在所有的构造函数中初始化所有的数据成员
  7. 用私用(private)构造函数来强制实现单件属性(singleton property)
  8. 优先采用深层复本（deep copies），除非论证可行，才采用浅层复本（shallow copies）

## 6.4 创建类的原因

## 6.5 与具体编程语言相关的问题

## 6.6 超越类: 包

# 第7章 高质量的子程序

## 7.1 创建子程序的正当理由

## 7.2 在子程序上设计

## 7.3 好的子程序名字

## 7.4 子程序可以写多长

## 7.5 如何使用子程序参数

## 7.6 使用函数时要特别考虑的问题

## 7.7 宏子程序和内联子程序

# 第8章 防御式编程

## 8.1 保护程序免遭非法输入数据的破坏

## 8.2 断言

## 8.3 错误处理技术

1. 返回中立值（比如数值计算返回0，字符串返回''等）
2. 换用下一个正确的数据（比如数据流返回下一个正确的数据）
3. 返回与前次相同的数据（比如温度测量，上一次10ms观测到的数据可以沿用）
4. 换用最接近的合法值（比如不该出现负数的场景，若计算错误得到负数则返回0）
5. 把警告信息记录到日志文件中
6. 返回一个错误码
7. 调用错误处理子程序或对象
8. 当错误发生时显示出错消息
9. 用最稳妥的方式在局部处理错误
10. 关闭程序

## 8.4 异常

## 8.5 隔离程序, 使之包容由错误造成的损害

## 8.6 辅助调试的代码

## 8.7 确定在产品代码中该保留多少防御式代码

## 8.8 对防御式编程采取防御的姿态

# 第9章 伪代码编程过程

## 9.1 创建类和子程序的步骤概述

## 9.2 伪代码

## 9.3 通过伪代码编程过程创建子程序

## 9.4 伪代码编程过程的替代方案

# 第3部分 变量

# 第10章 使用变量的一般事项

## 10.1 数据认知

## 10.2 轻松掌握变量定义

## 10.3 变量初始化原则

1. 在声明变量的时候初始化
2. 在靠近变量第一次使用的位置初始化它
3. **理想情况下，在靠近第一次使用变量的位置声明和定义该变量**
4. 在可能的情况下使用final或者const
5. 特别注意计数器和累加器
6. 在类的构造函数里初始化该类的数据成员
7. 检查是否需要重新初始化
8. 一次性初始化具名常量：用可执行代码来初始化变量
9. 使用编译器设置来自动初始化所有变量
10. 利用编译器的警告信息
11. 检查输入参数的合法性
12. 使用内存访问检查工具来检查错误的指针
13. 在程序开始时初始化工作内存

## 10.4 作用域

1. 在循环开始之前再去初始化该循环里使用到的变量，而不是在该循环所属的子程序的开始处初始化这些变量
2. 直到变量即将被使用时在为其赋值
3. 把相关的语句放到一起
4. 把相关语句组提取成单独的子程序
5. 开始时采用最严格的可见性，然后根据需要扩展变量作用域

## 10.5 持续性

## 10.6 绑定时间

## 10.7 数据类型和控制结构之间的关系

## 10.8 为变量指定单一用途

# 第11章 变量名的力量

## 11.1 选择好变量名的注意事项

## 11.2 为特定类型的数据命名

## 11.3 命名规则的力量

## 11.4 非正式命名规则

## 11.5 标准前缀

## 11.6 创建具备可读性的短名字

## 11.7 应该避免的名字

# 第12章 基本数据类型

## 12.1 数据概论

## 12.2 整数

## 12.3 浮点数

## 12.4 字符和字符串

## 12.5 布尔变量

## 12.6 枚举类型

## 12.7 具名常量

## 12.8 数组

## 12.9 创建你自己的类型(类型别名)

# 第13章 不常见的数据类型

## 13.1 结构体

## * 13.2 指针

1. 把指针操作限制在子程序或者类里面
2. 同时声明和定义指针
3. 在与指针分配相同的作用域中删除指针
4. 在使用指针之前检查指针
5. 先检查指针所引用的变量再使用它
6. **用狗牌字段来检测损毁的内存（即指针指向的对象或结构体，特地分配一个不变量，使用或释放指针内存时，检查该不变量的值，确保指针指向的内存正常。准备释放指针时记得修改标志字段或狗牌字段，避免下次误以为该内存仍有效）**
7. 增加明显的冗余（比如某些字段故意重复两次，如果冗余的数据不匹配，则视为数据被破坏了）
8. 用额外的指针变量来提高代码清晰度
9. 简化复杂的指针表达式
10. 按照正确的顺序删除链表中的指针
11. **分配一片保留的内存后备区域（在程序初始化阶段就把部分内存分配出来做后备，避免后续执行时内存分配不足导致程序错误只能丢失先前已经在内存计算好的数据）**
12. 粉碎垃圾数据
13. 在删除或者释放指针之后把它们设为空值
14. 在删除变量之前检查非法指针
15. 跟踪指针分配情况（比如额外用一个列表维护已经分配的指针情况）
16. 编写覆盖子程序，集中实现避免指针问题的策略
17. 采用非指针的技术
18. **理解指针和引用之间的区别**（C++中，最重要的区别，引用必须总是引用一个对象，而指针则可以指向空值；引用指向的对象在该引用初始化之后不能改变）
19. **把指针用于"按引用传递"参数，把const引用用于"按值传递"参数**
20. **使用auto_ptr**（C++11已弃用，可考虑其他智能指针如share_ptr, unique_ptr, weak_prt。通过在离开作用域的时候自动释放内存，auto_ptr能避免很多于常规指针相关的内存泄漏问题）
21. **灵活运用智能指针**
22. 使用显式指针类型而不是默认类型
23. 避免强制类型转换
24. 遵循参数传递的星号规则（在C语言中，只有当你赋值语句的参数前面加了星号，才能把参数从子程序中传回去）
25. **在内存分配中使用`sizeof()`确定变量的大小**

> [C++ --- 智能指针 - 流水灯 - 博客园 (cnblogs.com)](https://www.cnblogs.com/god-of-death/p/17962676)

## 13.3 全局数据

# 第4部分 语句

# 第14章 组织直线型代码

## 14.1 必须有明确顺序的语句

## 14.2 顺序无关的语句

# 第15章 使用条件语句

## 15.1 if语句

1. 首先写正常代码路径；再处理不常见情况
2. 确保对于等量的分支是正确的（也就是注意区分小于和小于等于之类的）
3. 把正常情况的处理放在if后面而不要放在else后面
4. 让if后面跟随一个有意义的语句
5. 考虑else子句
6. 测试else子句的正确性
7. 检查if和else子句是不是弄反了
8. 利用布尔函数调用简化复杂的检测
9. 把最常见的情况放在最前面
10. 确保所有的情况都考虑到了
11. 如果你的语言支持，请把if-then-else串替换成其他结构

## 15.2 case语句

1. 按字母顺序或数字顺序排列各种情况
2. 把正常的情况放在前面
3. 按执行频率排列case子句
4. 简化每种情况对应的操作
5. 不要为了使用case语而刻意制造一个变量
6. 把default子句只用于检查真正的默认情况
7. 利用default子句来检测错误（实际开发中常见用法，即列举的case都不符合，则默认视为不兼容或者未开发的逻辑分支，抛异常或走默认逻辑）
8. 在C++里，在case末尾明确无误地标明需要穿越执行的程序流程

# 第16章 控制循环

## 16.1 选择循环的种类

1. 计数循环

2. 连续求值的循环

3. 无限循环

4. 迭代器循环

## * 16.2 循环控制

+ 进入循环
  1. 只从一个位置进入循环
  2. 把初始化代码紧放在循环前面
  3. 用`while(true)`表示无限循环
  4. 在适当的情况下多使用for循环
  5. 在while循环更适用的时候，不要使用for循环

+ 处理好循环体
  1. 循环体用大括号维护
  2. 避免空循环
  3. 把循环内务操作要么放在循环的开始，要么放在循环的末尾
  4. 一个循环只做一件事
+ 退出循环
  1. 设法确认循环能够终止
  2. 使循环终止条件看起来很明显
  3. 不要为了终止循环而胡乱改动for循环的下标
  4. 避免出现依赖于循环下标最终取值的代码
  5. 考虑使用安全计数器
+ 提前退出循环
  1. 考虑在while循环中使用break语句而不使用布尔标记
  2. 小心那些有很多break散布在其中的循环
  3. 在循环开始处使用continue进行判断
  4. **如果语言支持，请使用带标号break接口**（java支持labeled break）
  5. 使用break和continue时要小心谨慎
+ 循环应该有多长
  1. 循环要尽可能地短，以便能够一目了然
  2. 把嵌套限制在3层以内
  3. 把长循环的内容移到子程序里
  4. 要让长循环格外清晰

## 16.3 轻松创建循环——由内而外

## 16.4 循环和数组的关系

# 第17章 不常见的控制结构

## 17.1 子程序的多处返回

## 17.2 递归

## 17.3 goto

## 17.4 针对不常见控制结构的观点

# 第18章 表驱动法

# 第19章 一般控制问题

