# 《代码大全2》-读书笔记

> 个人认为相对重要的章节，标注*（星号）

# 阅读指南

1. 初级程序员：优先18章
2. 高级程序员：优先4章
3. 项目经理：优先33章
4. 低年级学生：优先11章
5. 高年级学生：优先8章
6. 制定编码标准的人：优先32章
7. 自学编程的人：优先7章
8. 喜欢参与网上争议的人：13.3和17.3

# 第1部分 打好基础

# 第1章 欢迎进入软件构建的世界

## 1.1 什么是软件构建

软件开发过程中的不同活动：

+ 定义问题
+ 需求分析
+ 规划构建
+ 软件架构，高层设计
+ 详细设计
+ 编码与调试
+ 单元测试
+ 集成测试
+ 集成
+ 系统测试
+ 保障维护

## 1.2 软件构建为何如此重要

## 1.3 如何阅读本书

# 第2章 用隐喻来更充分地理解软件开发

## 2.1 隐喻的重要性

类比，比较， 最后使用隐喻表述，即“建模”(modeling)。

## 2.2 如何使用软件隐喻

将问题有效地概念化。（个人理解上就是将问题拆解成通俗、广为人知的小问题或者概念，而不是指一昧地造词增加理解难度）

## 2.3 常见的软件隐喻

+ 隐喻是启示而不是算法。因此它们往往有一点随意（sloopy）。
+ 隐喻把软件开发过程与其他你熟系的活动联系在一起，帮助你更好地理解。 有些隐喻比其他一些隐喻更贴切。
+ 通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备 是必要的，而大型项目和小型项目之间也是有差异的。
+ 通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程 序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制 宜地选择正确工具是成为能有效编程的程序员的关键。
+ 不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。

# 第3章 三思而后行: 前期准备

## 3.1 前期准备的重要性

造成准备工作不充分的常见原因：

1. 开发人员本身不具备做前期准备的专业技能能力
2. 无法抵抗快速开始代码工作的欲望
3. 管理者轻视准备工作并压缩开发者的工作时间

##  3.2 辨明你所从事的软件的类型

## 3.3 问题定义的先决条件

除非问题本身背景就是程序本身，否则尽量使用客户语言（非程序语言）表述问题本身，并且通常不需要夹带自认为的解决方案（初衷是好的，但是自认为的解决方案本身不一定是正确的或者合适的）

## 3.4 需求的先决条件

开发前明确需求，减少分歧以及开发中额外增加工作量打乱节奏。

1. 确保每一个人都知道需求变更的代价（比如产品可能灵光一闪需要加改动，那么需要明确周知改动量和排期变动，而不是在现有排期无脑追加工作量）
2. 建立一套变更控制程序（遇到频繁变更需求要求的场景，和客户协商变更流程，而非一股脑接收随时提出的变更）
3. 使用能适应变更的开发方法（即有些时候可以先做一部分设计，然后和客户对齐需求，如果没有歧义，继续响应剩余的需求内容，完成设计）
4. 放弃这个项目（如果项目本身捉摸不定，那么可以协商取消）
5. **注意项目的商业案例**（如果需求本身没有带来商业收益，可以此为理由拒绝部分需求内容）

## * 3.5 架构的先决条件

+ 程序组织
  1. 架构需要有明确的主要的类，以及说明这些主要的类之间如何联系和工作
+ 主要的类

  1. 架构应该给出选用当前架构的理由（这个比较理想，不乏使用新架构仅仅是KPI考核的情况）

  1. 架构无需详细说明系统每一个类，但对于构成系统的80%行为的20%的类应该详细说明（也就是和整个架构执行流程强相关的重点类，应该详细说明，比如链式调用流程等等）
+ 数据设计

  1. 主要的文件和数据表的设计应该具体描述技术选型和原因（比如设计顺序访问的ID，那么需要比较顺序访问ID和随机访问ID在该场景下的优劣和选择原因）
  2. **数据通常只应该由一个子系统或者一个类直接访问**：例外的情况就是透过访问器类（access class）或访问器子程序（access routine）——以受控且抽象的方式来访问数据。（实际开发中一般也建议某一个MySQL表统一由某个类完成CRUD访问，或者只由某个RPC服务负责提供CRUD该数据表的接口）
  3. 架构应该详细定义所用数据库的高层组织结构和内容。应该解释为什么单个数据库比多个数据库好（反之亦然），解释为什么不用平坦的文件而是数据库，指出与其他访问统一数据的程序的可能交互方式（比如提供RPC接口等），说明创建哪些数据视图（view），等等。
+ 业务规则

  1. 如果架构依赖于特定的业务规则，就应该详细描述这些业务规则，并描述规则对系统设计的影响。
+ 用户界面设计

  1. 通常用户界面在需求阶段进行详细说明（一般指前端UI页面设计等，通常和前端有关，另外可能影响后端接口交互形式）。如果没有，则应该在软件架构中进行详细说明。

  2. 架构应该模块化，以便在替换成新用户界面时不影响业务规则和程序的输出部分。
+ 资源管理

  1. **架构应该描述一份管理稀缺资源的计划。稀缺资源包括数据库连接，线程，句柄（handle）等**。
+ 安全性

  1. 架构应该描述实现设计层面和代码层面的安全性的方法。（比如数据应该编码后再入库，避免XSS攻击等；SQL应该预编译处理避免SQL注入攻击；cookie内仅存储加密后的数据等等）
+ 性能

  1. 如果需要关注性能，需求中应详细定义性能目标。（比如接口耗时，内存使用，机器资源成本等）
  2. 架构应该提供估计的数据，并解释为什么能达到性能目标。（比如预估Redis使用的内存并申请资源）
+ 可扩展性（可伸缩性）

  1. 架构设计时应考虑如何应对用户数量，服务器数量，网络节点数量，数据库记录数，数据库记录的长度，交易量的增长。
+ 互用性

  1. 如果预计这个系统会和其他软件或硬件共享数据和资源，架构需描述如何完成该任务。（比如通过RPC统一收口某些资源的访问等等）
+ 国际化/本地化

  1. 交互系统，需要架构留意国际化问题，并说明如何设计实现以及原因（比如状态显示，异常文案，帮助信息等如何国际化，一般会开发一套内部的译文平台用于统一管理）
+ 输入/输出

  1. 输入输出(I/O)是架构中值得注意的另一个领域。架构应该详细定义读取策略 (reading scheme)是先做(look-ahead)、后做(look-behind)还是即时做(just-in-time)。 而且应该描述在哪一层检测I/O错误：在字段、记录、流，或者文件的层次。
+ 错误处理

  1. 错误处理，是纠正还是仅检测（纠正比如超出分页范围，则采用指定的最大分页范围；检测即超出最大值直接抛出异常）
  2. 错误检测，主动还是被动（主动：比如界面在输入完后停顿1s检测输入合法性；被动：比如表单上传后，再对数据校验报错）
  3. 如何传播错误，忽略错误数据继续处理剩余数据；遇到错误则进入错误处理状态；等到所有处理结束后，统一汇总错误信息并返回
  4. 错误消息处理的约定，架构应该建设一套有关错误消息的约定（比如后端统一的异常处理器，前端则采用相同样式的异常消息吐司提示框）
  5. **如何处理异常，架构应规定代码何时能抛出异常，什么地方捕获异常，如何记录log异常，以及如何在文档中描述异常**
  6. 在什么层次处理错误，发现异常的地方处理；错误传递到专门的处理类上；沿函数调用链向上传递错误
  7. **每个类在验证输入的有效性方面该负何种责任，每个类单独负责验证自己的数据有效性，还是一组类负责验证整个系统数据的有效性，某个层级上的类是否能假设自己接收的数据是干净的(无错误的)**（举例子，在DDD领域开发模式下，很可能不同类针对不同业务场景对相同字段会有不同的校验规则，或者同一个字段的不同校验规则维护到某一个类中；还有就是不同业务各自针对同一个字段维护不同的业务校验逻辑，并且在业务调用链路上彼此不影响）
  8. 错误处理机制，采用运行环境内建的错误处理机制，或者自建一套机制（通常针对业务抛出的异常有统一的异常处理方式；而其他非主动捕获的运行时异常再用另一个统一处理器处理）
+ 容错性
  1. 如果可能的话从错误中恢复；如果不能的话则包容其不利影响
+ 架构的可行性
  1. 性能，资源，网络环境等，架构需要论证系统的技术可行性
+ 过度工程
  1. 架构应该清楚地指出程序员应该“为了谨慎起见宁可进行过度工程”，还是应该作出最简单的能工作的东西
+ 买or造轮子的决策
  1. 架构如果不采用现货供应的组件， 那么应该说明“自己定制的组件应在哪些方面胜过现成的程序库和组件”。
+ 关于复用的决策
  1. 如果复用已存在的软件、测试用例、数据格式或其他原料，架构应该说明：如何对复用的软件进行加工，使之符合其他架构目标
+ 变更策略
  1. 架构应该尽量灵活，以适应可能出现的变化
  2. 架构应该清楚地描述处理变更的策略，尽可能料想可能的变化以及应对方案（比如增加版本字段，或对代码生成器只需简单修改）
  3. 架构应提出“延迟提交”所用的策略（比如或许该规定使用表驱动技术，规定表保存在外部文件，而非直接硬编码代码，或许能做到不重新编译的情况下修改程序，等等）
+ 架构的总体质量
  1. 架构不应该包含任何仅仅为了取悦老板的东西
  2. 架构不应该包含任何对自己而言很难理解的东西
  3. 架构只包含需要的部分，不为了镀金而做多余的部分

## 3.6 花费在前期准备上的时间长度

一个良好运作的项目会在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间。如果有必要，架构工作也可以作为独立的项目来对待（比如遗老项目整体维护成本特别高，可能需要考虑小组一同按照新架构进行业务迁移）

# 第4章 关键的"构建"决策

## 4.1 选择编程语言

## 4.2 编程约定

在"构建"开始之前，讲清楚使用的编程约定。编程约定细节要达到这样的精确度：在编写完软件之后，几乎不可能改变（翻新）软件所遵循的编码约定。

## 4.3 你在技术浪潮中的位置

## 4.4 选择主要的构建实践方法

+ 每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点。 
+ **在开始编程之前，做好一些约定（convention）。“改变代码使之符合这些约定”是近乎不可能的。**
+ “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法。
+ 问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制?请记得“深入一种语言去编程”，不要仅“在一种语言上编程”。 
+ 你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标。

# 第2部分 创建高质量的代码

# 第5章 软件构建中的设计

## 5.1 设计中的挑战

## 5.2 关键的设计概念

高质量的设计具有很多常见的特征，常见的有：

1. 最小的复杂度
2. 易于维护
3. 松散耦合
4. 可扩展性
5. 可重用性
6. 高扇入（大量的类使用某个给定的类，系统很好地利用了较低层级上的工具类）
7. 低扇出（一个类中少量或适中地使用其他的类）
8. 可移植性
9. 精简性
10. 层次性
11. 标准技术

## * 5.3 设计构造块: 启发式方法

查阅常用的设计模式：适配器，桥接，装饰器，外观，工厂方法，观察者，单件，策略，模板方法。

常见的设计模式

| 模式     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 抽象工厂 | 通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象 |
| 适配器   | 把一个类的接口转变成另一个接口                               |
| 桥接     | 把接口和实现分离开来，使它们可以独立地变化                   |
| 组合     | 创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象 |
| 装饰器   | 给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类（派生类） |
| 外观     | 为没有提供一致接口的代码提供一个一致的接口                   |
| 工厂方法 | 做特定基类的派生类的实例化时，除了在Factory Method内部之外的均无须了解各派对象的具体类型 |
| 迭代器   | 提供一个服务对象来顺序地访问一组元素中的各个元素             |
| 观察者   | 使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象 |
| 单例     | 为有且仅有一个实例的类提供一种全局访问功能                   |
| 策略     | 定义一组算法或行为，使得它们可以动态地相互替换               |
| 模板方法 | 定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类） |

## 5.4 设计实践

## 5.5 对流行的设计方法的评论

# 第6章 可以工作的类

## * 6.1 类的基础: 抽象数据类型(ADTs)

使用ADT的好处：

1. 可以隐藏实现细节（比如文字素材设计，包含大小，单位，字体等属性，封装后可随时单独拓展）
2. 改动不会影响到整个程序
3. 让接口能提供更多信息
4. 更容易提高性能
5. 让程序的正确性更显而易见
6. 程序更具自我说明性
7. 无须在程序内到处传递数据
8. 你可以像在现实世界中那样操作实体，而不用在底层实现上操作它
9. 把常见的底层数据结构创建为ADT并使用这些ADT，而不再使用底层数据类型（常见的有高级语言已经封装好的队列，栈，数组等数据结构；以及一些中间件会根据实际情况封装特别的数据结构，如从后往前添加元素的队列等等）
10. 把像文件这样的常用对象当作ADT（高级语言通常会封装好磁盘文件操作的API）
11. 简单的事物也可当作ADT
12. 不要让ADT依赖于其存储介质（比如类名本身不携带File，好让未来可适配文件以外的其他存储方式）

## * 6.2 良好的类接口

1. 类的接口应该展现一致的抽象层次（把类仅当作一个ADT的实现，如果某个类实现了不止一种ADT，可能需要考虑拆分类实现）
2. 一定要理解类所实现的抽象是什么
3. 提供成对的服务（有些情况可能需要提供相反操作的方法）
4. 把不相关的信息转移到其他类中（比如类中一半子程序采用该类一半的数据，另一半子程序采用该类剩余的其他数据，那么此时可能实际需要拆分成两个类）
5. 尽可能让接口可编程，而不是表达语义（语义即人为要求某接口的使用方式，这些本身与编辑器代码检查无关）
6. 谨防在修改时破坏接口的抽象
7. 不要添加与接口抽象不一致的共用成员
8. 同时考虑抽象性和内聚性
9. 尽可能地限制类和成员的可访问性
10. 不要公开暴露成员数据
11. 避免把私用的实现细节放入类的接口中（举例C++中不建议把接口具体实现用到的私有成员变量声明到当前接口类中，而是只声明一个实现类指针，该实现类指针后续指向的实现类可以有多个自己私有成员变量）
12. 不要对类的使用者做出任何假设
13. 避免使用友元类（friend class）（一般情况下，C++的友元类会破坏封装）
14. 不要因为一个子程序里仅使用公用子程序，就把它归入公开接口
15. 让阅读代码比编写代码更方便（即不要为了省事把不相关的方法加入某个类中，而是考虑拆分维护一套新的接口和实现类）
16. 要格外警惕从语义上破坏封装性
17. 留意过于紧密的耦合关系

> [【C++】友元类 ( 友元类简介 | 友元类声明 | 友元类单向性 | 友元类继承性 | 友元类作用 | 友元类和友元函数由来 | Java 反射机制 | C / C++ 编译过程 )-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2342009)

## * 6.3 有关设计和实现的问题

+ 包含（has a）

  1. 通过包含来实现“有一个/has a”的关系
  2. 在万不得已时通过private继承来实现"有一个"的关系（C++）
  3. 警惕有超过约7个数据成员的类

+ 继承（is a）

  1. 用public继承来实现"是一个"的关系
  2. 要么使用继承并进行详细说明，要么就不要用它
  3. 遵循Liskov替换原则
  4. 确保只继承需要继承的部分
  5. 不要"覆盖"一个不可覆盖的成员函数
  6. 把共用的接口、数据及操作放到继承树中尽可能高的位置
  7. 只有一个实例的类是指的怀疑的
  8. 只有一个派生类的基类也值得怀疑
  9. 派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑
  10. **避免让继承体系过深**（实际工程不建议3层以上的继承关系，除非有把握封装得十分清晰合理。因为继承层级越多，在开发过程中，新增字段或方法时，就需更多考虑在哪一层级完成设计）
  11. **尽量使用多态，避免大量的类型检查**（部分场景如果有频繁的switch-case语句，或许多态会是一种解决方案）
  12. 让所有数据都是private（而非protected）（若派生类确实需要直接访问基类属性，可考虑提供protected访问器函数；当然声明protected能直接说明某个字段会用于派生类访问）

+ **何时使用继承（is a）或者包含（has a）**

  1. 如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象。
  2. 如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序。
  3. 如果多个类既共享数据也共享行为，应该让它们从一个共同的基类继承而 来，并在基类里定义共用的数据和子程序。
  4. 当你想由基类控制接口时，使用继承；当你想自己控制接口时，使用包含。

+ 成员函数和数据成员

  1. 让类中子程序的数量尽可能少
  2. 禁止隐式地产生你不需要的成员函数和运算符
  3. 减少类所调用的不同子程序的数量
  4. 对其他类的子程序的间接调用要尽可能少

  5. 一般来说，应尽量减少类和类之间互相合作的范围
  6. 如果可能，应该在所有的构造函数中初始化所有的数据成员
  7. 用私用(private)构造函数来强制实现单件属性(singleton property)
  8. 优先采用深层复本（deep copies），除非论证可行，才采用浅层复本（shallow copies）

## 6.4 创建类的原因

## 6.5 与具体编程语言相关的问题

## 6.6 超越类: 包

# 第7章 高质量的子程序

## 7.1 创建子程序的正当理由

## 7.2 在子程序上设计

## 7.3 好的子程序名字

## 7.4 子程序可以写多长

## 7.5 如何使用子程序参数

## 7.6 使用函数时要特别考虑的问题

## 7.7 宏子程序和内联子程序

# 第8章 防御式编程

## 8.1 保护程序免遭非法输入数据的破坏

## 8.2 断言

## 8.3 错误处理技术

1. 返回中立值（比如数值计算返回0，字符串返回''等）
2. 换用下一个正确的数据（比如数据流返回下一个正确的数据）
3. 返回与前次相同的数据（比如温度测量，上一次10ms观测到的数据可以沿用）
4. 换用最接近的合法值（比如不该出现负数的场景，若计算错误得到负数则返回0）
5. 把警告信息记录到日志文件中
6. 返回一个错误码
7. 调用错误处理子程序或对象
8. 当错误发生时显示出错消息
9. 用最稳妥的方式在局部处理错误
10. 关闭程序

## 8.4 异常

## 8.5 隔离程序, 使之包容由错误造成的损害

## 8.6 辅助调试的代码

## 8.7 确定在产品代码中该保留多少防御式代码

## 8.8 对防御式编程采取防御的姿态

# 第9章 伪代码编程过程

## 9.1 创建类和子程序的步骤概述

## 9.2 伪代码

## 9.3 通过伪代码编程过程创建子程序

## 9.4 伪代码编程过程的替代方案

# 第3部分 变量

# 第10章 使用变量的一般事项

## 10.1 数据认知

## 10.2 轻松掌握变量定义

## 10.3 变量初始化原则

1. 在声明变量的时候初始化
2. 在靠近变量第一次使用的位置初始化它
3. **理想情况下，在靠近第一次使用变量的位置声明和定义该变量**
4. 在可能的情况下使用final或者const
5. 特别注意计数器和累加器
6. 在类的构造函数里初始化该类的数据成员
7. 检查是否需要重新初始化
8. 一次性初始化具名常量：用可执行代码来初始化变量
9. 使用编译器设置来自动初始化所有变量
10. 利用编译器的警告信息
11. 检查输入参数的合法性
12. 使用内存访问检查工具来检查错误的指针
13. 在程序开始时初始化工作内存

## 10.4 作用域

1. 在循环开始之前再去初始化该循环里使用到的变量，而不是在该循环所属的子程序的开始处初始化这些变量
2. 直到变量即将被使用时在为其赋值
3. 把相关的语句放到一起
4. 把相关语句组提取成单独的子程序
5. 开始时采用最严格的可见性，然后根据需要扩展变量作用域

## 10.5 持续性

## 10.6 绑定时间

## 10.7 数据类型和控制结构之间的关系

## 10.8 为变量指定单一用途

# 第11章 变量名的力量

## 11.1 选择好变量名的注意事项

## 11.2 为特定类型的数据命名

## 11.3 命名规则的力量

## 11.4 非正式命名规则

## 11.5 标准前缀

## 11.6 创建具备可读性的短名字

## 11.7 应该避免的名字

# 第12章 基本数据类型

## 12.1 数据概论

## 12.2 整数

## 12.3 浮点数

## 12.4 字符和字符串

## 12.5 布尔变量

## 12.6 枚举类型

## 12.7 具名常量

## 12.8 数组

## 12.9 创建你自己的类型(类型别名)

# 第13章 不常见的数据类型

## 13.1 结构体

## * 13.2 指针

1. 把指针操作限制在子程序或者类里面
2. 同时声明和定义指针
3. 在与指针分配相同的作用域中删除指针
4. 在使用指针之前检查指针
5. 先检查指针所引用的变量再使用它
6. **用狗牌字段来检测损毁的内存（即指针指向的对象或结构体，特地分配一个不变量，使用或释放指针内存时，检查该不变量的值，确保指针指向的内存正常。准备释放指针时记得修改标志字段或狗牌字段，避免下次误以为该内存仍有效）**
7. 增加明显的冗余（比如某些字段故意重复两次，如果冗余的数据不匹配，则视为数据被破坏了）
8. 用额外的指针变量来提高代码清晰度
9. 简化复杂的指针表达式
10. 按照正确的顺序删除链表中的指针
11. **分配一片保留的内存后备区域（在程序初始化阶段就把部分内存分配出来做后备，避免后续执行时内存分配不足导致程序错误只能丢失先前已经在内存计算好的数据）**
12. 粉碎垃圾数据
13. 在删除或者释放指针之后把它们设为空值
14. 在删除变量之前检查非法指针
15. 跟踪指针分配情况（比如额外用一个列表维护已经分配的指针情况）
16. 编写覆盖子程序，集中实现避免指针问题的策略
17. 采用非指针的技术
18. **理解指针和引用之间的区别**（C++中，最重要的区别，引用必须总是引用一个对象，而指针则可以指向空值；引用指向的对象在该引用初始化之后不能改变）
19. **把指针用于"按引用传递"参数，把const引用用于"按值传递"参数**
20. **使用auto_ptr**（C++11已弃用，可考虑其他智能指针如share_ptr, unique_ptr, weak_prt。通过在离开作用域的时候自动释放内存，auto_ptr能避免很多于常规指针相关的内存泄漏问题）
21. **灵活运用智能指针**
22. 使用显式指针类型而不是默认类型
23. 避免强制类型转换
24. 遵循参数传递的星号规则（在C语言中，只有当你赋值语句的参数前面加了星号，才能把参数从子程序中传回去）
25. **在内存分配中使用`sizeof()`确定变量的大小**

> [C++ --- 智能指针 - 流水灯 - 博客园 (cnblogs.com)](https://www.cnblogs.com/god-of-death/p/17962676)

## 13.3 全局数据

# 第4部分 语句

# 第14章 组织直线型代码

## 14.1 必须有明确顺序的语句

## 14.2 顺序无关的语句

# 第15章 使用条件语句

## 15.1 if语句

1. 首先写正常代码路径；再处理不常见情况
2. 确保对于等量的分支是正确的（也就是注意区分小于和小于等于之类的）
3. 把正常情况的处理放在if后面而不要放在else后面
4. 让if后面跟随一个有意义的语句
5. 考虑else子句
6. 测试else子句的正确性
7. 检查if和else子句是不是弄反了
8. 利用布尔函数调用简化复杂的检测
9. 把最常见的情况放在最前面
10. 确保所有的情况都考虑到了
11. 如果你的语言支持，请把if-then-else串替换成其他结构

## 15.2 case语句

1. 按字母顺序或数字顺序排列各种情况
2. 把正常的情况放在前面
3. 按执行频率排列case子句
4. 简化每种情况对应的操作
5. 不要为了使用case语而刻意制造一个变量
6. 把default子句只用于检查真正的默认情况
7. 利用default子句来检测错误（实际开发中常见用法，即列举的case都不符合，则默认视为不兼容或者未开发的逻辑分支，抛异常或走默认逻辑）
8. 在C++里，在case末尾明确无误地标明需要穿越执行的程序流程

# 第16章 控制循环

## 16.1 选择循环的种类

1. 计数循环

2. 连续求值的循环

3. 无限循环

4. 迭代器循环

## * 16.2 循环控制

+ 进入循环
  1. 只从一个位置进入循环
  2. 把初始化代码紧放在循环前面
  3. 用`while(true)`表示无限循环
  4. 在适当的情况下多使用for循环
  5. 在while循环更适用的时候，不要使用for循环

+ 处理好循环体
  1. 循环体用大括号维护
  2. 避免空循环
  3. 把循环内务操作要么放在循环的开始，要么放在循环的末尾
  4. 一个循环只做一件事
+ 退出循环
  1. 设法确认循环能够终止
  2. 使循环终止条件看起来很明显
  3. 不要为了终止循环而胡乱改动for循环的下标
  4. 避免出现依赖于循环下标最终取值的代码
  5. 考虑使用安全计数器
+ 提前退出循环
  1. 考虑在while循环中使用break语句而不使用布尔标记
  2. 小心那些有很多break散布在其中的循环
  3. 在循环开始处使用continue进行判断
  4. **如果语言支持，请使用带标号break接口**（java支持labeled break）
  5. 使用break和continue时要小心谨慎
+ 循环应该有多长
  1. 循环要尽可能地短，以便能够一目了然
  2. 把嵌套限制在3层以内
  3. 把长循环的内容移到子程序里
  4. 要让长循环格外清晰

## 16.3 轻松创建循环——由内而外

## 16.4 循环和数组的关系

# 第17章 不常见的控制结构

## 17.1 子程序的多处返回

## 17.2 递归

除非只能用递归实现，不然通常建议使用迭代替代递归

## 17.3 goto

通常不建议使用goto，除非只能用goto完成某些功能

## 17.4 针对不常见控制结构的观点

# 第18章 表驱动法

## 18.1 表驱动法使用总则

常见的查表方法：

1. 直接访问
2. 索引访问
3. 阶梯访问

## 18.2 直接访问表

## 18.3 索引访问表

## 18.4 阶梯访问表

## 18.5 表查询的其他示例

# 第19章 一般控制问题

## * 19.1 布尔表达式

用狄摩根定理简化否认的布尔判断

| 原表达式        | 等价表达式            |
| --------------- | --------------------- |
| not A and not B | not (A and B)         |
| not A and B     | not (A or not B)      |
| A and not B     | not (not A or B)      |
| A and B         | not (not A or not B)  |
| not A or not B  | not (A and B)         |
| not A or B      | not (A and not B)     |
| A ot not B      | not( not A and B)     |
| A or B          | not (not A and not B) |

## 19.2 复合语句

## 19.3 空语句

## 19.4 驯服危险的深层嵌套

## 19.5 编程基础: 结构化编程

## 19.6 控制结构与复杂度

# 第5部分 代码改善

# 第20章 软件质量概述

## 20.1 软件质量的特性

## 20.2 改善软件质量的技术

## 20.3 不同质量保障技术的相对性能

## 20.4 什么时候进行质量保证工作

## 20.5 软件质量的普遍原理

# 第21章 协同构建

## 21.1 协同开发实践概要

## 21.2 结对编程

## 21.3 正式检查

## 21.4 其他类型的协同开发实践

# 第22章 开发者测试

+ 单元测试(Unittesting)是将一个程序员或者一个开发团队所编写的，一个完整的类、子程序或者小程序，从完整的系统中隔离出来进行测试。
+ 组件测试(Component testing)是将一个类、包、小程序或者其他程序元素，从一个更加完整的系统中隔离出来进行测试，这些被测代码涉及到多个程序 员或者多个团队。
+ 集成测试（Integration testing)是对两个或更多的类、包、组件或者子系统 进行的联合测试，这些组件由多个程序员或者开发团队所创建。这种测试通 常在有了两个可以进行测试的类的时候就应该尽快开始，并且一直持续到整 个系统开发完成。
+ 回归测试（Regression testing）是指重复执行以前的测试用例，以便在原先通过了相同测试集合的软件中查找缺陷。 
+ 系统测试（System testing）是在最终的配置下（包括同其他软硬件系统的集 成)运行整个软件。以便测试安全、性能、资源消耗、时序方面的问题,以 及其他无法在低级集成上测试的问题。

## 22.1 开发者测试在软件质量中的角色

## 22.2 开发者测试的推荐方法

1. 对每一项相关的需求进行测试，以确保需要都已经被实现
2. 对每一个相关的设计关注点进行测试，以确保设计已经被实现
3. 用基础测试来扩充对需求和设计的详细测试用例
4. 使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及过去的项目中所犯的错误类型

## 22.3 测试技巧锦囊

## 22.4 典型错误

## 22.5 测试支持工具

## 22.6 改善测试过程

## 22.7 保留测试记录

# 第23章 调试

## 23.1 调试概述

## 23.2 寻找缺陷

## 23.3 修正缺陷

## 23.4 调试中的心理因素

## 23.5 调试工具——明显的和不那么明显的

# 第24章 重构

## 24.1 软件演化的类型

## 24.2 重构简介

## * 24.3 特定的重构

+ 数据级的重构
  1. 用具名变量代替神秘数值
  2. 使变量的名字更为清晰且传递更多信息
  3. 将表达式内联化
  4. 用函数来代替表达式
  5. 引入中间变量
  6. 用多个单一用途变量代替某个多用途变量
  7. 在局部用途中使用局部变量而不是参数
  8. 将基础数据类型转化为类
  9. 将一组类型码（type codes）转化为类或枚举类型
  10. 将一组类型码转化为一个基类及其相应派生类
  11. 将数组转化为对象
  12. 把群集（collection）封装球来
  13. 用数据类来代替传统记录
+ 语句级的重构
  1. 分解布尔表达式
  2. 将复杂布尔表达式转换成命名准确的布尔函数
  3. 合并条件语句不同部分中的重复代码片段
  4. 使用break或return而不是循环控制变量
  5. 在嵌套的if-then-else语句一旦知道答案就立即返回，而不是去赋一个返回值
  6. 用多态来替代条件语句（尤其是重复的case语句）
  7. 创建和使用null对象而不是去检测空值
+ 子程序级重构
  1. 提取子程序或者方法
  2. 将子程序的代码内联化
  3. 将冗长的子程序转化为类
  4. 用简单算法替代复杂算法
  5. 增加参数
  6. 删除删除
  7. 将查询操作从修改操作中独立出来
  8. 合并相似的子程序，通过参数区分它们的功能
  9. 将行为取决于参数的子程序拆分开来
  10. 传递整个对象而非特定成员
  11. 传递特定成员而非整个对象
  12. 包装向下转型的操作
+ 类实现的重构
  1. 将值对象转化为引用对象
  2. 将引用对象转化为值对象
  3. 用数据初始化替代虚函数
  4. 改变成员函数或成员数据的位置
  5. 将特殊代码提取为派生类
  6. 将相似的代码结合起来放置到基类中
+ 类接口的重构
  1. 将成员函数放到另一个类中
  2. 将一个类变成两个
  3. 删除类
  4. 去除委托关系
  5. 去掉中间人
  6. 用委托代替继承
  7. 用继承代替委托
  8. 引入外部的成员函数
  9. 引入扩展类
  10. 对暴露在外的成员变量进行封装
  11. 对于不能修改的类成员，删除相关的Set()成员函数
  12. 隐藏那些不会在类之外被用到的成员函数
  13. 封装不使用的成员函数
  14. 合并那些非常类似的基类和派生类
+ 系统级重构
  1. 为无法控制的数据创建明确的索引源
  2. 将单向的类联系改为双向的类联系
  3. 将双向的类联系改为单向的类联系
  4. 用Factory Method模式而不是简单地构造函数
  5. 用异常取代错误处理代码，或者做相反方向的变换

## 24.4 安全的重构

## 24.5 重构策略

# 第25章 代码调整策略

## 25.1 性能概述

## 25.2 代码调整简介

## 25.3 蜜糖和哥斯拉

## 25.4 性能测量

## 25.5 反复调整

## 25.6 代码调整方法总结

# 第26章 代码调整技术

## * 26.1 逻辑

+ 在知道答案后停止判断
  1. 如果语言支持，可以利用逻辑与(&&)的短路特性实现提前结束if判断
  2. for循环可以考虑几种可能的优化方案
     1. 在达到可结束循环的条件后，提前break结束循环
     2. 如果语言不支持break，则考虑通过goto跳转提前结束循环
     3. for改成while
     4. for改成while，数组最后一项之后的第一个空位置设置一个哨兵值（sentinel value），然后简单地在while中检测负值。在循环结束后，看看首先发现的值是在原数组的范围内还是在哨兵位置。
+ 按照出现频率来调整判断顺序
  1. switch-case语句可以考虑按照出现频次排列case（不同语言实现方式不同，java计算hash值再走case，所以调整case顺序并不会有提升）
  2. if-else-then语句，把出现频次高的判断提前
+ 相似逻辑结构之间的性能比较
  1. **不同语言在不同情况下，if-else-then语句和swith-case语句的执行耗时不同，可以根据实际尝试后选择耗时较短的实现**
+ 用查询表替代复杂表达式
  1. 假设3布尔变量各种搭配组合求某个值，可以考虑该用多维数组维护3布尔变量搭配组合获取的不同值
+ 使用惰性求值
  1. 仅当值真正需要被使用时，再进行计算，避免不必要的提前计算（java stream流即遇到终端操作时才会触发计算）

## * 26.2 循环

+ 将判断外提
  1. for循环内的if-else可以尝试挪到外部判断，变成if内部一个for循环，else内部一个for循环
+ 合并
  1. 对相同元素操作的多个for循环合并成一个for循环
+ 展开
  1. 增加单次for循环内执行的逻辑量。比如for循环里做下一个元素的递增操作，可以改成每次做下两个元素的递增操作，最后for循环外单独对左后一个元素做判断（算是拿可读性换性能）
+ 尽可能减少在循环内部做的工作
  1. 将循环内重复计算的值改成for循环之前计算（比如减少引用，指针跳转访问，之前提前声明好对应的指针对象）
+ **哨兵值**
  1. **在任何使用线性查找的场合，你都可以使用哨兵法——从链表到数组**。需要注意的是必须仔细选择哨兵值，并小心地把它放到数据结构中去（比如举例遍历一维数组，可以额外申请空间放哨兵值，然后减少for循环判断的条件，改成for循环内只判断哨兵值，for循环外再判断是否遍历到额外空间才寻找到哨兵值，是的话说明原先数组就没有哨兵值，不满足条件）
+ **把最忙的循环放在最内层**
  1. 双层或多层for循环，把循环次数较少的for放外面，可以减少for循环总次数（比如原本外层for100次，内层for5次，实际就是100+100x5=600次；如果改成外层for5次，内层for100次，则为5+5x100=505次）
+ **削减强度**
  1. **用多次轻量级计算代替一次代价高昂的运算（比如多次加法替代一次乘法）**

## * 26.3 数据变换

+ 使用整型数而不是浮点数
  1. 整型数的加法和乘法要比浮点数的相应运算快很多
+ 数组维度尽可能少
  1. 如果能用一维数组替代二维数组，则考虑用一维数组
+ 尽可能减少数组引用
  1. 如果访问的数组元素不变，可直接用局部变量存储数据元素，而不是每次通过引用读取数据
+ 使用辅助索引
+ 使用缓存机制

## * 26.4 表达式

+ 利用代数恒等式

  1. 通过代数恒等式，用低代价的操作替代复杂操作（比如用not (a or b)有些情况比not a and not b效率高，能减少一次not运算）

+ 削弱运算强度

  1. 用加法代替乘法
  2. 用乘法代替幂乘
  3. 利用三角恒等式代换等价的三角函数
  4. 用long或int来代替long long整数（但请注意使用机器字长的整数和非机器字长整数所带来的差异）
  5. 用定点数或整型数代替浮点数
  6. 用单精度数代替双精度数
  7. 用移位操作代替整数乘2或除2

+ **编译期初始化**

  1. 一些常用的数学计算量，可以考虑用常量维护，避免计算耗时（比如log2，可以考虑直接用近似值常量维护）

+ 小心系统函数

  1. 系统函数运行起来很慢，提供的精度常常也是根本不需要的（比如log函数只需要整型参数和整型喊回值，甚至可以直接用含有一堆if的函数直接返回int值，比老实通过浮点数计算再转整型要快很多）

+ 使用正确的常量类型

  1. 尽量避免隐式数据转化，给变量赋值时使用正确的类型

+ 预先算出结果

  1. 一些计算耗时的可列举值，可以考虑提前计算出结果以常量或缓存的形式维护（比如计算精度要求不高的情况，可以用税务速算表等形式计算大概的税额）

     通过预先计算优化程序可以有如下几种形式:

     1. 在程序执行之前算出结果，然后把结果写入常量，在编译时赋值; 
     2. 在程序执行之前计算结果，然后把它们硬编码在运行时使用的变量里; 
     3. 在程序执行之前计算结果，把结果存放在文件中，在运行时载入; 
     4. 在程序启动时一次性计算出全部结果，每当需要时去引用; 
     5. 尽可能在循环开始之前计算，最大限度地减少循环内部需要做的工作: 
     6. 在第一次需要结果时进行计算，然后将结果保存起来以备后用。

+ 删除公共子表达式

  1. 如果发现莫个表达式老是在你面前出现，就把它赋给一个变量，然后在需要的地方引用该变量，而非重新计算这个表达式

## 26.5 子程序

+ 将子程序重写为内联（特定语言特定场景下需要经过测试才能确定是否是优化）

## 26.6 用低级语言重写代码

1. 用高级语言编写整个应用程序
2. 对程序进行完整的测试，验证其正确性
3. 如果测试后发现需要改进程序性能，就对程序进行分析，确定出热点
4. 把几小段代码在低级语言中重写，以此提高整体性能（实际开发中，一些业务场景比如文件操作，如果用shell更方便，可以考虑调用shell程序而不是用当前编程语言写一套冗长的文件操作程序；或者比如在C/C++中嵌入使用汇编语言）

## 26.7 变的越多, 事情反而越没变

# 第6部分 系统考虑

# 第27章 程序规模对构建的影响

## 27.1 交流和规模



## 27.2 项目规模的范围

## 27.3 项目规模对错误的影响

## 27.4 项目规模对生产率的影响

## 27.5 项目规模对开发活动的影响

# 第28章 管理构建

# 第29章 集成

# 第30章 编程工具

